{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ blog 主题 copy 自 CTF-wiki Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":[".","无前","来","见闻","来到","io","可以","比如","可能","javascript","green","=","data","都","amber","做","?",")","事项","什么","red","purple","中","部署","局限","语言","下去","不断","未来","包含","以及","）","入口","我","知识","更新","欢迎","深入","此外","并且","局限于","what","teal","函数","deploy","将会","mdcoloraccent","并","式","以下内容","回顾","一往","采用","首先","资料","好奇","内容","色","其","目前","和","[","自","dataset","算法","deep","详细","-","localstorage","失效","梳理","了","google","button","技术","一往无前","md","坚持下去","正在","会","s","整理","较为","旧","chancezyw","主色","github","阅读","typescript","对","基本","仅仅","辅助"," ","涉及","？","编程语言","build","旅行","https","当然","grey","想","to","点击","提升","颜色","一个","自己","不断更新","实践","一门","编程","待","material","setitem","至少","addeventlistener","风景","在于","判断","function","专注","不是","buttons","body","light","你","blog","核心","浏览","学习","palette","渴望","不仅","地","默认","prototype","主要","。","而","部分","建议","primary","\"","以下","善用","call","也","一些","帮助","orange","blue","到","栈","（","更好","可","在","前端","css","时","鉴于","¶","全面","{","}","与","practice","完善","总是","(","you","其次","的","：","刷题","shuyan","将","wiki","mdcolorprimary","新","因此","yellow","，","copy","pink","var","上述","不会","请","色块","/","学识","巩固","queryselectorall","系统","click","列出","搜索","写","indigo","cyan","调用","'",",","限于","accent","gh","智慧","提问","着力","color","lime","更换","领域","管用","brown","主题","掌握","foreach","比","随时","理解","经历","面对","要","基础知识","white","array","较","两点","试图","是","经常","can","不仅仅","师","提交","colors","成为","永远","网上","保持",";","pages","相关","ctf","分支","api","基础","]","坚持","看到","document","缺失","read","语法","how","mkdocs","this","参见","关于",":","多","通过","projects","直接"],"title":"Getting Started","title_tokens":["started"," ","getting"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["无前","来到","可能","javascript","做","事项","中","局限","不断","未来","包含","以及","）","入口","我","知识","更新","欢迎","深入","此外","并且","局限于","函数","将会","并","式","以下内容","回顾","一往","内容","目前","和","算法","详细","失效","梳理","了","技术","一往无前","正在","会","s","整理","较为","旧","chancezyw","typescript","仅仅"," ","涉及","当然","想","一个","自己","不断更新","编程","待","风景","在于","判断","专注","不是","blog","核心","不仅","主要","。","而","部分","以下","也","栈","（","在","前端","css","时","鉴于","全面","完善","总是","的","shuyan","新","因此","，","上述","不会","请","系统","列出","写","调用","'","限于","着力","领域","随时","理解","经历","面对","基础知识","较","两点","试图","是","经常","不仅仅","师","成为","永远","保持","相关","api","基础","看到","缺失","参见","关于","多","projects"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":[".","。","io","可以","chancezyw","github","到","在"," ","部署","提交","https","shuyan","将","pages","分支","deploy","采用","/","其","目前","mkdocs","blog","-",":","gh","直接"],"title":"How to build？","title_tokens":["to","how","？"," ","build"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["来","。","可以","一些","基本"," ","其次","的","网上","刷题","自己","，","资料","首先","学识","巩固","语法","浏览","学习","通过"],"title":"How to practice？","title_tokens":["to","how","？"," ","practice"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["地","智慧","技术","提问","见闻","坚持下去","建议","可以","比如","javascript","善用","管用","帮助","一些","都","阅读","掌握","对","比","更好","要","什么"," ","编程语言","下去","与","语言","旅行","的","我","：","保持","提升","自己","实践","一门","编程","，","并","至少","坚持","好奇","搜索","渴望","你","google"],"title":"What can you read?","title_tokens":["read","?","what"," ","can","you"]},{"location":"#material-color-palette","text":"blog 主题 copy 自 CTF-wiki","text_tokens":["wiki","自","ctf"," ","blog","copy","-","主题"],"title":"Material color palette 更换颜色主题","title_tokens":["color","颜色","更换","material"," ","主题","palette"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":[".","button","默认","md","color","prototype","lime","primary","更换","\"","green","=","主色","call","主题","orange","data","amber","foreach","blue","可",")","red","white","array"," ","purple","{","}","(","的","grey",";","mdcolorprimary","点击","teal","setitem","yellow","pink","var","]","addeventlistener","色块","document","function","queryselectorall","[","click","dataset","indigo","deep","cyan","buttons","light","body","this","-","localstorage",",","brown"],"title":"Primary colors 主色","title_tokens":["primary","主色"," ","colors"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":[".","button","默认","md","color","prototype","lime","更换","\"","green","=","call","主题","orange","data","amber","foreach","blue",")","red","辅助","array"," ","purple","{","}","(","的",";","点击","teal","setitem","yellow","pink","mdcoloraccent","色","var","]","addeventlistener","色块","document","function","queryselectorall","[","click","dataset","indigo","deep","cyan","buttons","light","body","this","-","localstorage",",","accent"],"title":"Accent colors 辅助色","title_tokens":["辅助"," ","色","accent","colors"]},{"location":"introduction/markdown-norm/","text":"采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["中英文","专有名词","高亮","更","list","表格","标点符号","间","）","小写","and","需要","中文标点","序列表","段落","整句","github","sure","nested","强调","使用","自动","注明","仅","其內容","双引号","格式","口语化","而","建议","看做","目录","开始","不必要","空格","章节","换行","下划线","时","¶","后","git","引用","example","的","单词","当前","包括","块","/","info","配置",",","'","特殊","bug","标点","嵌套","引号","「","left","至多","无","提交","cell","语态","相关","the","页面","mkdocs",":","多","显示","中文","=","log","肯定","failure","代码","样式","abstract","为准","其他","##","适用","diff","内容","两","和","陈述句","说法","尽量","google","fenced","正确","文件","完整","遇到","作为","根据","指南","提升","划线","没有","content","酌情","warning","aligned","件夹","以便","it","header","搜索引擎","text","tip","在","与","(","admonition","词","wiki","有名","重复使用","搜索","参考","second","utf","为","无需","啰嗦","省略","”","要求","good","标识",";","当","非","语句","不必","名词","b","中英","​","体验","danger","增加","以","4","可以","“","wrapped","避免","+","?","代替","前后","语言","readme","$","flavored","foo","全角","文件名","pygments","spaces","列表","之后","#","会","`","be","多种","加","结构","半角","连","c","分隔","to","space","专有","陈述","after","正文","8","numbered","直角","js","nice","。","必要","\"","right","编码","of","将","foofoo","update","后缀","公式","indent","主题","缩进","looks","有序","bad","bar","2","重复","合理","ctf","seo","口语","」","bullet","参见","单位","大小",".","一级","原因",")","数字","居中","中","处理","用","采用","很","删除","-","block","标记","md","标题","team","反","console","阅读","省略号"," ","again","编写","表达","序列","一个","标识符","清理","排版","first","之间","两个","引擎","且","主动","插件","符号","索引","don","有","从","部分","…","空行","t","也","success","（","个","文字","question","baz","文档","规范","ide","your","，","添加","!","请","center","barbar","indenting","只","quote","字符","a","文件夹","大小写","行间","for","*","简单","英文","下划","行内","例子","1","是","行末","不","note","、","status","markdown","3","|"],"title":"Markdown Norm","title_tokens":["markdown","norm"," "]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":[".","md","搜索引擎","utf","而","建议","会","为","。","看做","字符","文件夹","原因","文件","编码","下划线","下划","使用"," ","连","处理","是","的","文档","分隔","将","指南","单词","非","一个","、","，","小写","后缀","文件名","划线","seo","之间","两个","8","引擎","搜索","参考","-","件夹","google","索引"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["一级","有","标题","从","目录","开始","空行","空格","章节","在","时","bad"," ","后","中","要求","至多","与","1","good","作为","根据","间","的","文档","仅","当","一个","，","当前","##","采用","添加","没有","/","正文","配置","且","页面","mkdocs","之后","#"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["danger","口语化","有","部分","必要","会","空行","bug","不必要","空格","多种","主题","success","换行","避免","强调","tip","啰嗦","在","肯定","failure","使用","时","自动"," ","question","中","example","表达","样式","行末","提交","admonition","的","词","abstract","ide","语态","不","note","一个","语句","、","，","不必","口语","适用","清理","内容","陈述","删除","两","需要","酌情","info","陈述句","warning","主动","说法","尽量","段落","只","插件","quote"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":[".","barbar","foo","foofoo"," ","1","baz","bar"],"title":"有序列表无需编码","title_tokens":["序列","有","序列表","列表","无需","编码"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":[".","don","。","4","可以","t","无需","空格","a","text","缩进","wrapped","也","嵌套","for","nested","*","list","?","looks","有序","简单","在","结构","时","使用","个"," ","后","again","1","of","作为","baz","2","bar","标识","当","foo","标识符","space","，","很","spaces","没有","and","after","8","the","和","numbered","bullet","列表",",","'","it","尽量","indenting","标记","3","indent","nice"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[".","fenced","`","\"","console","log","高亮",")","使用"," ","代码","语言","(","注明","文档",";","，","pygments","块","js","参见","以便","block","​"],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":[".","md","反","be","`","文件","sure","引号","使用","时","行内"," ","引用","代码","readme","to","当","your","，","update","!","且"],"title":"行内代码","title_tokens":["代码","行内"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["header","格式","以","。","right","github"," ","git","left","cell","flavored","为准","first","diff","status","center","content","markdown","-","aligned",":","|","second"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["增加","中英文","字符","标点","空格","（","数字","英文","加","行内"," ","与","代码","）","不","其他","全角","包括","之间","需要","单位","中英","中文"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["…","标点","“","引号","「","代替","使用","省略","省略号"," ","”","标点符号","用","的","规范","重复","不","重复使用","」","直角","双引号","符号"],"title":"标点符号","title_tokens":["标点","符号","标点符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["字符","标点","完整","数字","英文","遇到","使用","半角"," ","的","全角","、","，","名词","中文标点","其內容","整句","特殊","中文"],"title":"全角与半角","title_tokens":["与","半角","全角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["有名","使用","专有名词","小写","大小写","专有","正确","大小","名词","的"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["。","可以","=","a","阅读","行间","+","居中","使用","前后","文字","行内"," ","c","$","无","的","合理","提升","，","公式","b","和","显示","尽量","体验"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["指南","和","请","相关","。","参考","排版"," ","多","例子","更","内容","中文"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":[".","梁少峰","icss","精通","优质","¶"," ","rx","技巧","在线","的","个人","基础","敏捷","30","js","blog","开发","days","学习","奇淫","书单"],"title":"Learning Resources","title_tokens":["resources"," ","learning"]},{"location":"introduction/resources/#_1","text":"js 基础学习","text_tokens":["基础","学习"," ","js"],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":[".","精通","的"," ","js","blog","梁少峰","rx","技巧","个人","奇淫","days","30","icss"],"title":"优质 blog","title_tokens":["blog","优质"," "]},{"location":"introduction/resources/#_2","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":["addition","concept"," "]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["下文","上下文","上下"," ","¶","执行"],"title":"Execute Context","title_tokens":["context","execute"," "]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["下文","上下文","上下","执行"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["nowobjprops","可能","更","举个","过瘾","内部","cacheresult","nextparam","需要","arg","解构","上下","不能","reverseargs","later","来看","使用","应有","？","技巧","这样","prevparam","strict","给","绑定","ret","那么","object","不是","你","loosecurry","无法","一起","栗子","重要","some","¶","{","}","的","拆分","仍然","reduce","/","output","位置","传递","'",",","http","args","口中","onresult","cache","柯里化","「","上面","constant","parseint","current","spreadargs","uncurry","为什么","开发者","the","这个",":","identity","return","fper","v2","来","比如","=","log","reverse","做","长度","gatherargs","代码","len","每次","其他","甚至","assign","并","使得","...","过滤","v","[","和","msg","没","还","时候","if","obj","partialright","人们","如","touppercase","事实上","情况","顺序","x","error","没有","只不过","这","很多","split","我们","在","参数","y","nextargs","穿透","(","单一","起来","nan","all","则","返回","shit","多余","别的","反向","hello","应用","传入","partial","为","手动","filter","let","user","必须","只能","v1","prevargs",";","上下文","当","参数信息","map","就","]","向","b","this","兼容","argsarr","像","脑子","4","可以","一次","声明","避免","now","+","信息","propsobj","nextobjprops","p2","foo","5","unary","扰乱","接收","基于","下","会","数量","最","fn","promise1","keys","值","看起来","id","然后","12","function","操作","time","js","如何","presetpropsobj","\"","提高","因为","of",">","按照","将","presetargs","调用","params","laterargs","如下","能","curry","words","理解","要","同时","2","bar","只有","取消","else","他们","promise","但是","」","考虑","world","combinefirsttwo","curryprops","看","直接",".","\\","person","都","期望",")","反转","什么","功能","中","partialprops","偏","用","注意","高级","函数","is","很","length","不定","bind","再","upper","呢","9","方式","花哨","s","console","数传","还有"," ","_","编写","当然","then","一个","但","两个","转换","宽松","它","某些","props","有","聚合","参数传递","帮助","success","也","可","一元","因此","，","下面","右边","txt","传递函数","写","实现","只","formatfn","nextcurry","nextcurried","事实","场景","for","不太","下文","一元函数","1","是","看起","可读","不","api","可读性","喜欢","方法","更改","ajax","开发","15","不过","3","|"],"title":"Manage Function Inputs","title_tokens":["function","manage"," ","inputs"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":[".","来","可以","比如","=","log","\\","更","避免","now","做",")","举个","过瘾","中","用","p2","foo","函数","甚至","is","...","过滤","v","[","msg","arg","还","再","unary","upper","方式","花哨","s","console","人们","不能","如","fn","还有","来看","promise1","touppercase"," ","？","这样","值","看起来","给","then","一个","但","error","time","转换","你","js","某些","栗子","\"","帮助","split","success","我们","参数","{","}","一元","穿透","(",">","的","单一","起来","nan","，","all","下面","txt","/","output","传递","传递函数","shit","写","多余","'",",","别的","hello","formatfn","口中","能","words","filter","for","看","let","一元函数","constant","parseint","1","看起","2","bar",";","只有","不","map","就","]","开发者","方法","promise","b","the","但是","这个","world","开发","identity","3","|","像","脑子"],"title":"一元函数","title_tokens":["一元函数","一元","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":[".","9","有","combinefirsttwo","下","会","一起","4","console","=","log","fn","声明","+","let",")","在","使用","y","？"," ","gatherargs","1","v1","spreadargs","(",">","情况","的","bar","2","不","foo","函数","，","x","reduce","]","他们","error","...","/","12","两个","操作","更改","[","考虑","时候","5","你","兼容",",","如何","反向","15","argsarr","无法","3","呢","某些","v2"],"title":"参数的解构和聚合","title_tokens":["和","解构","参数","聚合","的"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":[".","可以","=","person","更","reverse",")","反转","功能","中","偏","用","cacheresult","函数","并","...","需要","bind","和","[","时候","obj","基于","下","上下","partialright","reverseargs","最","fn","later"," ","技巧","_","编写","当然","id","一个","绑定","function","两个","你","js","某些","这","\"","很多","也","some","可","参数","{","}","因为","(",">","的","因此","，","presetargs","右边","/","实现",",","只","http","laterargs","args","应用","partial","场景","onresult","cache","let","不太","user","下文","同时","上面","current",";","上下文","不","api","]","喜欢","但是","ajax","this",":","return","fper","直接"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":[".","传入","如下","下","像","nextcurry","=","数传","参数传递","一次","手动","curry","都","fn","柯里化","期望","let",")","要","必须","return","参数","上面"," ","{","}","长度","代码","是","偏","len","(",">","prevparam","的","给","将","每次","当","然后","一个","函数","，","else","]","很","则","nextparam","...","length","需要","不定","和","传递","考虑","[","不是","但是","调用","if","你",",","params","不过","只","接收","只不过"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["提高","信息","拆分","的","会","参数","其他","参数信息"," ","可读性","扰乱","可读"],"title":"为什么使用柯里化和偏函数？","title_tokens":["和","使用","什么","函数","？","为什么","偏","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":[".","可以","为","nextcurried","事实","=","都","fn","我们","柯里化","理解","「","let",")","上面","nextargs"," ","{","}","事实上","这样","是","len","(",">","prevargs","strict","的","内部","，","else","]","...","length","」","[","实现","if","js","loosecurry",",","return","args"],"title":"更宽松的柯里化","title_tokens":["更","宽松","柯里化","的"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["传入","数量","=","fn","for","柯里化","let",")","应有","参数"," ","{","}","中","是","of","偏","(",">","uncurry","的","仍然","当","注意","一个","函数","取消","，","ret","向","...","没有","需要","arg","返回","你","return","args"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":[".","props","nowobjprops","nextcurried","可能","=","重要","都","fn","reverse","柯里化","let",")","propsobj","参数","上面"," ","{","}","nextobjprops","只能","代码","partialprops","1","偏","keys","len","(","按照",">","顺序","的","每次","不","函数","assign","，","else","下面","使得","开发者","length","那么","位置","和","object","考虑","没","if","它","开发",",","presetpropsobj","return","curryprops"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":[".","如果","多个","关键","可以","过程","可能","空","变差","pain","=","一次","原因","常规","输出","更","声明",")","映射","让","用来","面向","什么","清楚","副作用","中","尽可","代码","修改","name","角度","偏","用","未来","包含","更新","最好","对象","名","说","这会","并且","输入","函数","式","一定","很","需要","用途","和","交易","自","值得","时候","if","字符串","能力","意识","加上","解构","会","数学","coding","或","easy","的话","参是","知道","显式","fn","叫做","含有","稳定","使用","数据"," ","？","片段","值","表达","多次","情况","给","临时","定义","清晰","一个","编程","开发人员","x","闭包","至少","没有","达式","那么","function","执行","化","不是","变得","准确","一部分","你","js","它","如何","学习","when","不赋","不传","地","把","有","部分","。","取出","也","我们","到","数据流","最后","在","参数","个","y","¶","{","}","因为","引用","后面","人员","尽可能","表达式","(",">","的","作用","赋值","或是","一部","跟踪","，","包括","惰性","则","元","抽象","上","/","当有","到底","传递","返回","调用","todo",",","更加","只","入","应用","变量","是因为","为","或者","bug","字符","前面","不同","堆栈","这些","curry","命名","明显","发人","输入输出","「","let","调试","这种","是","可读","n","只有","不","当","存储","区别","返回值","else","可读性","递归","确保","喜欢","写法","一段","外部","本质","匿名","隐含","但是","」","造成","read","关键字","这个","开发","return","通过","过于","文章"],"title":"Nature Function","title_tokens":["function"," ","nature"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["什么","函数","是"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["function","的","可以","使用","或者","关键"," ","关键字","片段","，","声明","一次","代码","这些","多次","一段","执行"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["把","多个","有","可以","或","不同","也","输出","我们","叫做","输入输出","「","含有","映射","个"," ","值","包含","的","n","输入","一个","函数","，","元","和","但是","」","准确"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["有","过程","可能","输出","输入输出","稳定","面向"," ","中","的","不","输入","函数","编程","，","式","一定","则","没有"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["「","和","」","面向","区别","过程","函数","编程","式","的"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["函数"," ","js","中","能力","的"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["如果","多个","可以","变差","空","=","更","输出",")","让","副作用","中","代码","修改","用","最好","对象","这会","并且","输入","函数","需要","和","时候","if","解构","显式","fn","使用","数据"," ","临时","一个","清晰","开发人员","x","至少","一部分","它","不赋","不传","有","部分","取出","我们","数据流","最后","参数","y","{","}","因为","人员","(",">","的","作用","赋值","一部","，","包括","则","/","当有","传递","返回",",","更加","变量","命名","明显","发人","输入输出","let","这种","可读","只有","当","不","存储","返回值","else","可读性","喜欢","写法","外部","隐含","造成","开发","return"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["应用","到","和","函数"," ","偏","curry","上"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":[".","如果","加上","会","可以","是因为","可能","bug","空","字符","前面","堆栈","为","easy","的话","参是","原因","pain","知道","命名","fn","调试","用来","在","清楚"," ","因为","尽可","引用","name","是","尽可能","未来","情况","的","更新","给","名","或是","不","一个","跟踪","函数","，","递归","coding","确保","很","抽象","匿名","需要","用途","read","交易","返回","自","这个","调用","时候","你","todo","值得",",","如何","when","只","字符串","过于","入"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["到","说","。","会","后面","文章","的"],"title":"惰性表达式","title_tokens":["惰性","表达式","表达","达式"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["增加",".","m","来","4","可以","意味","维护","=","平衡","更","都","声明","了然",")","去","举个","让","什么","转变","中","代码","自主","arr","深入","模式","函数","好处","式","并","近年","...","length","[","和","熟练","0","时候","++","了","意识","技术","会","所有","意味着","知道","阅读","潜意识","对","每","一目","数据"," ","对比","多人","过度","一个","编程","近年来","一步","化","独立","带来","命令","从","。","变成","而","栗子","干","才","也","我们","在","数据流","¶","{","}","因为","不得","总是","(","更易",">","关心","的","不得已","维护性","熟练掌握","，","下面","循环","/","细节","技术细节","协同",",","天然","应该","bug","看出","可维护性","迫不得已","年来","一下","for","结果","掌握","更少","明显","转变成","「","let","必须","不由","i","要求","1","是","2","可读","强",";","读者","命令式","人","不","map","发现","主流","可读性","得","]","一目了然","不由自主","取得","成本","3","」","事情","开发","<"],"title":"Why FP","title_tokens":["fp","why"," "]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":[".","m","来","4","可以","维护","=","了然",")","去","举个","什么","代码","自主","arr","深入","...","length","[","0","时候","++","了","意识","会","知道","阅读","潜意识","每","一目"," ","对比","一步","。","栗子","干","也","我们","在","{","}","因为","不得","(","更易",">","的","不得已","维护性","，","下面","循环","/","细节","天然",",","bug","看出","可维护性","迫不得已","一下","for","更少","明显","let","不由","i","1","2","可读","强",";","map","发现","可读性","]","一目了然","不由自主","3","<"],"title":"函数式编程带来的好处","title_tokens":["函数","好处","带来","编程","式","的"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["技术","。","而","更","声明","结果","「","让","数据流","数据"," ","代码","总是","关心","的","过度","读者","人","命令式","式","细节","」","和","技术细节","命令"],"title":"命令式 =&gt; 声明式的转变","title_tokens":[";","命令式","的"," ","转变","=","式","gt","命令","声明","&"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["应该","。","意味","所有","维护","意味着","平衡","才","都","掌握","我们","必须","去"," ","代码","是","关心","的","熟练掌握","不","一个","函数","编程","式","并","得","取得","成本","熟练","和","化","事情","开发"],"title":"代码中的平衡","title_tokens":["中","代码","平衡","的"]}]}