{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["你","实践","看到","而","更好","经历","好奇","addeventlistener","deploy","前端","一往","typescript","知识","gh","s","欢迎","基础知识","基础","不会","不仅仅","shuyan","整理","两点","到","data","编程","成为","更换","经常","brown","上述","}","{","将会","queryselectorall","鉴于","部分","blue","不断更新","式","call","pink",";","渴望","缺失","善用","面对","也","(","判断","一往无前",",","yellow","click","入口","提问","=","color","/","primary","indigo","you","随时","专注","css","想","white","chancezyw","采用","详细","grey","var","学识","green","\"","不断","永远",")",".","提升","智慧","理解","涉及","多","着力","material","lime","中","限于","一门","请","build","github","颜色","相关","色块","目前","purple","[","局限于","practice","刷题","直接","试图","函数","会","可","什么","主色","学习","网上","做","read","将","。","算法","包含","更新","teal","栈","新","?","'","foreach","一些","mkdocs","梳理","并且","当然",":","都","body","内容","mdcoloraccent","师","（","旅行","核心","其","与","不仅","写","未来","提交","系统","和","dataset","部署","colors","坚持下去","cyan","deep","在于","以下内容","调用","api","button","较为","amber","正在","完善","what","array","blog","基本","编程语言","buttons","此外","一个","主要","this","管用","比","document","并","局限","]","时","可以","搜索","md","无前","地","了","保持","风景","prototype","浏览","参见","不是","色","pages","因此","掌握","to","点击","来到","深入","https","其次","function","坚持","至少","资料","orange","待","projects"," ","分支","通过","light","辅助","回顾","语言","accent","较","默认","帮助","以下","？","语法","setitem","关于","自己","可能","¶","失效","首先","red","在","下去","我","要","对","以及","mdcolorprimary","事项","）","google","来","palette","技术","巩固","领域","how","是","仅仅","总是","，","javascript","-","旧","can","：","比如","localstorage","的","见闻","主题","列出","全面","io","阅读","建议"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["看到","而","经历","前端","一往","typescript","知识","s","欢迎","基础知识","基础","不会","不仅仅","shuyan","整理","两点","编程","成为","经常","上述","将会","鉴于","部分","不断更新","式","缺失","面对","也","判断","一往无前","入口","随时","专注","css","想","chancezyw","详细","不断","永远","理解","涉及","多","着力","中","限于","请","相关","目前","局限于","试图","函数","会","做","。","算法","包含","更新","栈","新","'","梳理","并且","当然","内容","师","（","核心","不仅","写","未来","系统","和","在于","以下内容","调用","api","较为","正在","完善","blog","此外","一个","主要","并","局限","时","无前","了","保持","风景","参见","不是","因此","来到","深入","待","projects"," ","回顾","较","以下","关于","自己","可能","失效","在","我","以及","事项","）","技术","领域","是","仅仅","总是","，","javascript","旧","的","列出","全面"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["chancezyw","采用","分支"," ","其",".","提交","deploy","部署","gh","在","github","blog","目前","shuyan","到","直接","可以","将","。","-","pages","mkdocs",":","/","io","https"],"title":"How to build？","title_tokens":[" ","build","to","how","？"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["资料","通过"," ","学识","语法","自己","首先","基本","刷题","可以","来","学习","网上","。","巩固","浏览","，","一些","的","其次"],"title":"How to practice？","title_tokens":[" ","to","how","practice","？"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["你","坚持","至少","实践","旅行"," ","更好","好奇","与","语言","提升","帮助","智慧","坚持下去","自己","一门","下去","我","编程语言","要","对","编程","管用","比","并","搜索","google","可以","什么","地","技术","保持","渴望","善用","，","javascript","一些","：","比如","提问","的","都","掌握","见闻","阅读","建议"],"title":"What can you read?","title_tokens":["?"," ","read","can","what","you"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["material","更换"," ","palette","颜色","color","主题"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["white","orange","grey"," ","var","light","green","\"",")",".","默认","addeventlistener","dataset","cyan","deep","lime","button","red","amber","array","setitem","色块","[","purple","buttons","data","this","mdcolorprimary","document","更换","可","]","brown","md","主色","{","}","queryselectorall","blue","call","pink",";","prototype","teal","(","-","foreach","yellow",",","click","localstorage","=","的","color","点击","indigo","primary","body","主题","function"],"title":"Primary colors 主色","title_tokens":["主色"," ","colors","primary"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["mdcoloraccent","orange"," ","var","辅助","light","green","\"",")","accent",".","默认","addeventlistener","dataset","cyan","deep","lime","button","red","amber","array","setitem","色块","[","purple","buttons","data","this","document","更换","]","md","}","{","queryselectorall","blue","call","pink",";","prototype","teal","(","色","-","yellow","foreach",",","click","localstorage","=","的","color","点击","indigo","body","主题","function"],"title":"Accent colors 辅助色","title_tokens":["色"," ","辅助","accent","colors"]},{"location":"introduction/markdown-norm/","text":"采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["说法","seo","其他","专有名词","需要","编码","”","部分","danger","」","章节","后","it","标识符","正确","搜索引擎","$","中英","多种",")","多","请","|","中文","缩进","quote","info","符号","排版","完整","…","?","right","分隔","mkdocs",":","readme","（","「","引用","和","整句","编写","主动","看做","格式","utf","your","baz","again","bug","搜索","md","口语化","good","空格","参见","文件名","foo","大小写","代替","文件","中文标点","例子","status","配置","center","t","文字","结构","wiki","原因","适用","有","of","下划","标记","无","双引号","是","，","-","语态","强调","有序","以便","段落","间","after","而","3","fenced","bad","ctf","don","显示","两个","note","space","update","2","一级","a","采用","英文","diff","索引",".","样式","8","居中","github","b","必要","特殊","有名","全角","内容","根据","与","以","提交","参考","时","合理","block","公式","#","text","尽量","简单","语句","nested","indenting","半角"," ","中英文","标题","在","重复","非","代码","wrapped","markdown","小写","cell","行间","省略","引擎","之后","4","增加","不","looks","列表","!","success",";",",","引号","专有","\"","c","提升","更","空行","相关","块","会","标点","bullet","不必","件夹","个","'","first","酌情","不必要","词","、","##","加","下划线","重复使用","表格","the","for","陈述句","为","行内","一个","js","从","只","可以","且","大小","包括","没有","标点符号","目录","numbered","省略号","无需","嵌套","高亮","abstract","指南","遇到","）","google","left","team","“","很","单词","其內容","规范","spaces","的","文件夹","建议","*","ide","使用","sure","口语","tip","indent","自动","正文","example","之间","肯定","字符","用","and","barbar","warning","也","(","陈述","处理","header","=","连","数字","/","flavored","序列","删除","表达","中","pygments","admonition","插件","content","文档","将","。","序列表","be","单位","反","要求","为准","两","second","啰嗦","后缀","1","​","直角","log","划线","+","添加","仅","体验","标识","避免","nice","to","行末","开始","注明","`","list","语言","question","作为","bar","¶","页面","至多","换行","当前","当","git","清理","foofoo","名词","aligned","failure","主题","console","前后","阅读"],"title":"Markdown Norm","title_tokens":[" ","norm","markdown"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["搜索引擎","而"," ","使用","seo","下划线","索引",".","引擎","后缀","参考","看做","原因","之间","8","编码","utf","划线","非","为","指南","字符","一个","文档","下划","会","搜索","google","md","小写","将","。","两个","件夹","是","、","单词","，","-","文件名","处理","分隔","文件夹","连","的","文件","建议"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["根据","采用","##","开始","配置"," ","与","作为","之后","1","标题","正文","中","在","bad","空行","有","页面","一个","至多","文档","添加","仅","从","时","且","当前","当","没有","good","#","空格","，","目录","章节","mkdocs","后","的","一级","/","要求","间"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["行末","说法","ide","两"," ","使用","不必要","多种","啰嗦","提交","口语","question","tip","主动","删除","自动","表达","样式","abstract","中","example","需要","适用","空行","在","陈述句","不","肯定","有","admonition","一个","必要","插件","bug","success","会","只","时","换行","info","quote","不必","部分","口语化","语句","warning","danger","note","陈述","空格","清理","，","语态","强调","避免","的","failure","酌情","主题","段落","尽量","内容","词","、"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["1","foo"," ","foofoo","baz","barbar",".","bar"],"title":"有序列表无需编码","title_tokens":["编码","序列","有","序列表","无需","列表"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["after","*","numbered","nested","indenting"," ","使用","list",".","t","无需","和","作为","indent","bar","1","嵌套","the","for","3","结构","8","4","在","baz","缩进","again","don","of","looks","列表","wrapped","时","可以","简单","标识","bullet","标记","and","。","当","没有","个","也","?","很","空格","'","spaces",",","text","，","foo","有序","space","2","后","nice","a","it","标识符","尽量"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["注明"," ","使用","`","\"","语言",")",".","高亮","​","pygments","fenced","log","代码","js","文档","块","block",";","(","，","参见","以便","console"],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["readme"," ","使用","引用","`","sure",".","your","行内","代码","!","时","且","md","be","当","，","反","update","引号","to","文件"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["flavored","为准","status","second"," ","center","diff","以","格式","github","|","content","markdown","left","。","git","right","cell","-","header",":","first","aligned"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["（"," ","英文","与","加","中英文","其他","中英","之间","需要","增加","中文","不","字符","行内","代码","）","标点","包括","空格","单位","数字","全角"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["「"," ","使用","省略","省略号","重复使用","直角","重复","”","不","用","标点","符号","“","双引号","…","」","标点符号","规范","引号","的","代替"],"title":"标点符号","title_tokens":["符号","标点符号","标点"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["半角"," ","使用","英文","整句","中文","字符","遇到","标点","中文标点","完整","特殊","其內容","，","名词","数字","的","全角","、"],"title":"全角与半角","title_tokens":["全角","半角","与"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有名词","使用","名词","小写","大小写","的","大小","正确","专有","有名"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["行间"," ","使用","$","c","提升","和","文字","居中","b","+","行内","显示","体验","可以","合理","公式","。","无","，","=","的","a","前后","尽量","阅读"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["多","更","例子","排版"," ","请","中文","相关","指南","。","和","内容","参考"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["rx","书单"," ",".","在线","¶","优质","梁少峰","个人","基础","blog","js","学习","奇淫","days","30","开发","精通","技巧","的","敏捷","icss"],"title":"Learning Resources","title_tokens":["resources"," ","learning"]},{"location":"introduction/resources/#_1","text":"js 基础学习","text_tokens":["基础"," ","学习","js"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["30","rx","精通","技巧"," ","梁少峰","个人","的","blog",".","奇淫","icss","js","days"],"title":"优质 blog","title_tokens":["优质"," ","blog"]},{"location":"introduction/resources/#_2","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","addition","concept"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["上下文","¶","上下"," ","下文","执行"],"title":"Execute Context","title_tokens":["execute"," ","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["下文","执行","上下","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["p2","curry","...","identity","其他","world","还有","只有","考虑","不过","需要","person","起来","下文","prevargs","promise","只能","some","is","nextargs","」","onresult","信息","ret","每次","assign","later","更改",")","仍然","期望","|","[","reverseargs","聚合","直接","什么","应有","如何","拆分","v","方法","事实","过瘾",":","constant","都","\\","user","「","12","和","上面","能","下","编写","调用","]","并","向","return","因为","不是","宽松","foo","prevparam","但是","参数","就","spreadargs","nowobjprops","function","帮助","fn","obj","传递","这样","可读","有","of","可读性","同时","then","9","重要","提高","看起","传递函数","partialright","是","filter","方式","，","别的","参数信息","combinefirsttwo","txt","只不过","你","这个","一起","没","uncurry","3","presetargs","output","unary","如下","}","{","touppercase","两个","loosecurry","看起来","绑定","2","如","穿透","反转",".","len","b","很多","函数","time","id","一次","argsarr","过滤","某些","返回","写","事实上","split","api",">","nextparam","this","时候","curryprops","let","arg","顺序","甚至","看","手动"," ","args","数量","呢","他们","在","则","还","代码","兼容","15","那么","nextobjprops","cacheresult","object","words","current","promise1","它","口中","必须","4","shit","s","不","params","扰乱","success",";","strict","console",",","laterargs","值","操作","nan","\"","5","理解","更","cache","人们","开发者","presetpropsobj","无法","else","像","再","会","可","功能","高级","'","使得","v2","不太","当然","length","upper","来看","应用","参数传递","the","for","解构","ajax","partialprops","数传","为","一个","js","只","可以","但","now","没有","我们","然后","脑子","多余","if","柯里化","all","可能","注意","举个","来","最","很","开发","技巧","msg","的","keys","使用","长度","给","按照","喜欢","propsobj","用","fper","error","也","(","一元函数","偏","基于","=","_","/","花哨","实现","场景","转换","nextcurried","x","中","上下","不定","右边","做","reduce","将","y","取消","parseint","hello","reverse","1","内部","log","+","partial","接收","传入","位置","情况","nextcurry","map","http","bind","上下文","不能","避免","因此","这","v1","下面","？","bar","¶","声明","formatfn","要","为什么","props","一元","单一","当","比如","栗子","反向","gatherargs"],"title":"Manage Function Inputs","title_tokens":["inputs"," ","manage","function"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["你","promise1","p2","这个","...","identity","world","还有","口中","只有","3","给","shit","起来","s","output","不","unary","success","用","promise","}","{","touppercase","is",";","error","(","看起来","一元函数",",","2","=","/","如","穿透","花哨","值","nan","\"","转换",")",".","更","中","人们","开发者","|","[","b","函数","像","再","做","'","v","方法","time","过瘾","constant","\\","parseint","来看","过滤","upper","某些","hello","写","能","1","the","for","split",">","log","一个","js","]","可以","但","let","now","arg","map","foo","我们","不能","避免","甚至","但是","参数","就","看","脑子"," ","多余","all","下面","帮助","？","bar","fn","传递","这样","formatfn","还","举个","then","来","一元","单一","看起","传递函数","filter","方式","开发","words","，","别的","比如","msg","的","txt","栗子","console"],"title":"一元函数","title_tokens":["一元","函数","一元函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["你","某些","更改","一起","使用"," ","...","操作","12",")","v1",".","5","下","？","x","bar","fn","呢","3","他们","考虑","1","4","声明","在",">","log","有","不","[","+","无法","函数","会","]","兼容","15","时候","9","reduce","如何","let","两个","error","情况","(","反向","，",",","foo","v2","2","=","y","的","combinefirsttwo","argsarr","/","spreadargs","console","gatherargs"],"title":"参数的解构和聚合","title_tokens":["聚合","解构","的","参数","和"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["你","...","需要","person","presetargs","下文","不","喜欢","用","fper","}","{","some","两个",";","也","(","onresult","绑定","偏",",","基于","=","_","laterargs","/","实现","later","反转","\"","场景",")",".","中","更","cache","上下","[","很多","reverseargs","直接","函数","可","功能","右边","id","不太",":","当然","user","应用","某些","reverse","和","上面","下","编写","api","ajax",">","一个","this","js","partial","并","]","只","可以","时候","let","return","http","bind","因为","上下文","但是","因此","参数","function","这"," ","args","fn","obj","同时","最","cacheresult","partialright","，","技巧","的","current"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["你","然后","curry","手动"," ","参数传递","...","长度","if","柯里化",")",".","和","上面","必须","下","考虑","不过","fn","len","调用","需要","传递","给",">","则","数传","期望","params","[","要","nextparam","一个","代码","如下","else","函数","像","]","只","不定","接收","}","{","传入","将","let","return","每次","当","nextcurry","(","是","很","偏","，",",","不是","prevparam","一次","=","都","的","但是","参数","只不过","length"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["拆分","会"," ","参数信息","信息","可读","的","其他","参数","扰乱","提高","可读性"],"title":"为什么使用柯里化和偏函数？","title_tokens":["函数","偏","什么","使用","柯里化","和","？","为什么"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["「"," ","...","args","if","柯里化","事实上",")",".","nextcurried","上面","理解","len","fn","内部","这样",">","prevargs","为","[","else","js","]","可以","}","{","let","return","loosecurry","nextargs","strict","」","是","(","事实","，",",","我们","=","的","都","length","实现"],"title":"更宽松的柯里化","title_tokens":["宽松","的","更","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["你","返回"," ","...","args","柯里化",")","uncurry","数量","仍然","fn","for","中","需要",">","注意","of","一个","函数","}","向","{","传入","应有","let","return","当","没有","arg","是","(","偏","，","=","ret","的","取消","参数"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["keys"," ","它","if","柯里化","reverse","没",")",".","下面","和","nextcurried","上面","考虑","len","fn","1","可能",">","partialprops","开发者","按照","不","presetpropsobj","代码","else","propsobj","函数","}","{","curryprops","只能","那么","重要","props","let","nextobjprops","return","assign","位置","object","(","开发","偏","，","使得",",","顺序","=","的","都","参数","每次","nowobjprops","length"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["你","尽可能","副作用","curry","这个","使用","它","本质","用来","自","只有","todo","含有","化","需要","前面","给","惰性","不","临时","字符","喜欢","coding","到","编程","用","发人","}","{","部分","常规","式","是因为","上","输入","数学","也","」","(","匿名","对象","偏",",","这种","明显","=","/","外部","不传","知道","隐含","when","pain","空","值","尽可","跟踪","加上",")","让","把",".","稳定","x","入","表达","中","更","不同","人员","过程","交易","多个","能力","else","函数","面向","会","表达式","关键字","什么","学习","多次","造成","read","如何","。","修改","包含","更加","更新","个","文章","一次","执行","并且","y","一定","区别","字符串","应用","抽象","「","返回","最后","引用","元","达式","最好","递归","未来","变差","name","和","或","数据","解构","调用","的话","参是","easy","清晰",">","存储","调试","为","一个","js","bug","变量","一部","开发人员","这会","可以","变得","堆栈","只","地","意识","时候","到底","或是","片段","let","包括","return","如果","输入输出","没有","情况","数据流","因为","清楚","不是","说","我们","但是","值得","参数","确保","或者","function","至少","通过","准确"," ","显式","if","作用","输出","？","取出","fn","原因","赋值","关键","角度","¶","映射","可能","传递","声明","闭包","在","则","有","可读","用途","定义","代码","可读性","名","命名","当有","那么","叫做","后面","一段","当","过于","是","不赋","很","这些","开发","写法","，","n","一部分","返回值","的"],"title":"Nature Function","title_tokens":[" ","nature","function"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","什么","函数"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["这些","可以","，","function","关键","关键字"," ","使用","多次","声明","一次","执行","的","片段","一段","代码","或者"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["「","值","准确"," ","元","把","输出","和","或","含有","不同","映射","有","一个","多个","函数","可以","叫做","输入输出","包含","输入","」","也","个","，","n","我们","的","但是"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":[" ","输出","稳定","中","可能","则","有","不","过程","编程","函数","面向","式","输入输出","没有","输入","，","的","一定"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["函数","面向","「","的","式","过程","和","区别","」","编程"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["函数","中"," ","的","能力","js"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["副作用","使用","它","只有","需要","不","临时","喜欢","用","发人","}","{","部分","输入","(","对象",",","这种","明显","=","/","外部","不传","隐含","空",")","让","x","中","更","人员","多个","else","函数","造成","修改","更加","y","并且","返回","最后","最好","变差","和","数据","解构","清晰",">","存储","一个","变量","一部","开发人员","这会","可以","时候","let","包括","return","如果","输入输出","数据流","因为","我们","参数","至少","显式"," ","if","作用","输出","取出","fn","赋值","传递","则","有","可读","代码","可读性","命名","当有","当","不赋","开发","写法","，","一部分","返回值","的"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["应用","函数","curry","偏"," ","和","到","上"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["你","尽可能","抽象","这个","返回","空","尽可"," ","跟踪","引用","递归","加上","未来",".","name","用来","自","todo","入","fn","原因","调用","可能","需要","的话","参是","给","前面","easy","在","调试","不","为","用途","字符","coding","交易","一个","bug","pain","函数","会","堆栈","只","可以","名","命名","时候","read","或是","如何","如果","是因为","情况","过于","更新","是","匿名","很","因为","，","清楚",",","的","值得","知道","确保","when","字符串"],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["会","说","文章","的","后面","。","到"],"title":"惰性表达式","title_tokens":["表达","惰性","表达式","达式"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["年来","近年来","而","...","一目了然","发现","模式","必须","3","自主","化","4","维护性","增加","不","每","编程","}","技术细节","{","式",";","<","++","」","也","(","了然",",","不由自主","结果","明显","2","=","一下","/","循环","知道","意味","命令","近年","不得",")",".","让","过度","更","中","转变成","[","所有","0","干","函数","会","i","什么","成本","熟练","协同","。","对比","潜意识","不由","都","要求","强","length","「","和","1","数据","for",">","去","迫不得已","一个","bug","从","]","并","可以","维护","时候","意识","let","了","好处","平衡","主流","数据流","转变","map","因为","独立","看出","我们","更少","意味着","掌握","深入","人","带来"," ","命令式","事情","取得","下面","¶","一步","一目","声明","在","不得已","可读","对","m","举个","代码","可读性","变成","天然","来","arr","技术","关心","更易","是","总是","读者","多人","开发","才","，","熟练掌握","细节","的","得","栗子","应该","可维护性","阅读"],"title":"Why FP","title_tokens":["fp"," ","why"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["...","一目了然","发现","3","自主","4","维护性","每","}","{",";","<","++","也","(","了然",",","不由自主","明显","2","=","一下","/","循环","知道","不得",")",".","[","0","干","会","i","什么","。","对比","潜意识","不由","强","length","1","for",">","去","迫不得已","bug","]","可以","维护","时候","意识","let","了","map","因为","看出","我们","更少","深入"," ","下面","一步","一目","在","不得已","可读","m","举个","代码","可读性","天然","来","arr","更易","，","细节","的","栗子","可维护性","阅读"],"title":"函数式编程带来的好处","title_tokens":["函数","带来","的","式","好处","编程"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["人","「","而"," ","命令式","让","和","过度","数据","更","声明","代码","技术细节","技术","关心","式","。","」","数据流","总是","读者","结果","细节","的","命令"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["&"," ","声明","命令式","=","的","式","gt",";","命令","转变"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":[" ","事情","取得","和","必须","化","应该","不","去","所有","代码","一个","编程","函数","并","维护","成本","熟练","关心","式","。","平衡","是","开发","才","熟练掌握","我们","意味着","的","都","掌握","得","意味"],"title":"代码中的平衡","title_tokens":["平衡","的","代码","中"]}]}