{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["永远","在","地方","projects","https","提问","目前",")","mkdocs","不会","知识","部署","全面","旅行","欢迎","资料","中","light","阅读","data","what","实践","不仅仅","判断","待","主题","foreach","直接","将","想","仅仅","javascript","¶","md","在于","师","较","并且","成为","建议","着力","teal","未来","mdcoloraccent","参见","一个","一些","的","(","[","而","基础知识","blog","（","green","谋面","帮助","好奇","blue","不断","新","比","浏览","是","dataset","智慧","栈","buttons","自己","什么","white","辅助"," ","刷题","详细","deploy","以及","？","管用","，","grey","prototype","深入","setitem","cyan","编程","缺失","语言","风景","部分","地","至少","pink","indigo","来","技术","坚持","可","算法","素未谋面","can","见闻","brown","array","颜色","可能","localstorage","核心","主要","关于","将会","总是","首先","click","。","提交","下去","当然","以下","也","可以","学习","一门","多","'","colors","局限",":","对","red","函数","要","故乡","涉及","queryselectorall","入口","局限于","amber","）",",","不断更新","到","palette","this",".","yellow","不是","其次","一往","前端","你","call","做","事项","一往无前","-","掌握","you","和","内容","编程语言","并","css","网上","默认","包含","addeventlistener","经历","时","?","善用","领域","api","practice","material","写","较为","色","to","鉴于","：","因此","学识","保持","分支","与",";","]","read","相关","面对","=","基本","限于","不仅","试图","/","\"","purple","主色","正在","旧","巩固","坚持下去","deep","比如","整理","以下内容","式","github","{","去","google","会","专注","how","此外","基础","完善","我","chancezyw","列出","看到","其","button","更换","shuyan","提升","build","色块","失效","body","来到","}","更新","document","lime","请","无前","采用","搜索","color","primary","var","点击","上述","pages","更好","两点","渴望","梳理","调用","typescript","orange","系统","那些","mdcolorprimary","经常","s","都","随时","io","回顾","gh","通过","语法","function","accent","将要","了","理解"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"#shuyan","text":"那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["永远","在","地方","projects","目前","不会","知识","全面","欢迎","中","不仅仅","判断","待","想","仅仅","javascript","在于","师","较","并且","成为","着力","未来","参见","一个","的","而","基础知识","blog","（","谋面","不断","新","是","栈","自己"," ","详细","以及","，","深入","编程","缺失","风景","部分","技术","算法","素未谋面","可能","核心","主要","关于","将会","总是","。","当然","以下","也","多","'","局限","函数","故乡","涉及","入口","局限于","）","不断更新","不是","一往","前端","做","事项","一往无前","和","内容","并","css","包含","经历","时","领域","api","写","较为","鉴于","因此","保持","相关","面对","限于","不仅","试图","正在","旧","整理","以下内容","式","去","会","专注","此外","基础","完善","我","chancezyw","列出","看到","shuyan","失效","来到","更新","请","无前","上述","两点","梳理","调用","typescript","系统","那些","经常","s","都","随时","回顾","将要","了","理解"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":[" ","在","https","deploy","到","目前","mkdocs",".","github","部署","-","直接","将","chancezyw","其","shuyan","采用","。","pages","提交","blog","可以","分支",":","io","/","gh"],"title":"How to build？","title_tokens":["how"," ","？","to","build"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":[" ","刷题","，","其次","资料","来","网上","一些","首先","的","。","可以","学识","学习","浏览","语法","通过","基本","自己","巩固"],"title":"How to practice？","title_tokens":["how"," ","practice","？","to"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["坚持下去"," ","比如","提问","管用","，","旅行","google","编程","语言","阅读","你","地","实践","至少","掌握","技术","坚持","我","编程语言","见闻","并","提升","javascript","建议","善用","搜索","一些","的","更好","下去","渴望","可以","：","好奇","帮助","保持","一门","与","比","智慧","对","都","要","自己","什么"],"title":"What can you read?","title_tokens":[" ","read","you","can","?","what"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":[" ","主题","color","material","palette","更换","颜色"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["white","deep"," ",")","this",".","yellow","grey","prototype","setitem","{","light","data","call","主题","pink","indigo","-","foreach","可","button","默认","更换","brown","色块","array","md","addeventlistener","body","}","localstorage","document","teal","lime","color","var","primary","的","click","点击","(","[","green","blue",";","]","orange","dataset","=","red","function","buttons","mdcolorprimary","queryselectorall","\"","purple","主色","cyan","amber",","],"title":"Primary colors 主色","title_tokens":["primary","主色"," ","colors"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["辅助","deep"," ",")","this",".","yellow","prototype","setitem","{","light","data","call","主题","pink","indigo","-","foreach","button","默认","更换","array","色块","addeventlistener","md","body","mdcoloraccent","localstorage","}","document","teal","lime","color","var","色","的","click","点击","(","[","green","blue",";","]","orange","dataset","=","red","function","buttons","accent","queryselectorall","\"","purple","cyan","amber",","],"title":"Accent colors 辅助色","title_tokens":["辅助"," ","colors","色","accent"]},{"location":"algorithm/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["小写","+","mkdocs","啰嗦","两","中","专有","主题","don","将","nice","md","¶","代码","|","缩进","的","failure","而","单位","（","表达","换行","根据","列表","原因","again","info","#","文件","注明","looks","避免","看做","success","a","有",":","indent",",","索引","question","陈述句","文件夹","公式","时","、","tip","log","标识符","center","与",";","utf","编码","空格","重复使用","体验","空行","github","会","good","后","bug","居中","搜索","适用","说法","console","参考","其內容","简单","必要","foofoo","文件名","*","标识","清理","seo","阅读","行内","很","content","中英","foo","大小写","省略","符号","sure","不","无需","中文","，","aligned","显示","编写","多种","作为","文档","分隔","t","后缀","为","行末","完整","数字","页面","更","之后","list","半角","left","和","语态","引擎","8","强调","example","=","the","b","ide","之间","代替","it","非","google","有序","文字","提升","需要","章节","引用","2","baz","为准","要求","1","格式","在","ctf",")","段落","增加","指南","​","其他","酌情","陈述","一个","(","高亮","整句","indenting","3","quote","and","space","双引号","至多"," ","right","只","spaces","note","wrapped","有名","一级","字符","bar","diff","4","遇到","header","wiki","以便","after","也","可以","flavored","team","名词","多","目录","text","肯定","下划","be","前后","）","直角","引号","$","下划线","first","“","重复","口语","配置","your","to","正确","numbered","`","标记","排版","自动","序列","中文标点","两个","second","fenced","例子","readme","请","搜索引擎","danger","词","主动","c","js","nested","warning","表格","block","barbar","…","专有名词","of","建议","参见","划线","用","update","合理","从","是","全角","标点","以","大小","且","语言","cell","仅","省略号","部分","markdown","使用","单词","间","不必要","「","英文","。","提交","处理","尽量","'","当","件夹","”","反","bad",".","admonition","-","内容","规范","块","?","没有","pygments","插件","!","正文","特殊","口语化","结构","##","包括","无","开始","bullet","相关","序列表","中英文","/","\"","」","个","行间","标题","status","嵌套","删除","abstract","不必","添加","for","加","标点符号","语句","采用","连","git","当前","样式"],"title":"Markdown Norm","title_tokens":[" ","markdown","norm"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":[" ","采用","ctf","编写","的","。","规范","wiki","markdown","team"],"title":"Markdown 编写规范","title_tokens":["编写"," ","规范","markdown"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":[" ","小写","索引",".","，","两个","非","原因","google","seo","会","文件夹","下划线","指南","使用","-","单词","字符","将","文件","md","看做","建议","、","连","搜索","一个","文档","引擎","分隔","的","8","后缀","为","。","划线","参考","而","处理","搜索引擎","是","utf","件夹","文件名","编码","之间","下划"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":[" ","在","根据","bad","空行","mkdocs","，","且","标题","中","仅","good","一级","后","#","添加","间","配置","时","没有","作为","采用","文档","一个","章节","正文","的","当前","目录","##","与","从","开始","有","当","要求","页面","空格","/","之后","1","至多"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":[" ","在","空行","清理","，","只","段落","啰嗦","admonition","两","question","中","info","会","部分","陈述句","删除","abstract","不必","note","使用","主题","warning","酌情","内容","bug","多种","口语","陈述","避免","时","需要","、","不必要","语句","插件","tip","一个","语态","的","适用","说法","success","行末","提交","failure","口语化","尽量","danger","词","必要","quote","有","强调","example","样式","空格","ide","自动","主动","表达","肯定","换行","不"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":[" ","baz","foofoo",".","bar","barbar","foo","1"],"title":"有序列表无需编码","title_tokens":["序列","无需","有","列表","序列表","编码"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["it"," ","在","标识","无需",".","，","列表","spaces","list","again","嵌套","nested","wrapped","使用","有序","后","和","nice","don","很","bar","4","for","looks","?","时","of","foo","缩进","没有","作为","after","8","t","。","也","a","尽量","简单","可以","标识符","结构","2","'","indenting","numbered","text","3","baz","bullet","the","当","and","标记","空格","space","indent","*","1","个",","],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[" ",")",".","，","语言","​","使用","fenced","block","注明","代码","块","以便","pygments","参见","文档","console","(","高亮","log",";","`","\"","js"],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["反"," ",".","，","且","引号","使用","行内","文件","md","代码","时","readme","your","!","引用","to","update","当","`","sure","be"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":[" ","right","github","second","aligned","cell","status","markdown","first","-","left","diff","content","header","|","。","git","flavored","center","为准",":","以","格式"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":[" ","不","中文","增加","其他","行内","字符","加","代码","中英","需要","英文","单位","（","与","包括","数字","全角","中英文","空格","之间","）","标点"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":[" ","直角","引号","省略号","“","使用","重复","…","规范","标点符号","「","的","用","省略","符号","”","双引号","重复使用","代替","」","不","标点"],"title":"标点符号","title_tokens":["标点符号","标点","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":[" ","中文","中文标点","，","半角","使用","字符","遇到","、","特殊","的","英文","其內容","整句","名词","完整","全角","数字","标点"],"title":"全角与半角","title_tokens":["全角","半角","与"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["有名","使用","小写","大小写","大小","的","专有名词","正确","专有","名词"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["行间"," ","+","，","显示","阅读","$","使用","行内","公式","和","文字","提升","居中","的","。","可以","a","尽量","合理","无","b","=","c","前后","体验"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["多","指南"," ","请","和","内容","相关","中文","。","参考","排版","更","例子"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":[" ",".","优质","基础","资源","rx","精通","书单","¶","奇淫","开发","个人","梁少峰","的","在线","icss","blog","学习","30","敏捷","技巧","days","js"],"title":"Learning Resources","title_tokens":[" ","resources","learning"]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["学习","资源"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":[" ","学习","js","基础"],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":[" ","rx","技巧","的",".","icss","精通","个人","blog","奇淫","days","js","梁少峰","30"],"title":"优质 blog","title_tokens":["blog","优质"," "]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["库存","之前","在","加强","老旧","上眼","忘记","法","知识","有利","一样","掉","讲","中","给予","e","reward","东西","试着","关联","下","穿衣服","结合","这样","很","将","小而","推断","分钟","为始","¶","在于","并且","速度","奖励","做出","向","高强","时候","助于","强度","类比","信念","一些","脑神经","有助于","的","多少","海马","睡前","以往","怎样","他","而","用","有利于","变","以后","固化","合理","上","新","制定","多用","周末","是","cue","成","马云","人","如何","不用","自己","什么","不","成大"," ","最大化","这是","根据","听","脑细胞","？","25","，","只","同时","养成","能够","分解成","穿衣","目的","认为","睡眠","栗子","细胞","复杂","至少","聪明","大脑神经","g","批判","给","神经网络","新陈代谢","每天","集中","刚","有助","普通人","如果","某些","形成","运动","信息","思考","通人","方式","大化","精力","核心","然后","「","这个","这","记住","。","突触","整个","学","数据","办法","可以","belief","也","症","学习","十遍","一段","时间","多","聚合","以终","反馈","衰弱","行为","放松","分解","对","网络","分析","白话","组块","要","一段时间","更","之后","神经元","那么","就是说","大","意识","从而","执行","就是",".","意味着","不是","一遍","闭上眼","明天","routine","代谢","快","也就是说","你","压缩包","神经","做","一点","大脑","模式","意味","生长","掌握","重复","和","做事","记忆","而是","抽象","并","内","打包","问题","难免","没有","即时","惯性","穿","最好","所以","而已","衣服","间隔","完","老","世界","危险","练习","法则","因此","重要","保持","结构","僵尸","利于","思维","开始","任务","技巧","所有","最大","这些","不管","良好","企业","高强度","单一","」","眼中","才能","让","信号","再","有限","微","习惯","复习","比如","大白","结果","克服","方向","回忆","死亡","解决","普通","隔离","去","我们","方案","看法","段时间","最","会","删除","体","产生","起来","专注","压缩","最终","性价比","集中精力","今天","番茄","工作","先","神经网","控制","然而","别人","消灭","需要","只是","接受","明白","小","能","乏味","天才","拖延","接到","长此以往","得到","就","比喻","解决方案","举个","知道","通过","都","难","智商","即使","发展","回顾","大白话","特定","精确","已有","物流","了","生成","反复"],"title":"Study&Thought","title_tokens":["study","&","thought"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["习惯","？","和","的","养成","良好","如何","学习","思考"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":[" ","在","复习","老旧","，","方向","一遍","能够","会","删除","神经","大脑","大脑神经","控制","记忆","某些","并且","信息","方式","向","时候","「","脑神经","的","记住","睡前","以往","突触","可以","长此以往","因此","重要","新","放松","网络","通过","发展","特定","」","让","生成"],"title":"大脑结构","title_tokens":["大脑","结构"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":[" ","加强","脑细胞","就是","，","有利","代谢","睡眠","体","产生","也就是说","你","细胞","神经","大脑","聪明","生长","新陈代谢","有助","助于","能","的","有助于","海马","。","突触","有利于","变","新","利于","良好","神经元","就是说","了"],"title":"良好睡眠","title_tokens":["良好","睡眠"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":[" ","在","之前","结果","，","养成","routine","你","reward","这样","做事","做出","惯性","信念","的","接到","belief","行为","cue","之后","信号"],"title":"僵尸意识","title_tokens":["僵尸","意识"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":[" ","在","比如","执行",".","，","回忆","穿衣","一样","中","e","压缩包","起来","东西","你","关联","压缩","模式","下","穿衣服","将","g","集中","打包","需要","信息","方式","穿","「","一些","这个","衣服","能","的","。","整个","重要","学习","以后","就","思维","是","成","所有","知道","组块","要","都","如何","」","什么","不"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["成大"," ","最大化","从而","就是","意味着","，","知识","同时","解决","普通","分解成","我们","方案","专注","你","有限","东西","性价比","最终","意味","掌握","将","让","普通人","问题","速度","没有","只是","通人","接受","核心","大化","小","这个","这","的","世界","天才","。","练习","办法","也","因此","保持","学习","就","上","聚合","分解","解决方案","知道","最大","要","人","智商","那么","才能","大","了","再","反复"],"title":"怎样形成组块","title_tokens":["怎样","形成","组块"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["精力","然后"," ","集中精力","这是","最好","25","克服","，","的","分钟","集中","拖延","症","办法","给予","自己","奖励"],"title":"番茄工作法","title_tokens":["工作","法","番茄"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":[" ","加强","在","不","大脑神经","，","法","忘记","能够","段时间","东西","起来","神经","大脑","掌握","番茄","重复","神经网","很","和","记忆","工作","结合","抽象","神经网络","并","内","在于","高强","强度","然后","一些","脑神经","能","的","突触","一段","也","重要","十遍","时间","学习","固化","新","是","放松","技巧","网络","这些","即使","一段时间","高强度","让","生成","反复"],"title":"间隔重复法则","title_tokens":["重复","间隔","法则"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["重复","上眼","的","乏味","，","。","人","试着","闭上眼","回顾","难免","单一","你","让","可以"],"title":"在重复中回顾","title_tokens":["重复","中","在","回顾"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":[" ","习惯","的","养成","危险","隔离","奖励","信号","微"],"title":"克服拖延症","title_tokens":["症","克服","拖延"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":[" ","只","不是","明天","最","复杂","做","今天","先","而是","小而","每天","刚","时候","完","的","制定","周末","开始","任务","难","精确","不"],"title":"如何制定任务","title_tokens":["制定","任务","如何"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["在","，","死亡","掉","会","产生","神经","一点","大脑","至少","如果","每天","所以","多少","老","的","学","而","就","衰弱","开始","人","都","不管","神经元","不用"],"title":"合理运动和学习","title_tokens":["运动","和","学习","合理"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["类比","大脑","利于","比喻","和","组块","有利","形成","有利于"],"title":"多用类比和比喻","title_tokens":["类比","比喻","多用","和"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["库存","在","，","我们","看法","快","目的","认为","栗子","然而","消灭","只是","而已","他","的","。","是","对","马云","举个","更","企业","眼中","物流"],"title":"以终为始的思维","title_tokens":["为始","的","以终","思维"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["根据","的","分析","推断","数据","去","已有"],"title":"批判思维","title_tokens":["思维","批判"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["多","大白","别人","听","你","明白","白话","的","给","，","学","更","会","大白话","讲","用","得到","东西"],"title":"即时反馈","title_tokens":["即时","反馈"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","concept","addition"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":[" ","执行","上下","下文","上下文","¶"],"title":"Execute Context","title_tokens":[" ","context","execute"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["执行","上下","下文","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["+","presetargs","中","下","柯里化","将","¶","|","应用","代码","的",">","不过","http","如","some","甚至","current","参数信息","避免","很多","可能","方式","success","onresult","arg","还有","口中","有",":","shit","要","不能",",","长度","因为","hello","strict","并","顺序","9","api","反向","接收","log","ret",";","]","nowobjprops","_","只能","ajax","txt","...","args","id","会","nextcurry","curry","filter","combinefirsttwo","上下文","可读","5","手动","console","考虑","一元函数","必须","传递","reverseargs","声明","s","object","脑子","obj","parseint","下面","为什么","很","不定","foo","unary","功能","props","[","msg","reduce","p2","不","上面","高级","偏","，","同时","扰乱","但","多余","fper","宽松","编写","给","identity","然后","这个","上下","else","为","当然","cacheresult","all","像","函数","更","事实","this","开发者","argsarr","不是","formatfn","prevargs","你","nextcurried","和","v1","then","开发","split","每次","没","promise1","\\","下文","uncurry","绑定","一元","length","技巧","b","the","=","keys","params","v2","我们","但是","只有","later","promise","实现","期望","}","需要","仍然","if","2","调用","举个","1","在",")","now","别的","参数传递","内部","person","基于","其他","reverse","向","loosecurry","时候","y","一个","laterargs","传入","值","(","bind","一起","partial","帮助","3","穿透","error","cache","如何","什么"," ","它","只","nan","场景","栗子","可","bar","4","某些","参数","信息","user","方法","这","可以","也","返回","花哨","12","呢","过滤","提高","只不过","操作","因此","重要","nextargs","len","比如","数传","两个","is","人们","拆分","一次","还","最","应有","解构","来看","位置","他们","转换","不太","let","右边","就","看","看起来","15","upper","gatherargs","如下","都","js","使得","assign","无法","v","这样","直接","情况","注意","of","用","是","更改","spreadargs","？","nextparam","取消","x","使用","output","来","则","传递函数","presetpropsobj","「","nextobjprops","'","touppercase","聚合","return","map","当","world","那么","看起",".","兼容","做","fn","过瘾","没有","可读性","写","partialright","prevparam","按照","/","\"","单一","」","再","数量","time","curryprops","{","constant","喜欢","起来","propsobj","for","words","事实上","能","反转","function","partialprops","理解"],"title":"Manage Function Inputs","title_tokens":["manage"," ","function","inputs"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":[")","now","脑子","v","别的","中","parseint","下面","这样","|","unary","foo","一个","的","值","[","(","用","帮助","msg","3","穿透",">","error","p2","不"," ","如","？","，","nan","栗子","但","多余","甚至","output","来","给","bar","identity","避免","某些","参数","传递函数","方式","这个","方法","success","可以","arg","all","'","touppercase","还有","口中","像","map","函数","shit","world","更","看起","不能",",",".","开发者","花哨","formatfn","你","做","hello","过滤","fn","过瘾","then","开发","split","promise1","写","\\","log","一元",";","]","b","the","=","/","\"","单一","再","比如","time","is","人们","{","constant","我们","但是","还","只有","...","txt","起来","promise","filter","for","}","来看","转换","words","let","能","console","一元函数","传递","就","2","看","看起来","upper","举个","s","js","1"],"title":"一元函数","title_tokens":["一元函数","一元","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":[" ","在",")","+","spreadargs","？",".","，","v2","两个","argsarr","12","无法","1","兼容","x","...","会","你","使用","呢","下","bar","情况","fn","combinefirsttwo","v1","9","4","foo","某些","5","时候","他们","y","let","反向","的","console","(","[","考虑","一起","log","操作","reduce","2","声明","3","]",">","15","有","error","=","gatherargs","函数","如何","/","更改","不",","],"title":"参数的解构和聚合","title_tokens":["聚合","和","的","解构","参数"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":[")","obj","presetargs","中","person","下","基于","直接","reverse","功能","应用","时候","一个","laterargs","的","(","[","bind","用","partial",">","cache","http","不"," ","上面","偏","some","，","只","同时","场景","fper","current","可","编写","很多","某些","参数","user","这","上下","onresult","当然","也","cacheresult","可以","return",":","函数","更",",","this",".","因为","你","和","并","fn","api","partialright","下文","绑定","因此",";","]","_","技巧","=","/","\"","ajax","两个","{","但是","...","args","喜欢","id","最","later","实现","上下文","}","需要","不太","let","右边","反转","reverseargs","function","js"],"title":"偏函数","title_tokens":["偏","函数"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["len"," ","上面","数传",")","长度","params","偏",".","，","只","nextparam","不是","{","但是","...","一次","参数传递","nextcurry","你","下","curry","柯里化","很","和","将","给","不定","则","fn","期望","代码","}","参数","需要","每次","然后","let","一个","if","手动","else","的","只不过","传入","(","[","接收","考虑","prevparam","必须","传递","return","调用","]","像","length",">","当","是","=","如下","函数","都","要","不过",","],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":[" ","其他","可读性","提高","的","参数","参数信息","可读","拆分","扰乱","会","信息"],"title":"为什么使用柯里化和偏函数？","title_tokens":["使用","？","为什么","柯里化","和","偏","函数","什么"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["len"," ","上面",",",")","事实",".","，","{","我们","...","args","内部","prevargs","nextargs","nextcurried","strict","这样","柯里化","实现","fn","}","loosecurry","「","let","if","事实上","的","else","为","(","[","可以","return","]","是","length",">","=","都","」","js","理解"],"title":"更宽松的柯里化","title_tokens":["宽松","的","更","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":[" ",")","数量","偏","，","返回","取消","{","...","args","中","你","柯里化","fn","for","应有","注意","}","of","需要","参数","没有","向","仍然","let","一个","的","传入","uncurry","(","arg","ret","return",">","是","当","=","函数"],"title":"取消柯里化","title_tokens":["取消","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["len"," ","上面",")","它","assign","偏",".","，","curryprops","开发者","keys","1","{","nextcurried","使得","下面","柯里化","和","propsobj","reverse","顺序","partialprops","fn","代码","}","开发","参数","可能","位置","presetpropsobj","每次","没","let","props","if","的","else","nextobjprops","(","考虑","重要","return","nowobjprops",">","length","=","函数","都","按照","只能","那么","object","不",","],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["对象",")","多个","在","后面","中","显式","n","赋值","清晰","外部","很","easy","化","情况","代码","¶","人员","应用","并且","的话","时候","未来","面向","y","一个","输入输出","过程","的","值","(","不传","用","上","数据流","片段","是",">","这种","如何","name","表达","什么","不"," ","pain","它","？","偏","，","只","输出","原因","编程","x","表达式","最后","地","部分","取出","使用","至少","定义","字符","跟踪","给","则","如果","映射","参数","可能","变量","一部","名","是因为","「","这个","else","。","一定","角度","命名","数据","为","当有","一段","可以","也","清楚","学习","return","关键字","文章","有","当","写法","入","函数","变得","更","那么","堆栈","达式","值得","when","更加",",","变差","意识","到","含有","执行",".","确保","返回","不是","发人","把","因为","你","字符串","匿名","和","抽象","fn","包含","明显","开发","没有","尽可能","最好","todo","可读性","交易","自","这会","闭包","尽可","数学","返回值","惰性","本质","一部分","包括","说","read","多次","常规","=","这些","隐含","/","参是","」","或者","让","个","加上","或是","存储","式","区别","调试","副作用","稳定","用来","空","前面","{","不赋","我们","但是","一次","只有","喜欢","修改","会","递归","过于","作用","关键","或","curry","bug","可读","临时","解构","}","需要","开发人员","准确","造成","能力","更新","let","叫做","if","引用","coding","元","输入","传递","用途","声明","调用","function","通过","不同","知道","js","到底"],"title":"Nature Function","title_tokens":["nature","function"," "]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","什么","函数"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["声明","使用"," ","关键","关键字","片段","执行","多次","一段","的","，","function","这些","代码","一次","可以","或者"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":[" ","多个","含有","，","输出","把","但是","我们","n","或","和","包含","映射","准确","「","一个","叫做","输入输出","的","值","元","可以","也","输入","有","函数","不同","」","个"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":[" ","式","，","稳定","输出","编程","中","则","可能","没有","面向","输入输出","过程","的","一定","输入","有","函数","不"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["「","面向","式","过程","和","的","区别","函数","编程","」"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["能力"," ","的","函数","中","js"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["对象",")","多个","中","显式","赋值","清晰","外部","代码","人员","并且","时候","y","一个","输入输出","的","(","不传","用","数据流",">","这种","不"," ","它","，","输出","x","最后","部分","取出","使用","至少","则","如果","参数","变量","一部","else","命名","数据","当有","可以","return","有","当","写法","函数","更","更加",",","变差","返回","发人","因为","和","fn","明显","开发","最好","可读性","这会","返回值","一部分","包括","=","隐含","/","让","存储","副作用","空","{","不赋","我们","只有","修改","喜欢","作用","可读","临时","解构","}","需要","开发人员","造成","let","if","输入","传递"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["上"," ","到","curry","偏","和","函数","应用"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["加上"," ","在","或是","pain","调试",".","，","只","返回","用来","空","确保","原因","因为","前面","递归","过于","会","你","字符串","匿名","字符","跟踪","很","easy","给","bug","抽象","如果","情况","fn","的话","需要","可能","更新","名","尽可能","时候","是因为","未来","todo","一个","这个","交易","的","引用","自","尽可","命名","为","coding","可以","清楚","用途","调用","read","是","入","函数","知道","如何","堆栈","参是","name","值得","when","不",","],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["说","到","文章","的","。","后面","会"],"title":"惰性表达式","title_tokens":["表达式","惰性","达式","表达"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["维护","在",")","一目","协同","增加","中","应该","阅读","过度","干","下面","得","化","好处","代码","¶","天然","独立","m","时候","一个","的","带来","[","(","而","发现","一目了然","arr","3","强","数据流","从",">","是","人","了然","<","更少","自主","什么","不"," ","，","深入","编程","熟练掌握","关心","近年来","栗子","不由自主","每","来","不得已","技术","4","近年","主流","了","「","总是","细节","一下","。","潜意识","迫不得已","数据","才","可以","也","看出","多人","map","对","函数","更",",","一步","意识","对比",".","意味着","因为","++","模式","意味","掌握","和","年来","读者","并","明显","开发","命令式","可读性","成本","i","不得","转变成",";","]","length","所有","更易","=","/","」","让","结果","式","0","{","去","命令","我们","...","熟练","会","不由","维护性","技术细节","可维护性","bug","事情","for","可读","}","平衡","取得","let","转变","变成","必须","2","声明","循环","举个","知道","要求","都","1"],"title":"Why FP","title_tokens":["fp"," ","why"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["维护","在",")","一目","阅读","干","下面","代码","天然","m","时候","的","[","(","发现","一目了然","arr","3","强",">","了然","<","自主","更少","什么"," ","，","深入","栗子","不由自主","每","来","不得已","4","了","细节","一下","潜意识","。","迫不得已","可以","也","看出","map","一步",",","意识","对比",".","因为","++","明显","可读性","i","不得",";","]","length","更易","=","/","0","{","去","我们","...","会","不由","维护性","可维护性","bug","for","可读","}","let","2","循环","举个","知道","1"],"title":"函数式编程带来的好处","title_tokens":["式","的","函数","带来","编程","好处"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":[" ","结果","式","命令","关心","过度","技术细节","技术","和","读者","代码","「","命令式","总是","的","细节","。","数据","而","声明","数据流","人","更","」","让"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["声明"," ",";","命令式","式","的","=","gt","命令","&","转变"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":[" ","维护","式","意味着","熟练","编程","我们","去","熟练掌握","应该","关心","意味","掌握","得","和","化","并","事情","代码","开发","平衡","取得","一个","成本","的","。","才","必须","是","所有","函数","都","不"],"title":"代码中的平衡","title_tokens":["中","的","平衡","代码"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":[" ","started","getting"]}]}