{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["下去","辅助","localstorage","技术","queryselectorall","旅行","¶","调用","？","颜色","addeventlistener","系统","pages","师","事项","how","dataset","都","accent","io","入口","理解","首先","实践","build","primary","内容","css","对","一往","当然","自己","不会","]","两点","欢迎","色块","而","mdcoloraccent","帮助","不是","主要","会","新","to","this","（","orange","green","function","lime","至少","鉴于","不断更新","可能","智慧","较","未来","管用","将","更好","("," ","中","比","试图","基础知识","资料","采用","以及","好奇","what","并","目前","我","无前","foreach","github","read","的","保持","mdcolorprimary","随时","请","回顾","，","通过","）","以下内容","red","坚持","pink","多","s","永远","}","其次","领域","https","chancezyw","巩固","待","deep","\"","在于","式","经历","{","google","要","默认","局限","typescript","写","一些","var","因此","setitem","。","正在","gh","更换","限于","不断","刷题","来","判断","不仅","teal","在","想","amber","提问","以下","搜索","色","基本","一门","核心","shuyan","缺失","部分","到","you","-",",","相关","参见","专注","基础","失效","'","比如","将会","来到","掌握",":","了","一个","deploy","网上","document","部署","是","上述","坚持下去","buttons","click","阅读","mkdocs","完善","[","并且","可","列出","=","blue","主色","涉及","点击","直接","和","call","风景","/","深入","栈","can","：","purple","prototype","前端","你","见闻",";","api","善用","yellow","看到","material","梳理","整理","可以","编程语言","grey","一往无前","javascript","总是","仅仅","practice","做","什么","与","详细","时","地","提升","语言","渴望","array","旧","color","主题","知识","学识","projects","palette","indigo",")","面对","也","body",".","较为","更新","包含","编程","此外","colors","blog","brown","局限于","?","全面","建议","white","关于","其","算法","提交","cyan","分支","md","学习","经常","button","不仅仅","函数","light","语法","data","浏览","成为","着力"],"title":"Getting Started","title_tokens":["started"," ","getting"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["技术","调用","系统","师","事项","入口","理解","内容","css","一往","当然","自己","不会","两点","欢迎","而","不是","主要","会","新","（","鉴于","不断更新","可能","较","未来"," ","中","试图","基础知识","以及","并","目前","我","无前","的","保持","随时","请","回顾","，","）","以下内容","多","s","永远","领域","chancezyw","待","在于","式","经历","局限","typescript","写","因此","。","正在","限于","不断","判断","不仅","在","想","以下","核心","shuyan","缺失","部分","相关","参见","专注","基础","失效","'","将会","来到","了","一个","是","上述","完善","并且","列出","涉及","和","风景","深入","栈","前端","api","看到","梳理","整理","一往无前","javascript","总是","仅仅","做","详细","时","旧","知识","projects","面对","也","较为","更新","包含","编程","此外","blog","局限于","全面","关于","算法","经常","不仅仅","函数","成为","着力"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["github","shuyan","到","-","pages",":","deploy","io","部署","mkdocs",".","https","chancezyw","blog","直接","/","其","提交","。","gh","分支","将"," ","在","采用","目前","可以"],"title":"How to build？","title_tokens":["build"," ","？","to","how"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["的","，","通过","首先","网上","学识","其次","自己","巩固","一些","。","学习","刷题","来"," ","语法","资料","浏览","基本","可以"],"title":"How to practice？","title_tokens":[" ","practice","？","to","how"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["编程语言","一门","的","技术","下去","保持","旅行","javascript","什么","与","提升","地","语言","，","比如","都","渴望","掌握","坚持","实践","坚持下去","阅读","对","我","自己","编程","建议","帮助","google","要","一些","：","至少","智慧","你","见闻","管用","更好"," ","善用","比","好奇","提问","搜索","并","可以"],"title":"What can you read?","title_tokens":["read","you","?"," ","can","what"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["color","主题"," ","palette","颜色","material","更换"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["的","grey","queryselectorall","localstorage","-",",","mdcolorprimary","addeventlistener","dataset","array","red","pink","color","主题","primary","}","document","indigo","buttons",")","click","body",".","]","[","\"","可","deep","色块","brown","=","blue","主色","点击","{","white","this","默认","call","orange","green","var","lime","purple","prototype","更换","cyan","function","setitem","md","(",";","button"," ","teal","light","yellow","data","amber","foreach"],"title":"Primary colors 主色","title_tokens":[" ","colors","主色","primary"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["辅助","的","queryselectorall","localstorage","-",",","addeventlistener","dataset","accent","red","array","pink","color","主题","}","document","indigo","buttons",")","click","body",".","]","[","\"","色块","deep","=","blue","点击","mdcoloraccent","{","this","默认","call","orange","green","var","lime","purple","prototype","更换","cyan","function","setitem","md","(",";","button"," ","teal","light","yellow","data","amber","色","foreach"],"title":"Accent colors 辅助色","title_tokens":["辅助"," ","色","accent","colors"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["符号","¶","文件夹","小写","自动","内容","重复","don","单词","a","规范","块","字符","将","引用","中英","啰嗦","两个","github","markdown","的","of","again","标记","两","）","专有名词","不必要","语句","中文","大小写","表格","info","google","半角","排版","。","8","序列表","双引号","清理","包括","-",",","success","“","'","bullet",":","一个","表达","fenced","team","it","for","mkdocs","=","和","/","编码","当前","js","陈述句","b","与","省略号","适用","时","大小","提升","没有","指南","连","right","要求","文件名","文字","引擎","代码","需要","数字","?","中英文","md","wrapped","至多","…","cell","the","简单","序列","看做","只","索引","quote","完整","口语化","代替","而","其他","口语","其內容","first","居中","从","(","强调","warning","采用","间","主动","utf","$","space","无需","，","sure","多","bug","单位","\"","bar","更","样式","编写","很","英文","and","参见","相关","例子","高亮","log","content","pygments","*","划线","aligned",";","`","语态","目录","3","list","foofoo","不必","failure","注明",")",".","分隔","#","个","wiki","left","bad","flavored","之间","非","after","用","配置","、","tip","整句","diff","good","专有","to","会","（","段落","admonition","baz","尽量","+","必要","行间","加"," ","省略","「","note","名词","标识符","请","引号","遇到","章节","多种","参考","标点","一级","c","text","根据","ide","搜索","以便","部分","下划","搜索引擎","列表","反","indent","文档","行末","当","肯定","页面","不","seo","词","全角","正文","后","且","插件","nested","有序","主题","重复使用","正确","原因","避免","spaces","也","下划线","​","建议","作为","##","前后","换行","体验","update","空格","件夹","结构","question","header","readme","中文标点","特殊","block","example","中","后缀","增加","nice","!","1","为准","center","开始","有","second","console","直角","标识","ctf","合理","abstract","酌情","your","在","缩进","标题","git","”","处理","使用","删除","barbar","说法","无","numbered","是","之后","公式","阅读","status","显示","嵌套","以","|","danger","空行","添加","仅","文件","标点符号","陈述","有名","可以","为","be","语言","looks","indenting","foo","格式","行内","4","提交","2","t","」"],"title":"Markdown Norm","title_tokens":["norm"," ","markdown"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["的","markdown"," ","ctf","。","team","编写","采用","规范","wiki"],"title":"Markdown 编写规范","title_tokens":[" ","markdown","编写","规范"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["的","件夹","-","索引","utf","处理","下划","、","为","使用","，","文件夹","搜索引擎","一个","指南","小写","连","是","原因","文档","文件名","引擎",".","下划线","分隔","参考","而","单词","建议","google","会","划线","编码","。","md","字符","将","seo","8","文件"," ","后缀","之间","非","两个","看做","搜索"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["空格","的","正文","配置","后","且","1","与","时","，","没有","一个","要求","开始","之后","文档","mkdocs","章节","有","good","当","#","作为","##","/","一级","当前","页面","空行","添加","从","bad","至多","仅"," ","中","根据","在","采用","目录","间","标题"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["空格","note","的","部分","主动","question","success","quote","适用","两","时","、","使用","插件","，","删除","tip","一个","主题","说法","不必","表达","自动","failure","内容","bug","避免","不必要","有","语句","多种","需要","行末","info","口语化","肯定","会","abstract","酌情","example","段落","口语","提交","admonition","danger","尽量","空行","样式","不","换行","必要"," ","中","强调","啰嗦","语态","ide","warning","在","陈述","陈述句","词","只","清理"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["barbar","foo","bar","foofoo"," ","1","baz","."],"title":"有序列表无需编码","title_tokens":["列表","序列表","无需","序列","编码","有"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["空格","after","of","nice","后","again","结构","3",",","1","标记","时","space","使用","有序","无需","nested","looks","list","bullet","'","没有","，","列表","numbered","indenting","indent","it","spaces","for","也",".","don","当","foo","标识符","嵌套","标识","?","bar","个","作为","和","*","a","4","baz","2","尽量","。","wrapped","text","8"," ","the","在","简单","很","t","and","缩进","可以"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["参见","语言","使用","，","注明","fenced","log","高亮",")","文档",".","代码","console","pygments","\"","​","block","块","js","(",";","`"," ","以便"],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["!","且","时","be","使用","，","引号","sure","反","readme",".","代码","当","行内","to","your","md","引用","文件"," ","`","update"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["github","markdown","-","为准","header","center",":","right","diff","content","status","second","格式","以","|","aligned","。","left","first"," ","flavored","cell","git"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["空格","包括","与","）","单位","代码","中文","数字","需要","其他","行内","中英文","（","标点","不","字符","加","中英"," ","之间","英文","增加","全角"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["用","”","符号","的","省略号","“","使用","引号","重复使用","重复","直角","代替","标点","规范","不","…"," ","标点符号","省略","双引号","「","」"],"title":"标点符号","title_tokens":["符号","标点","标点符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["的","名词","、","使用","，","整句","完整","遇到","中文标点","中文","数字","特殊","半角","标点","其內容","字符"," ","英文","全角"],"title":"全角与半角","title_tokens":["与","半角","全角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["的","小写","专有","名词","正确","有名","专有名词","大小","使用","大小写"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["的","提升","$","使用","，","无","公式","阅读","文字","显示","=","行内","b","和","a","合理","前后","尽量","。","+","c","体验","居中","行间"," ","可以"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["多","例子","参考","指南"," ","内容","更","相关","和","。","排版","中文","请"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["的","梁少峰","rx","¶","个人","基础","资源","30","优质","在线","奇淫","精通",".","days","blog","开发","技巧","书单","icss","js","学习"," ","敏捷"],"title":"Learning Resources","title_tokens":["resources"," ","learning"]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["学习","资源"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":[" ","学习","基础","js"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["30","blog","的","梁少峰","rx"," ","个人","奇淫","精通","技巧",".","days","icss","js"],"title":"优质 blog","title_tokens":["优质","blog"," "]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["分解成","用","分钟","思考","¶","结构","之前","一样","？","向","这","复杂","多少","一点","集中","结果","就","即时","都","然而","最","大化","如果","难免","对","网络","知道","而是","自己","重复","高强度","眼中","突触","库存","然后","体","大","而","以终","睡眠","形成","信号","会","新","不是","闭上眼","生成","已有","解决","法则","技巧","僵尸","抽象","cue","先","所以","变","惯性","至少","神经元","加强","我们","将","栗子","起来"," ","有利于","中","而已","拖延","穿","大脑神经","这些","微","良好","普通","「","法","下","神经网络","并","企业","g","的","生长","养成","一遍","穿衣","保持","举个","睡前","回顾","，","高强","通过","小而","有利","一段时间","关联","问题","多","同时","方式","方向","开始","做事","最终","物流","细胞","他","制定","执行","明天","大脑","强度","有限","在于","这个","去","要","更","从而","打包","合理","为始","一些","意味着","别人","因此","这是","症","。","单一","运动","海马","死亡","能","信念","才能","重要","根据","衣服","有助","在","多用","复习","很","间隔","集中精力","世界","每天","接受","掉","刚","比喻","任务","利于","练习","上","快","数据","核心","分析","明白","回忆","belief","组块","发展","聚合","通人","能够","脑神经","专注","放松","只是","固化","删除","比如","最大","掌握","了","内","再","目的","特定","是","控制","看法","性价比","之后","一段","今天","十遍","习惯","并且","新陈代谢","产生","衰弱","大白话","天才","和","上眼","难","那么","意识","记住","整个","东西","不","隔离","白话","你","即使","危险","办法","做出","不管","推断","最大化","也就是说","神经网","智商","小","时间","解决方案","完","批判","可以","试着","分解","记忆","奖励","乏味","神经","以往","就是说","讲","接到","让","最好","方案","老旧","什么","做","reward","周末","成","学","怎样","给","就是","克服","听","某些","没有","反馈","知识","精确","聪明","反复","所有","人","结合","精力","类比","长此以往","也",".","模式","压缩包","普通人","老","需要","大白","e","得到","压缩","段时间","消灭","忘记","如何","速度","不用","25","以后","马云","有助于","认为","穿衣服","脑细胞","学习","助于","工作","给予","时候","这样","行为","成大","代谢","意味","信息","routine","思维","只","」","番茄"],"title":"Study&Thought","title_tokens":["thought","study","&"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["的","学习","养成","思考","和","？","如何","良好","习惯"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["记忆","的","神经","一遍","以往","让","向","发展","老旧","能够","脑神经","放松","睡前","，","删除","通过","某些","特定","方式","方向","控制","网络","长此以往","并且","突触","大脑","会","新","生成","记住","因此","重要","时候"," ","在","复习","大脑神经","信息","「","」","可以"],"title":"大脑结构","title_tokens":["结构","大脑"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["的","生长","神经","就是说","，","就是","有利","了","聪明","细胞","突触","新陈代谢","大脑","产生","体","睡眠","新","。","变","有助于","海马","能","神经元","脑细胞","加强","助于","你"," ","有利于","也就是说","代谢","有助","良好","利于"],"title":"良好睡眠","title_tokens":["睡眠","良好"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["的","养成","之前","接到","belief","reward","结果","，","做事","之后","信号","cue","惯性","你","信念","做出"," ","这样","行为","在","routine"],"title":"僵尸意识","title_tokens":["僵尸","意识"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["g","的","穿衣","一样","回忆","组块","什么","集中","成","就","，","都","比如","关联","方式","是","所有","知道","执行","模式","压缩包",".","需要","e","压缩","这个","要","打包","如何","一些","整个","。","以后","东西","不","你","穿衣服","能","学习","将","重要","起来"," ","中","衣服","在","穿","信息","「","思维","下","」"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["分解成","的","核心","保持","这","让","通人","方案","聚合","专注","只是","就","，","世界","最大","就是","掌握","没有","了","问题","上","再","同时","大化","知识","反复","最终","人","性价比","也","知道","普通人","有限","大","这个","天才","要","从而","那么","速度","解决","意味着","因此","东西","。","你","才能","办法","将","我们","学习"," ","最大化","成大","智商","小","意味","解决方案","分解","普通","接受","练习"],"title":"怎样形成组块","title_tokens":["怎样","形成","组块"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["然后","奖励","的","分钟","办法"," ","最好","给予","这是","症","精力","拖延","集中","集中精力","自己","，","25","克服"],"title":"番茄工作法","title_tokens":["工作","法","番茄"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["记忆","的","神经","让","能够","脑神经","放松","固化","，","高强","掌握","一段时间","内","是","反复","结合","网络","也","一段","十遍","重复","高强度","突触","强度","大脑","然后","在于","段时间","和","忘记","新","生成","技巧","一些","抽象","东西","不","能","工作","即使","加强","学习","重要","起来"," ","神经网","在","时间","这些","很","大脑神经","神经网络","法","并","番茄"],"title":"间隔重复法则","title_tokens":["重复","间隔","法则"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["你","的","乏味","让","难免","上眼","人","。","闭上眼","试着","回顾","重复","，","单一","可以"],"title":"在重复中回顾","title_tokens":["在","重复","中","回顾"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["奖励","的","危险","养成"," ","信号","微","习惯","隔离"],"title":"克服拖延症","title_tokens":["症","拖延","克服"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["的","复杂","做","周末","小而","最","精确","开始","今天","而是","制定","明天","刚","不是","难","先","不"," ","时候","每天","完","只","任务"],"title":"如何制定任务","title_tokens":["如何","任务","制定"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["的","神经","一点","多少","就","学","，","都","如果","开始","人","老","大脑","产生","衰弱","而","会","不用","所以","至少","死亡","神经元","不管","在","每天","掉"],"title":"合理运动和学习","title_tokens":["合理","运动","和","学习"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["有利于","有利","和","形成","组块","类比","比喻","大脑","利于"],"title":"多用类比和比喻","title_tokens":["类比","多用","和","比喻"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["的","举个","只是","，","然而","目的","是","物流","对","他","眼中","库存","消灭","更","认为","。","马云","我们","栗子","在","而已","看法","快","企业"],"title":"以终为始的思维","title_tokens":["的","思维","为始","以终"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["的","分析","推断","去","根据","已有","数据"],"title":"批判思维","title_tokens":["思维","批判"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["你","用","的","大白","明白","多","得到","大白话","讲","更","会","别人","，","学","给","东西","听","白话"],"title":"即时反馈","title_tokens":["即时","反馈"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","concept","addition"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["下文","¶"," ","上下文","上下","执行"],"title":"Execute Context","title_tokens":[" ","execute","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["执行","上下","上下文","下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["¶","使得","nextcurried","最","返回","内部","当然","喜欢","然后","argsarr","帮助","可能","我们","将","还","两个","的","of","world","如下","p2","上下","这个","要","nextcurry","uncurry","能","v1","取消",",","success","'",":","一个","person","id","参数","for","数量","=","和","/","那么","人们","js","你","方法","curryprops","arg","laterargs","b","反向","高级","操作","事实","做","但是","then","为什么","formatfn","给","没有","如","按照","事实上","later","代码","需要","partialright","看起","不定","assign","nowobjprops","fn","时候","the","current","只","all","else","只能","都","解构","宽松","理解","它","cacheresult","split","转换","其他","this","不是","技巧","(","没","cache","甚至","nextobjprops","txt","上下文","举个","兼容","，","期望","map","方式","parseint","nextparam","\"","strict","开发","bar","更","位置","error","因此","time","重要","partialprops","编写","很","但","不太","len","log","15","presetargs","propsobj","reduce","每次","presetpropsobj",";","过瘾","is","onresult","3","应有","可读性","upper","他们","\\","ajax","12","基于","reverse","words",")","开发者","则",".","很多","object","some","如何","不过","花哨","来看","提高","看","一起","函数","return","用","这","调用","？","就","功能","注意","穿透","]","右边","prevparam","呢","接收","会","别的","情况","+","msg"," ","promise","y","「","下","并","同时","if","hello","一次","unary","v2","无法","params","下面","一元","let","过滤","下文","filter","比如","shit","[","可","当","拆分","直接","不能","不","api","手动","什么","x","口中","传递","避免","curry","也","partial","只有","props","可读","扰乱","prevargs","这样","柯里化","loosecurry","数传","user","实现","向","reverseargs","多余","值","仍然","length","传入","function","考虑","栗子","起来","gatherargs","中","声明","传递函数","1","更改","参数传递","identity","s","}","偏","5","ret","有","console","...","{","写","单一","必须","now","args","看起来","nan","来","在","绑定","output","聚合","因为","使用","再","promise1","场景","是","spreadargs","参数信息","combinefirsttwo","nextargs","bind","应用","|","touppercase","只不过","可以","上面","为","长度","某些","constant","还有","脑子","foo","fper","obj","4","v","9","2","_","一元函数","反转","http",">","顺序","像","keys","信息","」"],"title":"Manage Function Inputs","title_tokens":["manage"," ","inputs","function"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["用","？","就","穿透","多余","值","]","split","转换","帮助","别的","msg","(","我们","栗子","起来"," ","中","还","promise","甚至","的","txt","传递函数","1","举个","world","，","identity","p2","s","map","}","方式","parseint","hello","unary","console","\"","开发","bar","这个","...","{","更","下面","写","error","单一","能","now","time","看起来","nan","来","一元","let","过滤",",","filter","output","但","success","'","比如","一个","shit","再","log","promise1","参数","for","[","=","/","|","人们","touppercase","不能","不","js","你",";","过瘾","is","方法","arg","可以","b","3","做","upper","但是","then","formatfn","给","\\","某些","口中","如","传递","words","constant","还有","避免",")","脑子","开发者",".","只有","foo","看起","v","2","花哨","来看","一元函数",">","像","fn","这样","the","看","函数","all"],"title":"一元函数","title_tokens":["一元函数","一元","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["的","反向","操作",",","？","3","1","更改","他们","使用","兼容","，","12","某些","x","log",")","15","5","spreadargs",".","有","]","console","[","v2","foo","无法","=","bar","combinefirsttwo","呢","argsarr","...","会","/","如何","reduce","4","error","9","情况","+","考虑","2","不","你",">","(","fn","gatherargs","时候"," ","一起","函数","在","v1","两个","y","let","下","声明"],"title":"参数的解构和聚合","title_tokens":["的","和","聚合","参数","解构"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["用","这","实现","reverseargs","功能","最","当然","]","cacheresult","喜欢","右边","this","技巧","function","("," ","中","cache","两个","下","并","的","上下文","，","同时","}","偏","上下","\"","...","{","更","因此","args","编写","let","绑定","下文",",","因为",":","不太","一个","person","场景","id","参数","[","可","=","presetargs","bind","和","应用","直接","/","不","js","你",";","api","onresult","laterargs","可以","上面","但是","ajax","某些","基于","reverse",")","也","later",".","很多","需要","partial","partialright","fper","obj","some","_","反转","http",">","fn","时候","current","函数","return","只","user"],"title":"偏函数","title_tokens":["偏","函数"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["的","else","调用",",","上面","但是","长度","参数传递","如下","，","都","给","一个","len","期望","}","传递","偏","是","nextparam",")","curry","参数","if","则",".","一次","代码","[","]","需要","length","然后","当","=","prevparam","传入","params","{","下","和","接收","...","不是","要","不定","nextcurry","考虑","不过","必须","只不过","每次",">","像","(","你","将","fn"," ","函数","柯里化","很","return","数传","let","只","手动"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["提高","的","其他"," ","拆分","可读性","会","参数","信息","扰乱","可读","参数信息"],"title":"为什么使用柯里化和偏函数？","title_tokens":["偏","和","？","什么","函数","柯里化","为什么","使用"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["的","else","事实","实现","上面","loosecurry",",","为","nextcurried","，","都","理解","len","}","是",")","事实上","内部","if",".","]","[","strict","length","=","nextargs","...","{","prevargs","js",">","(","我们","args","fn"," ","这样","柯里化","return","「","let","」","可以"],"title":"更宽松的柯里化","title_tokens":["柯里化","的","更","宽松"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["的","of","取消","应有","向","注意","，","没有","一个","}","返回","偏","是",")","for","ret","数量","参数","仍然","需要","传入","当","=","...","{","uncurry",">","你","(","args","fn"," ","中","函数","柯里化","arg","return","let"],"title":"取消柯里化","title_tokens":["取消","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["nextobjprops","的","else",",","上面","1","使得","nextcurried","，","只能","都","len","reverse","}","偏","按照","它",")","参数","开发者","if",".","代码","object","length","=","开发","{","propsobj","和","位置","下面","那么","props","考虑","不","assign","可能","每次","顺序",">","没","(","presetpropsobj","重要","fn","partialprops"," ","nowobjprops","keys","函数","curryprops","柯里化","return","let"],"title":"高级实现","title_tokens":["实现","高级"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["用","¶","else","调用","空","关键","？","多次","能力","一部分","一定","解构","如果","返回","加上","值","它","这种","一部","知道","到底","喜欢","表达式","todo","取出","明显","文章","不是","本质","会","easy","说","稳定","function","含有","角度","情况","至少","抽象","when","可能","前面","人员","过于","(","我们","字符","自","引用","未来"," ","中","尽可","这些","y","「","作用","修改","声明","read","的","输入输出","闭包","调试","准确","，","通过","面向","}","偏","输出","bug","或者","赋值","if","coding","执行","一次","有","输入","更加","确保","返回值","开发","式","这个","{","更","变得","常规","开发人员","最后","隐含","。","发人","这会","在","n","很","化","let","清晰","上","数据","名","当有","部分","片段","到","包括","变差",",","因为","使用","外部","name","一个","表达","用来","把","是","参数","一段","递归","用途","并且","当","=","惰性","叫做","和","应用","/","那么","意识","交易","映射","的话","不","js","你","显式","后面","匿名","过程","入","可以","值得","堆栈","最好","让","可读性","不传","什么","但是","为","定义","地","给","临时","没有","副作用","多个","不同","元","x","关键字","写法","命名","不赋","传递","数据流","字符串","原因",")","curry","也","则","区别","代码",".","是因为","更新","编程","包含","需要","只有","个","如何","pain","对象","存储","造成","或是","跟踪","数学","或","可读","参是","清楚","变量",">","学习","fn","达式","时候","函数","尽可能","return","只","」"],"title":"Nature Function","title_tokens":[" ","nature","function"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","函数","什么"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["的","片段","关键字"," ","代码","关键","多次","使用","或者","这些","一段","function","执行","一次","，","可以","声明"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["的","输入输出","但是","准确","，","一个","多个","不同","元","值","把","输出","也","有","输入","包含","叫做","个","和","映射","含有","或","我们"," ","函数","n","「","」","可以"],"title":"数学角度","title_tokens":["角度","数学"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["的","输入输出","一定","，","面向","没有","输出","则","有","输入","编程","式","稳定","不","可能"," ","中","函数","过程"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["的","式","和","函数","面向","区别","过程","「","」","编程"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["的"," ","中","函数","能力","js"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["用","else","空","一部分","解构","如果","返回","它","这种","一部","喜欢","取出","明显","至少","人员","(","我们"," ","中","y","作用","修改","的","输入输出","，","}","输出","赋值","if","有","更加","输入","返回值","开发","{","更","开发人员","最后","隐含","发人","这会","let","清晰","数据","当有","部分","包括","变差",",","因为","使用","外部","一个","参数","并且","当","=","和","/","不","显式","可以","最好","让","可读性","不传","临时","副作用","x","写法","不赋","多个","数据流","传递","命名",")","则","代码","需要","只有","对象","存储","造成","可读","变量",">","fn","时候","函数","return"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["到"," ","偏","应用","和","函数","curry","上"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["值得","read","的","堆栈","调用","空",",","调试","因为","为","，","给","如果","name","一个","返回","字符串","清楚","命名","加上","bug","原因","是","知道","coding",".","递归","是因为","用途","更新","需要","确保","todo","这个","会","easy","如何","pain","或是","交易","跟踪","情况","的话","参是","抽象","不","when","可能","你","过于","前面","未来","字符","自","fn","引用"," ","时候","尽可","函数","在","匿名","很","尽可能","用来","入","只","可以","名"],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["的","到","文章","说","会","后面","。"],"title":"惰性表达式","title_tokens":["达式","惰性","表达式","表达"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["天然","技术","¶","m","可维护性","结果","一下","都","潜意识","看出","协同","对","循环","知道","]","变成","length","而","明显","会","从","(","我们","栗子"," ","中","迫不得已","得","增加","「","并","声明","的","<","每","1","举个","0","，","map","}","取得","bug","开发","式","...","{","去","更少","arr","更","下面","不由自主","意味着","。","必须","更易","关心","来","好处","一目了然","在","平衡","化","带来","let","数据","近年","熟练掌握",",","命令","因为","发现","++","转变","掌握","了","一个","命令式","是","过度","阅读","for","自主","不得已","[","干","=","成本","和","细节","/","一目","深入","意识","读者","不","一步",";","i","不得","不由","强","可以","总是","近年来","3","可读性","让","什么","熟练","维护","数据流","要求","主流","人",")","独立","了然","所有","也",".","代码","模式","应该","才","编程","事情","对比","4","2","可读","年来",">","时候","函数","转变成","意味","多人","」","技术细节","维护性"],"title":"Why FP","title_tokens":[" ","fp","why"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["天然","m","可维护性","一下","潜意识","看出","循环","知道","]","length","明显","会","(","我们","栗子"," ","迫不得已","的","<","每","1","举个","0","，","map","}","bug","...","去","{","更少","arr","下面","不由自主","。","更易","来","一目了然","在","let",",","因为","发现","++","了","阅读","for","自主","不得已","[","干","=","细节","/","一目","深入","意识","一步",";","i","不得","不由","强","可以","3","可读性","什么","维护",")","了然","也",".","代码","对比","4","2","可读",">","时候","维护性"],"title":"函数式编程带来的好处","title_tokens":["的","式","好处","函数","带来","编程"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["的","技术","总是","命令","让","结果","数据流","命令式","过度","人","代码","而","式","更","和","细节","读者","。","关心"," ","「","」","技术细节","数据","声明"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["的","=",";","式","命令式"," ","gt","命令","转变","&","声明"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["熟练掌握","的","熟练","都","掌握","一个","维护","取得","是","所有","代码","应该","才","编程","开发","式","事情","去","成本","和","意味着","。","必须","不","我们","关心"," ","函数","平衡","意味","得","化","并"],"title":"代码中的平衡","title_tokens":["平衡","代码","中","的"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":["started"," ","getting"]}]}