{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["将要","试图",":","理解","color","prototype","can","部署","编程","风景","?","不断","可以","在于","网上","缺失","默认","localstorage","gh","智慧","https","内容","通过","来","提交","其次","amber","基础","github","mkdocs","dataset","分支","坚持下去","deploy","搜索","一门","经历",")","以下内容","提问","buttons","色块","s","学识","你","shuyan","核心","我","build","而","前端","整理"," ","brown","不仅仅","入口","基础知识","）","管用","其","欢迎","teal","grey","(","mdcoloraccent","上述","鉴于","巩固","旧","系统","比","色","button","中","不会","一往无前","当然","light","关于","学习",",","palette","了","建议","首先","比如","以下","下去","详细","至少","坚持","indigo","主色","技术","you","的","/","辅助","刷题",".","目前","material","也","var","颜色","[","click","不仅","什么","事项","去","red","this","pages","保持","更好","可能","函数","成为","完善","lime","md","着力",";","chancezyw","式","待","主要","javascript","并且","旅行","参见","将","编程语言","purple","知识","{","看到","。","想","对","涉及","渴望","较为","掌握","blog","无前","到","yellow","blue","一个","]","深入","与","foreach","梳理","较","，","array","可","正在","read","此外","how","cyan","以及","写","要","\"","是","见闻","采用","accent","更新","colors","}","-","typescript","判断","setitem","都","css","仅仅","专注","和","面对","自己","primary","queryselectorall","=","function","mdcolorprimary","素未谋面","来到","资料","包含","body","api","projects","做","回顾","全面","因此","：","white","pink","¶","调用","'","部分","将会","what","算法","并","时","不断更新","会","？","未来","在","不是","（","故乡","一些","师","列出","请","总是","地方","失效","浏览","阅读","点击","领域","语言","经常","google","主题","栈","多","实践","限于","一往","基本","更换","永远","相关","io","局限","帮助","deep","call","to","好奇","两点","提升","green","document","语法","善用","那些","谋面","地","data","practice","局限于","随时","orange","addeventlistener","新","直接"],"title":"Getting Started","title_tokens":["getting"," ","started"]},{"location":"#shuyan","text":"那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["将要","试图","理解","编程","风景","不断","在于","缺失","内容","基础","经历","以下内容","s","shuyan","核心","我","而","前端","整理"," ","不仅仅","入口","基础知识","）","欢迎","上述","鉴于","旧","系统","中","不会","一往无前","当然","关于","了","以下","详细","技术","的","目前","也","不仅","事项","去","保持","可能","函数","成为","完善","着力","chancezyw","式","待","主要","javascript","并且","参见","知识","看到","。","想","涉及","较为","blog","无前","一个","深入","梳理","较","，","正在","此外","以及","写","是","更新","typescript","判断","都","css","仅仅","专注","和","面对","自己","素未谋面","来到","包含","api","projects","做","回顾","全面","因此","调用","'","部分","将会","算法","并","时","不断更新","会","未来","在","不是","（","故乡","师","列出","请","总是","地方","失效","领域","经常","栈","多","限于","一往","永远","相关","局限","两点","那些","谋面","局限于","随时","新"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":[":","blog","到","部署","可以","在","gh","https","/","提交","github","mkdocs",".","目前","分支","deploy","采用","pages","io","shuyan","-","chancezyw"," ","将","其","。","直接"],"title":"How to build？","title_tokens":["build"," ","how","？","to"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["巩固","学习","首先","可以","网上","，","一些","通过","来","浏览","的","其次","刷题","基本","学识","语法"," ","自己","。","资料"],"title":"How to practice？","title_tokens":[" ","practice","how","？","to"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["：","比","掌握","建议","并","编程","比如","可以","至少","与","坚持","下去","智慧","一些","，","技术","的","阅读","语言","要","google","坚持下去","搜索","一门","什么","实践","提问","见闻","保持","你","更好","帮助","好奇","提升","我","善用","都","地"," ","自己","旅行","编程语言","javascript","管用","对","渴望"],"title":"What can you read?","title_tokens":[" ","you","can","what","read","?"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["material","主题","颜色","更换","color"," ","palette"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["button","white","pink","light","color","prototype",",","yellow","blue","]","foreach","indigo","默认","localstorage","主色","array","可","的","cyan","点击","amber","dataset","var",".","\"","主题","click","[",")","更换","red","buttons","this","色块","deep","call","green","document","lime","-","md","}","setitem","primary","queryselectorall",";","function"," ","brown","=","purple","data","grey","mdcolorprimary","orange","{","addeventlistener","teal","(","body"],"title":"Primary colors 主色","title_tokens":["primary","主色","colors"," "]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["色","button","pink","light","color","prototype",",","yellow","blue","]","foreach","indigo","默认","localstorage","array","的","辅助","cyan","点击","amber","dataset","var",".","\"","主题","click","[",")","更换","red","buttons","this","accent","色块","deep","call","green","document","lime","-","md","}","setitem",";","queryselectorall","function"," ","data","=","purple","orange","{","addeventlistener","mdcoloraccent","teal","(","body"],"title":"Accent colors 辅助色","title_tokens":["色"," ","accent","辅助","colors"]},{"location":"algorithm/introduction/","text":"Become stronger ¶ 想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！ 变强的方法 ¶ 参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["：","方法","某位","大佬","打卡","¶","半天","了","一个","找","出来","千多","排序","时候","stronger","，","中值","的","才","不用","become","简单","！","顺序","问","感受","变强","大堆","三千多","只有","推荐","心里","想起","我","参考","加入","刷"," ","三千","小","一点","想","题","阿赖","我要"],"title":"Getting Started","title_tokens":["getting"," ","started"]},{"location":"algorithm/introduction/#become-stronger","text":"想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！","text_tokens":["：","打卡","半天","了","一个","找","出来","排序","时候","，","中值","的","才","不用","简单","！","问","感受","变强","大堆","只有","心里","想起","我","加入"," ","小","一点","想","阿赖","我要"],"title":"Become stronger","title_tokens":["become","stronger"," "]},{"location":"algorithm/introduction/#_1","text":"参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["千多","参考","某位","刷","大佬"," ","三千","三千多","了","的","推荐","题","顺序"],"title":"变强的方法","title_tokens":["变强","方法","的"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["foo","#","引用","可以","前后","…","markdown","没有","只","仅","处理",")","必要","question","换行","参考","）","wiki","block","(","diff","good","当","序列表","bullet","避免","显示","肯定","second","的","文件","status","块","标识","a","fenced","md","下划","增加","间","体验","一个","符号","barbar","标识符","之间","搜索引擎","语态","left","页面","当前","utf","无需","双引号","英文","公式","阅读","语言","google","##","right","js","清理","语句","提升","强调","success","省略","spaces",":","根据","indenting","适用","为","文件名","标题","正文","内容","一级","be","酌情","提交","looks","包括","github","看做","嵌套","failure","加","且","而","格式","first","t","重复","要求","结构","ctf","多种","中文标点","建议","数字","update","规范","整句","team","也","indent","、","陈述句","小写","后","!","非","章节","排版","中文","。","baz","cell","指南","」","特殊","，","分隔","个","段落","header","是","划线","采用","the",";","和","作为","=","表格","after","之后","其他","引擎","全角","sure","again","（","单词","重复使用","字符","开始","例子","相关","主动","bad","空格","ide","至多","text","aligned","删除","console","​","danger","遇到","don","标点符号","为准"," ","陈述","居中","space","编码","合理","中","高亮","反","不必","bar","admonition","/","and","有名",".","4","warning","省略号","使用","说法","example","tip","将","*","文字","content","件夹","b","连","口语化","文件夹","pygments","不必要","wrapped","nice","索引","中英","很","自动","”","有","文档","flavored","代替","3","¶","中英文","会","需要","原因","在","for","无","编写","请","引号","名词","主题","多","to","两个","of","your","直角","完整","更","正确","+","?","空行","git","用","note","mkdocs","center","搜索","`","list","quote","两","log","“","info","尽量","目录",",","8","abstract","bug","不","代码","以","标记","半角","参见","行内","专有","缩进","与","标点","readme","后缀","添加","\"","「","下划线","插件","配置","注明","以便","表达","专有名词","从","有序","-","1","大小","foofoo","numbered","单位","词","口语","'","部分","c","其內容","时","nested","序列","2","$","大小写","行末","样式","简单","行间","列表","it","seo","啰嗦","|"],"title":"Markdown Norm","title_tokens":["norm"," ","markdown"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["。"," ","采用","规范","ctf","编写","的","markdown","wiki","team"],"title":"Markdown 编写规范","title_tokens":["编写"," ","markdown","规范"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["文档","编码","8","建议","引擎","件夹","会","指南","一个","连","原因","文件名","文件夹","为","，","单词","字符","后缀","分隔","的","文件","之间",".","搜索引擎","google","索引","下划线","、","搜索","处理","看做","是","小写","划线","使用","seo","md","-","非","两个","参考","而","下划"," ","将","utf","。"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["有","文档","之后","中","至多","目录","要求","good","当","根据","#","时","一个","空行","与","在","标题","，","正文","一级","的","/","添加","没有","mkdocs","开始","仅","配置","##","采用","从","后","1","章节","且","bad","空格"," ","作为","页面","当前","间"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["口语","有","尽量","info","ide","中","不必","部分","多种","时","避免","会","适用","一个","空行","肯定","需要","口语化","在","，","不必要","内容","行末","admonition","的","酌情","删除","note","提交","段落","abstract","bug","样式","只","语态","主题","不","插件","、","warning","陈述句","danger","必要","表达","使用","主动","清理","说法","语句","quote","failure","啰嗦","question","换行","example","tip","两","空格"," ","陈述","强调","自动","success","词"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["1","foofoo","bar","foo"," ","barbar","baz","."],"title":"有序列表无需编码","title_tokens":["有","编码","序列表","列表","无需","序列"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["spaces","尽量","text","缩进","3","当",",","'","8","foo","结构","bullet","时","nested","indenting","?","可以","2","在","again","for","bar","，","t","wrapped","标识符","个","looks","and","没有","nice","简单",".","也","4","indent","嵌套","标识","list","列表","a","使用","don","后","有序","it","标记","the","of","1","numbered","和","空格"," ","作为","很","*","无需","after","space","。","baz"],"title":"嵌套列表","title_tokens":["列表","嵌套"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["文档","高亮","pygments","，","console","语言",".","\"","块","​",")","注明","以便","`","代码","使用","js","fenced",";"," ","参见","log","block","("],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["反","当","时","update","引用","sure","，","be","readme","引号","文件",".","`","代码","使用","!","to","md","且","your"," ","行内"],"title":"行内代码","title_tokens":["代码","行内"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["content","flavored",":","cell","aligned","git","second","markdown","github","header","center","left","status","right","以","-","为准"," ","格式","first","。","|","diff"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["其他","中英文","英文","数字","全角","与","需要","（","标点","字符","之间","包括","不","代码","中英","加","空格"," ","中文","增加","行内","）","单位"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["省略","双引号","代替","」","符号","用","标点","规范","…","重复使用","引号","的","「","不","省略号","使用","标点符号"," ","直角","“","”","重复"],"title":"标点符号","title_tokens":["标点符号","标点","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["英文","中文标点","其內容","数字","全角","特殊","，","标点","整句","字符","的","名词","、","遇到","使用","半角","中文"," ","完整"],"title":"全角与半角","title_tokens":["全角","与","半角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有","大小","正确","小写","大小写","专有名词","使用","的","名词","有名"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["尽量","合理","c","体验","+","b","可以","显示","前后","，","$","无","公式","的","阅读","行间","a","使用","提升","和"," ","行内","居中","=","文字","。"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["多","排版","参考","更","和","例子"," ","中文","内容","请","相关","指南","。"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["在线","开发","blog","学习","¶","days","icss","资源","rx","优质","30","的","基础",".","个人","技巧","书单","js","奇淫","敏捷","精通"," ","梁少峰"],"title":"Learning Resources","title_tokens":["resources"," ","learning"]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["资源","学习"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":["学习","基础"," ","js"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":[".","精通","个人","技巧","rx","blog"," ","30","days","梁少峰","的","js","icss","奇淫"],"title":"优质 blog","title_tokens":["优质","blog"," "]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多 五分钟起步法 ¶ 遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["看法","上眼","如何","cue","段时间","可以","形成","时候","有限","消灭","就是说","通过","复杂","没有","智商","只","类比","你","世界","所以","核心","复习","细胞","抽象","神经","惯性","不想","信号","库存","起来","分解成","练习","接到","而是","的","制定","组块","什么","内","某些","更好","大化","危险","大白","对","明白","就","方向","也就是说","最","马云","工作","死亡","打包","普通人","人","解决方案","完","做","因此","数据","新陈代谢","这是","以往","法","乏味","长此以往","穿衣","通人","一样","隔离","掉","脑神经","东西","推断","信念","所有","根据","重要","白话","最终","固化","再谈","利于","先","这个","而","加强","压缩","重复","代谢","结构","穿","回忆","快","我们","也","已有","执行","大白话","五分钟","老旧","养成","并且","普通","集中精力","穿衣服","精力","脑细胞","。","刚","下","」","有利于","模式","，","要","是","集中","一段时间","方案","企业","讲","和","奖励","25","自己","眼中","拖延","之后","睡前","其他","思维","g","不是","海马","生长","目的","开始","高强","办法","才能","大脑","再","记忆","十遍","高强度","认为","得到","精确","如果","在于","大","别人","小而","删除","性价比","任务","闭上眼","神经网络","栗子","五分"," ","e","分钟","合理","中","明天","网络","难","一段","习惯","信息","至少","睡眠","单一","控制",".","强度","然后","去","从而","保持","这些","而已","将","知识","难免","能","衰弱","意识","速度","起步","以后","良好","让","间隔","向","放松","belief","都","番茄","做出","很","怎样","回顾","反复","¶","聪明","反馈","会","？","行为","听","需要","上","在","一些","接受","分解","多","试着","然而","小","最大化","最大","体","成大","更","只是","整个","用","结合","结果","遇见","不用","物流","一遍","给","关联","意味着","分析","为始","变","法则","成","产生","学习","了","运动","忘记","比如","即时","助于","有助于","聚合","他","不","微","今天","即使","每天","发展","同时","知道","衣服","学","比喻","一点","突触","批判","压缩包","多用","天才","掌握","最好","克服","以终","特定","之前","症","僵尸","意味","记住","那么","就是","时间","「","思考","多少","这样","专注","有利","周末","有助","routine","reward","给予","并","老","生成","神经元","能够","这","问题","不管","做事","技巧","神经网","但是","方式","解决","大脑神经","举个","新","事情"],"title":"Study&Thought","title_tokens":["thought","&","study"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["习惯","养成","思考","和","如何","学习","良好","的","？"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["因此","睡前","方向","神经","网络","特定","会","」","生成","可以","信息","能够","在","时候","以往","，","让","记住","通过","的","删除","重要","控制","向","长此以往","「","放松","某些","一遍","大脑","发展","老旧","方式","脑神经","复习","记忆"," ","并且","大脑神经","突触","新"],"title":"大脑结构","title_tokens":["大脑","结构"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["产生","。","体","神经","代谢","能","聪明","新陈代谢","也就是说","了","有利于","助于","有助于","神经元","睡眠","，","良好","海马","就是说","就是","的","生长","大脑","你","利于","细胞","有利"," ","有助","脑细胞","变","突触","新","加强"],"title":"良好睡眠","title_tokens":["睡眠","良好"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["routine","之后","reward","cue","信念","之前","惯性","信号","行为","在","接到","，","结果","的","做事","belief","你","养成","这样"," ","做出"],"title":"僵尸意识","title_tokens":["僵尸","意识"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["成","压缩包","东西","中","如何","学习","思维","下","g","能","所有","比如","」","整个","信息","起来","需要","在","穿","模式","一些","，","以后","回忆","的","重要","要",".","组块","「","就","不","执行","打包","穿衣","什么","是","集中","你","一样","这个","关联","知道","方式","都"," ","衣服","穿衣服","将","e","。","压缩"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["因此","东西","天才","掌握","成大","反复","学习","只是","了","速度","分解成","聚合","大","练习","上","有限","意味","，","这","问题","接受","让","那么","就是","的","没有","最终","要","智商","我们","分解","也","性价比","办法","才能","普通人","从而","通人","保持","你","世界","这个","方案","再","同时","知道","人","核心","意味着","大化","解决","专注"," ","普通","小","将","解决方案","最大化","知识","最大","。","就"],"title":"怎样形成组块","title_tokens":["组块","怎样","形成"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["分钟","症","办法","然后","最好","，","克服","集中精力","25"," ","自己","奖励","给予","集中","精力","的","拖延","这是"],"title":"番茄工作法","title_tokens":["番茄","工作","法"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["东西","掌握","反复","网络","神经","学习","能","并","段时间","忘记","生成","一段","在于","起来","能够","在","，","结合","法","一些","让","的","工作","时间","重要","固化","也","高强","技巧","强度","然后","不","即使","是","内","放松","大脑","神经网络","神经网","一段时间","这些","脑神经","记忆","十遍","和","番茄"," ","很","高强度","抽象","大脑神经","突触","新","加强","重复"],"title":"间隔重复法则","title_tokens":["间隔","法则","重复"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["人","回顾","，","单一","上眼","闭上眼","让","的","难免","你","试着","。","乏味","可以","重复"],"title":"在重复中回顾","title_tokens":["中","回顾","在","重复"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["习惯","隔离","养成","微"," ","奖励","的","信号","危险"],"title":"克服拖延症","title_tokens":["症","拖延","克服"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["做","明天","难","不是","时候","而是","最","小而","复杂","的","制定","只","开始","不","任务","今天","每天","先","周末"," ","完","刚","精确"],"title":"如何制定任务","title_tokens":["任务","制定","如何"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["产生","神经","如果","老","会","衰弱","神经元","至少","在","，","不管","的","不用","死亡","开始","大脑","每天","所以","人","掉","多少","而","都","学","一点","就"],"title":"合理运动和学习","title_tokens":["和","运动","学习","合理"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["组块","形成","和","有利","类比","比喻","大脑","利于","有利于"],"title":"多用类比和比喻","title_tokens":["类比","多用","和","比喻"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["看法","更","只是","库存","在","消灭","，","马云","他","的","快","目的","物流","我们","是","企业","然而","栗子","而已","对","眼中","举个","。","认为"],"title":"以终为始的思维","title_tokens":["以终","为始","思维","的"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["分析","已有","数据","去","推断","根据","的"],"title":"批判思维","title_tokens":["批判","思维"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["用","听","多","东西","大白","讲","更","，","大白话","别人","学","给","的","你","会","白话","得到","明白"],"title":"即时反馈","title_tokens":["即时","反馈"]},{"location":"introduction/study-thought/#_18","text":"遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["分钟","做","会","五分","，","五分钟","再谈","其他","遇见","了","的","更好","不想","先","事情","但是"],"title":"五分钟起步法","title_tokens":["分钟","五分","起步","五分钟","法"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":["concept","addition"," "]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["执行"," ","¶","下文","上下","上下文"],"title":"Execute Context","title_tokens":["execute"," ","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["上下","下文","执行","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/composing-functions/","text":"","text_tokens":[],"title":"Composing Function","title_tokens":["function","composing"," "]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器 Point Style ¶ 当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["propsobj","foo","如何","可以","时候","curryprops","通过","来","nextobjprops","argsarr","没有","只","style",")","_","实现","反向","你","前面","仍然","柯里化","(","combinefirsttwo","parseint","...","当然","当","避免","presetpropsobj","起来","轻易","的","reduce","[","什么","12","某些","内置","不太","let","参数","15","length","error","promise","就","传递函数","]","一个","取消","txt","最","一起","tostring","time","事实上","len","穿透","id","转换","split","做","因此","identity","绑定","一元函数","喜欢","器","world","看","但","http","只有","v","js","帮助","上下","partialprops","拆分","success","直接","not","y","方法",":","提高","编程","all","later","nowobjprops","叫做","为","数量","重要","v2","参数传递","x","s","这个","else","p2","props","它","不动","长度","我们","把","也","别的","return","下面","兼容","函数","!","current","砍掉","不过","。","object","loosecurry","下","完全","」","arg","反转","多余","，","\\","要","spreadargs","filter","是","则","没法","}","the","upper",";","assign","和","=","又","user","很多","isshortenough","其他","不是","扰乱","addthree","可读性","内部","值","例子","无法","场景","功能","fper","ret","操作","另","再","手动","msg","if","point","cacheresult","相反","人们","理解","按照","laterargs","如果","如下","partial","nextcurried","then","console","output","obj","脑子","位置","如","没","优化","uncurry","数传","formatfn","栗子","constant"," ","情况","风格","转发","中","prevargs","返回","unary","可是","信息","<","bar","单一","/",".","应用","那个","4","来看","然后","shit","像","使用","每次","fn","map","口中","传递","偏","将","{","应有","只能","能","person","b","还","解构","让","可","一元","基于","因为","向","写","reverse","gatherargs","必须","some","参数信息","他们","注意","bind","接收","都","function","很","这一","高级","花哨","过瘾","考虑","有","3","¶","更改","args","hello","touppercase","5","会","？","prevparam","开发者","需要","在","for","编写","下文","期望","两个","of","幸好","v1","事实","更","9","ajax","+","类似","用","now","遇见","给","一次","log","islongenough","拿到","开发",",","看起来","比如","可读","聚合","words","promise1","使得","顺序","不","this","还有","代码","可能","同时","params","不能","声明","之前","上面","curry","呢","那么","\"","「","右边","reverseargs","过滤","原封","传入","不定","1","nan","判断","这样",">","api","宽松","只不过","调用","'","keys","并","strict","甚至","2","partialright","cache","原封不动","这","为什么","presetargs","技巧","装饰","列表","但是","上下文","方式","is","nextargs","onresult","看起","nextcurry","nextparam","举个","|"],"title":"Manage Function Inputs","title_tokens":["inputs","function","manage"," "]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["人们","方法","更","foo","all","可以","用","now","来","then","console","output",")","脑子","给","你","s","如","这个","formatfn","p2","栗子","constant"," ","log","(","parseint","开发","中","...",",","看起来","避免","unary","比如","起来","words","bar","单一","的","/","promise1","我们",".","不","[","来看","别的","shit","还有","某些","下面","像","fn","函数","map","口中","let","参数","传递","error","{","promise","就","传递函数","不能","能","b","]","一个","还","arg","txt","多余","，","time","一元","\\","写","\"","filter","过滤","}","the","upper","1","穿透","nan","这样",";","=","花哨","过瘾","转换","split",">","做","identity","3","'","hello","touppercase","？","甚至","2","开发者","一元函数","for","world","看","但","值","只有","v","js","帮助","再","但是","方式","is","看起","success","msg","举个","|"],"title":"一元函数","title_tokens":["函数","一元","一元函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["有","combinefirsttwo","y","9","foo","如何","3",",","下","...","更改","声明","5","会","+","？","]","2","呢","在","时候","bar","，","一起","的","/","reduce","console","argsarr",".","v2","4","不","[","gatherargs","12",")","spreadargs","x","无法","某些","他们","兼容","反向","使用","你","fn","函数","操作","let","两个","1","15","v1"," ","=","log","error","情况","(","考虑",">"],"title":"参数的解构和聚合","title_tokens":["参数","聚合","解构","和","的"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":[":","更","laterargs","ajax","later","可以","用","时候","partial","只","obj",")","_","实现","你"," ","(","中","...","当然",",","的","/",".","应用","也","不","[","return","this","某些","不太","fn","函数","let","同时","current","参数","偏","{","下","person","上面","]","一个","反转","，","最","可","基于","因为","\"","reverse","右边","reverseargs","some","}","bind",";","和","function","id","=","user","很多",">","api","因此","args","并","绑定","需要","喜欢","cache","partialright","这","编写","presetargs","下文","http","技巧","场景","功能","js","fper","上下","但是","上下文","两个","onresult","cacheresult","直接"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["...","只不过","调用",",","下","当","上面","一个","如下","prevparam","]","curry","需要","不是","，","的","长度","要","只",".","参数传递","[","然后","期望",")","return","必须","是","len","则","代码","像","给","每次","你","fn","函数","let","}","else","但是","参数","不定","接收","数传","传入","都","传递","和","一次","不过"," ","偏","nextcurry","很","将","=","length","nextparam","params","{","手动","if","柯里化","(","考虑",">"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["可读","信息","参数","扰乱","参数信息","可读性"," ","其他","拆分","的","提高","会"],"title":"为什么使用柯里化和偏函数？","title_tokens":["什么","和","为什么","偏","？","使用","函数","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["事实","loosecurry","理解","...",",","args","prevargs","上面","strict","]","」","可以","为","，","内部","的","nextcurried","我们",".","「","[",")","return","事实上","是","len","实现","js","fn","let","}","else","nextargs","都","这样"," ","=","length","{","if","柯里化","(",">"],"title":"更宽松的柯里化","title_tokens":["更","柯里化","的","宽松"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["中","...","当","args","返回","一个","取消","需要","arg","for","，","数量","的","向","没有",")","return","是","注意","ret","你","fn","函数","let","}","of","传入","uncurry","参数"," ","偏","=","仍然","{","应有","柯里化","(",">"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器","text_tokens":["propsobj","方法","按照","叫做","nowobjprops","可以","类似","时候","curryprops","通过","nextobjprops","nextcurried","重要",")","位置","实现","没","前面","else"," ","柯里化","拿到","(","props","开发",",","它","presetpropsobj","可是","轻易","的","使得","我们","顺序",".","不","return","内置","代码","下面","使用","每次","可能","函数","fn","let","参数","偏","length","{","。","只能","object","不能","上面","一个","解构","，","让","那么","tostring","reverse","spreadargs","len","没法","}","传入","1","都","assign","和","=","转换","考虑",">","有","更改","keys","开发者","器","这","装饰","列表","js","再","partialprops","幸好","if"],"title":"高级实现","title_tokens":["实现","高级"]},{"location":"javascript/fp/manage-function-inputs/#point-style","text":"当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["有","not","方法","转发","parseint","...","3","当",",","isshortenough","args","它","并","如果","5","之前","+","unary","一个","]","编程","可以","2","比如","完全","<","addthree","原封不动","，","不动","遇见","通过","的","/","我们",".","把","那个","4","[",")","是","例子","某些","则","他们","实现","给","风格","你","v","fn","函数","原封","!","map","另","let","优化","两个","参数","1","接收","判断","砍掉"," ","将","=","这一","length","islongenough","又","msg","相反","(",">"],"title":"Point Style","title_tokens":["point","style"," "]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["准确","y","赋值","跟踪","清楚","更","参是","如何","关键字","如果","编程","引用","变量","可以","叫做","用","coding","递归","为","时候","尽可能","闭包","这会","通过","匿名","没有","开发人员","片段","当有","包括","只","说","取出",")","x","空","后面","给","外部","你","清晰","这个","前面","else","一次","惰性"," ","确保","一部","一部分","抽象","情况","稳定","定义","(","name","中","开发","输入输出","学习",",","当","返回","它","用途","常规","一段","至少","修改","可读","字符串","角度","面向","pain","映射","的","/","bug","我们",".","把","应用","也","todo","执行","不","交易","什么","表达式","return","代码","使用","最后","可能","函数","fn","let","知道","参数","这些","不赋","式","传递","并且","隐含","偏","数学","{","调试","值得","。","变差","或","自","明显","最好","存储","过于","含有","对象","命名","到","声明","能力","一个","」","意识","easy","curry","关键","解构","，","让","造成","变得","那么","数据流","个","人员","因为","read","when","返回值","「","加上","入","副作用","是","则","表达","更新","输出","的话","堆栈","不同","输入","区别","}","和","function","很","=","达式","多个","写法","临时","包含",">","发人","有","数据","是因为","¶","调用","部分","过程","会","？","需要","未来","上","或者","不是","喜欢","在","原因","尽可","可读性","作用","化","多次","更加","n","字符","名","值","用来","这种","一定","文章","不传","显式","js","只有","但是","地","或是","本质","if","元","到底"],"title":"Nature Function","title_tokens":["nature","function"," "]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["函数","是","什么"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["或者","执行","这些","关键","一次","，","function"," ","关键字","代码","声明","多次","的","使用","片段","可以","一段"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["准确","有","输入输出","含有","元","一个","」","可以","叫做","，","映射","n","的","个","值","我们","把","「","也","输出","包含","函数","不同","但是","输入","和"," ","多个","或"],"title":"数学角度","title_tokens":["角度","数学"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["有","中","输入输出","过程","编程","面向","，","的","没有","一定","不","则","输出","可能","函数","输入","式"," ","稳定"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["「","式","和","面向","的","过程","编程","函数","」","区别"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["中"," ","的","js","能力","函数"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["y","赋值","更","如果","变量","可以","用","时候","开发人员","包括","当有","取出",")","x","空","外部","清晰","else"," ","一部","一部分","(","中","开发","输入输出","当",",","返回","它","至少","可读","修改","的","/","我们","不","return","代码","使用","最后","fn","函数","let","参数","不赋","传递","并且","隐含","{","变差","明显","最好","存储","对象","命名","一个","解构","，","让","造成","数据流","人员","因为","返回值","副作用","则","输出","}","输入","和","=","多个","临时","写法","发人",">","有","数据","部分","需要","喜欢","可读性","作用","更加","这种","不传","显式","只有","if","这会"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["应用","curry","上","和"," ","偏","到","函数"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["自","跟踪","清楚","是因为","参是","调用","如何","命名","过于",",","返回","如果","用途","会","一个","引用","可以","easy","需要","未来","递归","字符串","在","原因","尽可能","时候","尽可","，","为","pain","名","字符","的","read","因为","用来","匿名","bug","when",".","只","交易","加上","todo","不","入","是","空","更新","给","你","的话","可能","函数","fn","堆栈","这个","前面","知道","coding"," ","或是","确保","很","抽象","调试","值得","情况","name"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["文章","后面","到","的","会","。","说"],"title":"惰性表达式","title_tokens":["表达","表达式","达式","惰性"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["循环","更","所有","编程","转变成","可以","时候","可维护性","结果","独立","来","协同","带来","看出",")","m","过度","好处","意味着","而","不由","++","栗子"," ","关心","(","得","中","开发","要求","...","arr",",","平衡","了","不由自主","一下","可读","取得","<","命令式","干","技术","维护性","的","/","更少","才","细节","天然","bug","每","我们",".","也","4","一目了然","[","不","什么","成本","去","代码","下面","转变","函数","map","let","知道","一步","式","应该","增加","了然","潜意识","length","变成","{","。","维护","对","不得","明显","掌握","技术细节","声明","近年","]","」","一个","意识","深入","模式","，","意味","0","让","数据流","i","因为","迫不得已","「","必须","不得已","是","从","熟练","对比","}","人","1",";","都","和","=","读者","近年来",">","数据","3","年来","¶","一目","并","会","更易","2","自主","在","强","for","可读性","化","阅读","总是","熟练掌握","多人","命令","发现","举个","事情","主流"],"title":"Why FP","title_tokens":["fp"," ","why"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["循环","可以","时候","可维护性","来","看出",")","m","不由","++","栗子"," ","(","...","arr",",","了","不由自主","一下","可读","<","干","维护性","的","/","更少","细节","天然","bug","每","我们",".","也","4","一目了然","[","什么","去","代码","下面","map","let","知道","一步","了然","潜意识","length","{","。","维护","不得","明显","]","意识","深入","，","0","i","因为","迫不得已","不得已","对比","}","1",";","=",">","3","一目","会","更易","2","自主","在","强","for","可读性","阅读","发现","举个"],"title":"函数式编程带来的好处","title_tokens":["带来","式","的","编程","函数","好处"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["数据","更","技术细节","声明","」","命令式","技术","结果","让","数据流","的","总是","细节","「","代码","过度","人","而","式","和"," ","命令","关心","读者","。"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["命令式","gt",";","式"," ","命令","=","声明","&","的","转变"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["得","掌握","开发","平衡","所有","并","编程","一个","取得","意味","化","的","才","我们","成本","不","熟练掌握","必须","是","去","代码","熟练","函数","意味着","式","都","和","应该"," ","关心","。","维护","事情"],"title":"代码中的平衡","title_tokens":["代码","平衡","中","的"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":["getting"," ","started"]},{"location":"skills/introduction/","text":"简介 ¶","text_tokens":["简介"," ","¶"],"title":"Getting Started","title_tokens":["getting"," ","started"]},{"location":"skills/introduction/#_1","text":"","text_tokens":[],"title":"简介","title_tokens":["简介"]},{"location":"skills/git/git-cz/","text":"why git cz ¶ 给 git commit 添加一段简短有意义且规范的描述 组成 ¶ 一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中 type ¶ feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变 scope ¶ 说明本次代码影响的范围（文件、文件夹） subject ¶ 简短描述 body ¶ 当代码需要一些说明时 foot ¶ 可以用来跟踪 issue 的 ID ，如 Close #123 方便的库 ¶ npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["跟踪",":","#","提高","可以","git","init","cz","库","通过","来","提交","没有","包括","refactor","style","json",")","footer","给","构建","如","安装","commit","换行","且","config"," ","）","(","其中","docs","范围","意义","目录","中","foot","当","conventional","方便","了","commitizen","一段","修改","新","<","工具","perf","规范","123","的","type","issue","文件","bug",".","也","、","然后","test","标准","代码","下面","close","修复","应该","本次","说明","{","。","line","就","changelog","简短","改变","件夹","一个","文件夹","，","i","save","exact","添加","\"","scope","去掉","blank","package","feat","运行","}","-","几个","id","body",">","有","文档","全局","¶","why","部分","g","并","影响","过程","时","chore","scripts","需要","性能","或者","在","（","path","一些","run","描述","用来","项目","组成","功能","只有","npm","空格","fix","测试","subject"],"title":"git-cz","title_tokens":["git","cz","-"]},{"location":"skills/git/git-cz/#why-git-cz","text":"给 git commit 添加一段简短有意义且规范的描述","text_tokens":["git","commit","有","且","意义"," ","简短","规范","给","的","描述","添加","一段"],"title":"why git cz","title_tokens":["git","cz"," ","why"]},{"location":"skills/git/git-cz/#_1","text":"一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中","text_tokens":["body",":","部分","一个","<","的","type","包括","scope",")","标准","footer","blank","下面","line","commit","几个","应该"," ","subject","(","其中",">"],"title":"组成","title_tokens":["组成"]},{"location":"skills/git/git-cz/#type","text":"feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变","text_tokens":["docs","文档","意义","改变","并","影响","提高","过程","chore","修改","性能","或者","工具","perf","，","的","添加","提交","没有","bug","refactor","style","也","去掉",")","test","代码","功能","feat","只有","构建","修复","换行","空格"," ","测试","fix","新","("],"title":"type","title_tokens":["type"]},{"location":"skills/git/git-cz/#scope","text":"说明本次代码影响的范围（文件、文件夹）","text_tokens":["件夹","范围","、","（","文件夹","）","代码","本次","影响","说明","的","文件"],"title":"scope","title_tokens":["scope"]},{"location":"skills/git/git-cz/#subject","text":"简短描述","text_tokens":["简短","描述"],"title":"subject","title_tokens":["subject"]},{"location":"skills/git/git-cz/#body","text":"当代码需要一些说明时","text_tokens":["需要","一些","当","代码","时","说明"],"title":"body","title_tokens":["body"]},{"location":"skills/git/git-cz/#foot","text":"可以用来跟踪 issue 的 ID ，如 Close #123","text_tokens":["跟踪","，"," ","close","id","123","#","的","issue","用来","如","可以"],"title":"foot","title_tokens":["foot"]},{"location":"skills/git/git-cz/#_2","text":"npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["changelog","中","目录","全局",":","conventional","g","了","commitizen","scripts","可以","git","init","在","path","cz","run","i","通过","来","save","exact","添加",".","\"","json","然后","项目","package","运行","安装","-","}","commit","npm","config"," ","{","。","就"],"title":"方便的库","title_tokens":["方便","库","的"]}]}