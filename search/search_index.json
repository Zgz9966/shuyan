{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术整理。 shuyan 涉及较多领域。我试图整理一个系统的手册，判断自己缺失的技术栈，并且专注核心概念，主要在于理解而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 如何安装 mkdocs 待整理 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["grey","一往无前","body","以下","直接","you","保持","与","将要","如何","包含","javascript","编程","看到","内容","成为","巩固",";","blog","this",":","全面","会","判断","刷题","那些","至少","来到","渴望","基本","欢迎","?","核心","什么","主题","网上","地","完善","较为","不断","并且","坚持","语言","color","green","document","其","click","array","未来","因此","不仅仅","时","默认","列出","queryselectorall","projects","理解","https","的","'","lime","google","blue","素未谋面","to","此外","deploy","调用","以及","brown","css","accent","技术","一门","师","编程语言","一往","更换","分支","在","仅仅","随时","栈",".","善用","深入","算法","white","掌握","永远","button","前端","cyan","(","鉴于","typescript","也","安装","概念","indigo","可","不会","shuyan","。","搜索","经历","语法","领域","实践","purple","palette","can","light","可能","teal","md","mkdocs","deep","面对","去","自己","practice","what","red","阅读","orange","[","辅助","gh","局限","更新","学习","色块","以下内容","更好","chancezyw","primary","正在","当然","好奇","{","比如","浏览","较","=","手册","涉及","关于","旧","s","我","不是","主要","梳理","风景","总是","学识","call","不仅","建议","build","到","想","来","function","：","，","/","经常","基础","提问","不断更新","？","知识","并","整理","material","函数","对","addeventlistener","一个","色","故乡","旅行","）","专注","相关","待","局限于","见闻","io","（","目前","写","部署","提升","-","都","比","和","式","缺失","限于","how","中","部分","无前","下去","]","着力","setitem","帮助","github","试图","mdcolorprimary","多","var","read","做","}","你","回顾","采用","¶","基础知识","坚持下去","提交","失效","通过","参见","pages","localstorage","详细","了","mdcoloraccent","两点","管用","dataset","事项",")","foreach","主色","yellow","在于","智慧","prototype","amber"," ","\"","系统","上述","地方","颜色","谋面","将","api","data","可以","新","首先","要","而","请","一些","其次","将会","点击","pink","是","buttons",",","colors","资料"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"#shuyan","text":"那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术整理。 shuyan 涉及较多领域。我试图整理一个系统的手册，判断自己缺失的技术栈，并且专注核心概念，主要在于理解而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["一往无前","以下","保持","将要","包含","javascript","编程","看到","内容","成为","blog","全面","会","判断","那些","来到","欢迎","核心","完善","较为","不断","并且","未来","因此","不仅仅","时","列出","projects","理解","'","的","素未谋面","此外","调用","以及","css","技术","师","一往","在","仅仅","随时","栈","深入","算法","永远","前端","鉴于","typescript","也","概念","不会","shuyan","。","经历","领域","可能","面对","去","自己","局限","更新","以下内容","chancezyw","正在","当然","较","手册","涉及","关于","旧","s","我","不是","主要","梳理","风景","总是","不仅","想","，","经常","基础","不断更新","知识","并","整理","函数","一个","故乡","）","专注","相关","待","局限于","（","目前","写","都","和","式","缺失","限于","中","部分","无前","着力","试图","多","做","回顾","基础知识","失效","参见","详细","了","两点","事项","在于"," ","系统","上述","地方","谋面","api","新","请","而","将会","是"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 如何安装 mkdocs 待整理","text_tokens":["chancezyw","直接","如何","分支","在","github",".","blog",":","到","采用","提交","/","pages","安装","整理","shuyan","。"," ","其","待","将","io","mkdocs","可以","目前","部署","https","-","deploy","gh"],"title":"How to build？","title_tokens":["how","build","to"," ","？"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["浏览","学识","巩固","刷题","来","，","通过","基本","网上","。"," ","语法","首先","可以","一些","的","其次","自己","学习","资料"],"title":"How to practice？","title_tokens":["how","practice","to"," ","？"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["更好","下去","好奇","比如","一门","技术","保持","与","编程语言","我","帮助","javascript","编程","善用","建议","至少","你","坚持下去","渴望","：","，","掌握","提问","什么","管用","并","地","对","智慧","搜索","坚持","语言"," ","旅行","实践","见闻","可以","要","一些","的","提升","自己","google","比","都","阅读"],"title":"What can you read?","title_tokens":["read","can","you","what"," ","?"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["palette","material","颜色","主题","更换","color"," "]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["grey","primary","body","{","=","]","更换","setitem","call",".","mdcolorprimary","var",";","this","}","white","function","button","localstorage","cyan","(","indigo","dataset","主题",")","foreach","可","主色","addeventlistener","yellow","prototype","amber","document"," ","green","\"","color","click","array","purple","light","默认","teal","queryselectorall","md","data","点击","pink","的","deep","lime","orange","buttons","red","blue","-","[",",","brown","色块"],"title":"Primary colors 主色","title_tokens":[" ","主色","colors","primary"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["accent","body","{","=","]","更换","setitem","call",".","var",";","this","}","function","button","localstorage","cyan","(","mdcoloraccent","indigo","dataset","主题",")","foreach","addeventlistener","yellow","色","prototype","amber","document"," ","green","\"","color","click","array","purple","light","默认","teal","queryselectorall","md","data","点击","pink","的","deep","lime","orange","buttons","red","blue","-","[",",","辅助","色块"],"title":"Accent colors 辅助色","title_tokens":["accent","辅助","色"," ","colors"]},{"location":"algorithm/introduction/","text":"Become stronger ¶ 想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！ 变强的方法 ¶ 参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["加入","小","时候","出来","大堆","大佬","不用","打卡","推荐","心里","我要","我","become","找","简单","三千","排序","变强","想","半天","阿赖","¶","参考","：","，","stronger","中值","感受","方法","题","了","刷","想起","！","千多","一个"," ","顺序","一点","某位","的","问","三千多","才","只有"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"algorithm/introduction/#become-stronger","text":"想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！","text_tokens":["加入","小","时候","出来","大堆","不用","打卡","心里","我要","我","找","简单","排序","变强","想","半天","阿赖","：","，","中值","感受","了","想起","！","一个"," ","一点","的","问","才","只有"],"title":"Become stronger","title_tokens":[" ","become","stronger"]},{"location":"algorithm/introduction/#_1","text":"参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["三千"," ","大佬","顺序","参考","某位","推荐","千多","的","三千多","题","了","刷"],"title":"变强的方法","title_tokens":["的","方法","变强"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["大小写","嵌套","有名","of","肯定","字符","failure","重复","结构","?","中文","and","且","件夹","行间","」","时","文件名","语态","标点","大小","需要","开始","添加","专有名词","简单","遇到","之后","content","|","aligned","​","仅","重复使用","为","必要","wiki","b","目录","bad","the","admonition","=","分隔","left","「","block","引用","换行","!","间","/","c","不必要","文档","foofoo","陈述句","after","）","相关","header","排版","3","中","表达","省略号","wrapped","从","标记","cell","双引号","don","readme","¶","提交","space","适用","专有","right","一级","陈述","team","标点符号","flavored","\"","规范","有","而","后缀","是","插件","强调","be","ide","章节","内容","用","之间","会","正确","text","seo","无需","中文标点","looks","的","google","单位","样式","啰嗦","更","标题","barbar","bullet","公式","、","也","页面","中英","引擎","作为","尽量","success","diff","完整","info","for","缩进","以","不","一个","行内","看做","nice","无","格式","（","baz","…","sure","例子","处理","github","原因","配置","不必","下划线","status","note","名词","indent","至多","nested","空格","与","指南","“",";",":","again","fenced","口语","list","非","特殊","包括","在","+","正文","自动","词","序列表","体验","abstract","js","符号","说法","序列","居中","。","搜索","显示","中英文","省略","git","a","个","example","md","mkdocs","语句","搜索引擎","spaces","直角","建议","主动","段落","utf","，","全角","当","划线","second","提升","和","只","bar","为准","下划","后","反","小写","参见","”","`","其他","注明","两","口语化"," ","将","center","quote","可以","请","console","两个","2","文件","foo","多种","$","以便","t","主题","标识符","your","1","语言","##","tip","danger","'","当前","log","to","编写","it","根据","删除","前后",".","good","markdown","(","空行","代码","文字","使用","英文","其內容","first","编码","*","增加","半角","阅读","pygments","8","文件夹","question","没有","块","酌情","整句","高亮","引号","单词","bug","清理","-","连","表格","部分","列表","代替","有序","indenting","多","参考","采用","warning","很","行末","数字","标识",")","update","加","避免","要求","#","索引","4","合理",",","ctf","numbered"],"title":"Markdown Norm","title_tokens":[" ","norm","markdown"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["规范","采用","markdown","wiki","编写","的","。","team"," ","ctf"],"title":"Markdown 编写规范","title_tokens":[" ","规范","编写","markdown"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["8","文件夹","处理","分隔","指南","下划","字符","文件",".","原因","建议","之间","会","参考","utf","，","小写","下划线","、","一个","使用","seo","件夹","搜索","引擎","。","文档"," ","划线","看做","单词","非","为","文件名","将","md","索引","而","的","编码","-","两个","google","后缀","是","连","搜索引擎"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["中","空格","bad","从","与","标题","在","后","章节","正文","开始","添加","没有","配置","good","采用","间","，","之后","/","空行","当","页面","一个","文档","一级","且","1","作为"," ","##","仅","要求","有","时","#","mkdocs","的","至多","当前","目录","根据"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["样式","表达","空格","中","部分","删除","啰嗦","admonition","question","需要","肯定","在","ide","内容","自动","词","info","主动","会","段落","多种","failure","换行","warning","酌情","提交","不必","，","abstract","行末","、","不必要","空行","说法","主题","适用","不","note","一个","使用","陈述","口语","两","陈述句","口语化"," ","bug","尽量","避免","tip","有","success","必要","时","清理","语态","danger","example","quote","的","插件","只","语句","强调"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["bar","foo","foofoo","baz","1"," ",".","barbar"],"title":"有序列表无需编码","title_tokens":["有","序列表","列表","序列","编码","无需"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["2","空格","8","the","列表","bar","wrapped","嵌套","有序","of","标记","在","indenting","后",".","没有","简单","foo","for","don","again","bullet","缩进","，","text","结构","space","?","numbered","很","标识","t","也","当","and","标识符","使用","。","1","无需","作为"," ","after","list","nice","尽量","a","looks","个","时","可以","4","indent","'","*",",","baz","和","3","it","nested","spaces"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["pygments",".",";","block","块","，","js","参见","fenced","以便","高亮","(","代码","`",")","注明","​","使用","文档","语言"," ","\"","console","log"],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["be","文件",".","引用","反","readme","!","，","引号","代码","`","当","update","your","行内","使用","且"," ","时","md","to","sure"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["为准","cell","left","github",":","markdown","content","以","status","|","aligned","right","。"," ","flavored","git","first","center","second","header","格式","-","diff"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["空格","需要","与","包括","字符","之间","全角","中文","数字","代码","其他","不","行内","中英","加","英文"," ","中英文","）","标点","（","增加","单位"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["省略号","代替","双引号","直角","“","「","用","重复","”","符号","引号","不","使用"," ","」","标点符号","省略","重复使用","规范","标点","的","…"],"title":"标点符号","title_tokens":["标点符号","标点","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["特殊","完整","字符","遇到","整句","，","全角","、","中文","数字","使用","英文","名词"," ","其內容","中文标点","标点","的","半角"],"title":"全角与半角","title_tokens":["与","半角","全角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有名词","专有","大小写","大小","有名","的","使用","小写","正确","名词"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["=","前后","+","体验","$","，","公式","c","文字","居中","行内","使用","。","行间","显示"," ","尽量","无","a","可以","提升","的","合理","b","和","阅读"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["排版","更","例子","参考","请","中文","。","和","指南","相关"," ","内容","多"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["技巧","精通",".","开发","30","blog","days","¶","个人","rx","icss","优质","js","基础","资源","奇淫","书单","在线"," ","梁少峰","敏捷","的","学习"],"title":"Learning Resources","title_tokens":[" ","resources","learning"]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["资源","学习"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":[" ","基础","js","学习"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["30","blog","days","奇淫","的","个人","icss","技巧","rx","js"," ","精通","梁少峰","."],"title":"优质 blog","title_tokens":[" ","优质","blog"]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多 五分钟起步法 ¶ 遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["思考","高强度","克服","而已","睡前","以终","能够","重复","试着","就","即使","小而","穿","结构","强度","放松","什么","大白","并且","白话","g","」","意味着","时候","需要","番茄","高强","快","开始","做事","以往","习惯","加强","之后","信念","以后","看法","目的","神经元","五分","有利于","去","有助于","老","世界","养成","工作","不是","接到","「","belief","压缩包","起步","不想","一遍","知识","难","利于","反馈","形成","运动","方案","制定","多用","问题","中","学","神经网络","细胞","做","¶","推断","了","脑细胞","时间","集中精力","办法","才能","最","产生","掉","讲","而","已有","东西","是","大","反复","为始","法则","闭上眼","惯性","所以","大脑","所有","用","至少","会","核心","关联","整个","因此","普通人","五分钟","的","意味","方向","更","单一","再","速度","代谢","向","也","聪明","完","乏味","睡眠","有利","最大化","自己","明白","类比","学习","大化","比如","技巧","行为","再谈","认为","并","不","间隔","对","衣服","刚","通人","结果","忘记","段时间","僵尸","别人","reward","一段时间","栗子","思维","组块","这个","这","衰弱","事情","普通","新","良好","变","解决方案","神经网","小","内","保持","固化","老旧","如何","天才","回忆","企业","重要","即时","成","海马","今天","然后","智商","记忆","这样","复习","批判","一点","这是","执行","给予","同时","做出","在","精力","给","脑神经","穿衣","十遍","控制","。","他","分钟","知道","特定","物流","穿衣服","让","练习","奖励","，","消灭","库存","cue","死亡","助于","发展","从而","和","精确","然而","只","明天","突触","复杂","成大","任务","新陈代谢","马云","回顾","压缩","其他","分解成","隔离","有限","最终","上"," ","数据","信息","下","将","法","可以","比喻","一些","分析","神经","一段","性价比","不管","有助","生长","信号","抽象","routine","记住","就是说","那么","上眼","最好","但是","聚合","只是","多少","最大","根据","删除","拖延",".","打包","集中","也就是说","掌握","分解","遇见","之前","大白话","我们","生成","体","结合","更好","听","一样","周末","起来","没有","举个","眼中","而是","？","就是","这些","e","模式","每天","先","接受","意识","专注","症","大脑神经","方式","都","某些","如果","解决","不用","网络","怎样","微","多","你","人","长此以往","通过","危险","很","能","在于","难免","要","合理","25","得到"],"title":"Study&Thought","title_tokens":["&","thought","study"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["思考","习惯","？","良好","的","如何","和","养成","学习"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["时候","删除","突触","方向","睡前","大脑","老旧","能够","网络","在","让","记住","「","会","以往","重要","，","脑神经","通过","长此以往","放松","一遍","向","并且","控制"," ","」","信息","记忆","因此","复习","大脑神经","发展","可以","新","的","方式","某些","特定","神经","生成"],"title":"大脑结构","title_tokens":["结构","大脑"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["突触","有助","大脑","生长","细胞","新陈代谢","你","就是说","加强","，","也就是说","代谢","了","能","就是","海马","脑细胞","聪明","利于","。"," ","产生","助于","睡眠","神经元","新","良好","有利","的","有利于","有助于","变","神经","体"],"title":"良好睡眠","title_tokens":["良好","睡眠"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["结果","惯性","做出","信号","在","接到","routine","做事","reward","belief","你","行为","，","之后","信念","cue"," ","这样","之前","的","养成"],"title":"僵尸意识","title_tokens":["意识","僵尸"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["中","执行","一样","需要","比如","穿衣服","如何","在","回忆","起来",".","所有","打包","「","压缩包","你","重要","思维","就","集中","，","压缩","穿衣","穿","组块","成","什么","能","关联","以后","这个","不","e","模式","整个","g","。","衣服"," ","」","信息","知道","下","将","要","一些","的","方式","东西","都","是","学习"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["大化","小","性价比","解决","意味","同时","保持","成大","天才","让","没有","再","练习","你","人","那么","就","，","掌握","速度","核心","了","分解","知识","就是","也","这个","分解成","这","有限","最终","办法","聚合","。","上"," ","智商","接受","才能","专注","只是","方案","因此","知道","普通人","将","普通","要","通人","的","从而","问题","意味着","东西","最大","最大化","我们","大","世界","解决方案","反复","学习"],"title":"怎样形成组块","title_tokens":["怎样","组块","形成"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["精力","给予","症","最好","克服","集中精力","奖励","拖延","集中","，","25","然后","自己","的"," ","办法","分钟","这是"],"title":"番茄工作法","title_tokens":["工作","番茄","法"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["忘记","高强度","段时间","工作","突触","内","大脑","能够","技巧","抽象","番茄","网络","神经网络","起来","在","高强","让","固化","一段时间","重复","重要","即使","加强","，","十遍","掌握","很","强度","脑神经","放松","能","反复","并","也","时间","这些","不","在于","然后"," ","记忆","法","大脑神经","新","一些","的","东西","和","是","神经","生成","一段","神经网","学习","结合"],"title":"间隔重复法则","title_tokens":["法则","间隔","重复"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["闭上眼","重复","难免","人","你","可以","的","试着","上眼","，","回顾","。","乏味","让","单一"],"title":"在重复中回顾","title_tokens":["中","重复","回顾","在"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["习惯","隔离","的","奖励","信号","危险","微"," ","养成"],"title":"克服拖延症","title_tokens":["拖延","克服","症"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["时候","复杂","任务","周末","不是","开始","做","小而","而是","难","今天","不","完","每天","先"," ","最","制定","刚","的","精确","只","明天"],"title":"如何制定任务","title_tokens":["如何","任务","制定"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["不管","不用","学","所以","大脑","在","开始","至少","会","人","就","，","死亡","衰弱","每天","产生","掉","多少","神经元","一点","而","的","都","老","神经","如果"],"title":"合理运动和学习","title_tokens":["合理","和","运动","学习"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["利于","比喻","有利","有利于","大脑","形成","和","组块","类比"],"title":"多用类比和比喻","title_tokens":["多用","比喻","类比","和"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["物流","更","而已","在","快","栗子","马云","企业","举个","眼中","，","消灭","库存","认为","对","。","他","只是","看法","目的","的","是","我们","然而"],"title":"以终为始的思维","title_tokens":["的","以终","思维","为始"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["已有","去","的","分析","数据","推断","根据"],"title":"批判思维","title_tokens":["批判","思维"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["给","听","用","会","讲","你","更","学","的","白话","东西","大白话","别人","，","明白","得到","多","大白"],"title":"即时反馈","title_tokens":["反馈","即时"]},{"location":"introduction/study-thought/#_18","text":"遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["做","更好","会","五分钟","其他","五分","不想","但是","的","事情","遇见","，","先","再谈","分钟","了"],"title":"五分钟起步法","title_tokens":["法","五分钟","起步","五分","分钟"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","concept","addition"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["下文","执行","上下文","¶"," ","上下"],"title":"Execute Context","title_tokens":[" ","context","execute"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["下文","执行","上下","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/composing-functions/","text":"函数组合 ¶ 函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。 function outputs ¶ 在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。 常规函数组合 ¶ 我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念上去理解 compose pipe ¶ pipe 与 compose 相同，只不过 pipe 是从左往右 let pipe = reverseArgs ( compose ) 你可能会困惑，我们给出详细实现。 let pipe = (... fns ) => result => { let list = [... fns ] while ( list . length > 0 ) { // take the first function from the list // and execute it result = list . shift ()( result ); } return result ; }; 在某些需要 reverse 右边参数的场景，使用 pipe 会更有效率 Abstraction ¶ 抽象是一个重要的能力，他让我们的一些代码只需要写一遍。 思考 let saveComment = txt => { if ( txt != \"\" ) comments [ comments . length ] = txt ; } let trackEvent = evt => { if ( evt . name !== undefined ) { events [ evt . name ] = evt ; } } 我们可以很轻松的发现，上面代码的共性就是存储一个值 function storeData ( store , location , value ) { store [ location ] = value ; } function saveComment ( txt ) { if ( txt != \"\" ) { storeData ( comments , comments . length , txt ); } } function trackEvent ( evt ) { if ( evt . name !== undefined ) { storeData ( events , evt . name , evt ); } } 上面体现了抽象的一个原则，那就是不要重复。 但是注意抽象不要过头。 我们可以隐藏一些细节，就像黑盒子那样 但是被隐藏的细节应该是相对的，比如我们有一个相互依赖的功能 x 和 y 当我们专注 x 的时候 y 是无关紧要的 相反，我们专注 y 的时候 x 是无关紧要的。 我们抽象的目的不是隐藏细节，而是调整聚焦 。 请时刻记住，函数式编程的本质目的是写出更多可读性良好，可维护的代码。 为了分离两个概念，我们会插入一个语义级的分界，在大多数情况下，这个边界就是函数的名称。我们调用时，只在意名称和他的输出。 我们把 怎样 和 什么 分离开来 命令式编程风格说明 怎样 而声明式风格注重 什么 也就是输出，声明式关心结果，将如何实现交给别人。 声明式代码实现了从 how 到 what 的一个抽象 我们应该在声明式和命令式之间找到一个平衡。 声明式简单的将 做什么 和 如何做 分开 compose VS abstract ¶ compose 也是 声明式 的抽象 总而言之，compose 是一项非常有用的技能来将我们命令式的代码转换为可读性更好的声明式的代码。 在 FP 中 compose是极其重要的一种方式，它可能是函数间除了副作用传递数据的唯一方法。","text_tokens":["情况","思考","curry","多数","编程","相反","传递数据","重复","就","什么","说明","总而言之","and","并且","同样","左边","时","现成","右边","上去","fns","store","welcomeword","时候","风格","不要","需要","events","let","composedfn","简单","预设","类型","功能","savecomment","第三","左","只不过","night","execute","命令","黑盒子","为","目的","声明","可能","注重","result","去","what","[","可读","the","拿到","welcome","当然","=","从左到右","可读性","实现","不是","转换","func1","轻易","!","间","/","改进","一遍","的话","库","分界","outputs","写","分开","value","evt","有效","rest","极其","...","写出","中","往右","从","返回值","]","受到","除了","做","语义","相互","输出","¶","过头","类似","详细","了","小方块","本质","arguments","因为","最","\"","上面","有","场景","每次","而","在意","积木","是","发现","维护","pull","交给","大多","尽可","username","所以","还有","length","拷贝","之间","会","compose2","是因为","storedata","第三篇","组成","组合","因此","使得","顺序","名称","理解","的","而言","约定俗成","funcn","更","fn1","隐藏","toupper","fp","lego","msg","依次","向","拼","也","概念","原","不会","作为","别的","技能","局限","关心","比如","undefined","喜欢","接收","技巧","for","来","function","调整","体现","多个","之所以","partialright","好处","无关紧要","不过","一项","函数","不","对","一个","放在","输入","平衡","约定","这里","x","相同","comments","结果","减小","fn","how","shift","例子","name","别人","copy","从右","user","这个","pop","这","分离","样子","吧","从左往右","循环","容易","txt","良好","长度",">","原则","关紧","程序","与","如何",";","只能","重要","黑盒","三篇","修改","惰性","运用","直到","细节","然后","off","list","这样","封装","进行","这是","调用","执行","res","return","+","在","应该","给","location","递归","abstract","可","把","像","。","能力","他","命令式","返回","极其重要","它","{","abstraction","管道","相对","相互依赖","考虑","这种","让","值","，","while","盒子","当","参数","库中","0","系列","做作","安全","和","式","不再","只","vs","长条","级","轻松","}","数组","甚至","from","文章","最终","数据"," ","常规","注意","规定","下","将","fper","当中","可以","origvalue","一些","请","两个","还","取出","2","finalvalue","那样","take","共性","抽象","记住","y","边界","touppercase","发生","小方","那么","通用","方法","<","reverseargs","有用","if","一份","但是","1","效率","只是","'","有效率","紧要","it","聚焦","存储",".","good","插入","运行","副作用","(","依赖","代码","迭代","使用","compose","无关","大多数","计算","pipe","之前","提到","first","性能","*","我们","外层","作用","last","更好","最后","那","一样","到","而是","welcomeuser","two","就是","一种","唯一","非常","专注","reduce","方式","-","困惑","某些","为了","如果","func2","不用","传递","怎样","多","fn2","方块","你","通过","很","一次","能","reverse","args",")","找到","给出","被","在于","尽可能","trackevent","具备","开来","4","要",",","时刻"],"title":"Composing Function","title_tokens":[" ","composing","function"]},{"location":"javascript/fp/composing-functions/#_1","text":"函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。","text_tokens":["中","一样","长条","从","程序","需要","管道","方块","你","小方","就","，","lego","组成","拼","函数","小方块","组合","像","样子","。","库中","数据"," ","现成","可以","的","去","积木","和","取出"],"title":"函数组合","title_tokens":["函数","组合"]},{"location":"javascript/fp/composing-functions/#function-outputs","text":"在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。","text_tokens":["2","情况","大多","username","多数",";","compose2","touppercase","发生","通用","直到","组合","1","只是","左边","顺序","的","'","这是","约定俗成","welcomeword","执行","需要","fn1","+","在",".","let","toupper","good","fp","运行","类型","lego","msg","左","(","向","也","night","把","。","作为","大多数","*","我们","外层","最后","拿到","welcome","=","考虑","这种","，","/","welcomeuser","改进","库","函数","一个","放在","输入","做作","约定","安全","中","例子","传递","fn2","输出","从右","很","user",")","最终","吧"," ","最","注意","上面","容易","规定","下","可以","4","origvalue",">",",","是"],"title":"function outputs","title_tokens":[" ","outputs","function"]},{"location":"javascript/fp/composing-functions/#_2","text":"我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念上去理解 compose","text_tokens":["finalvalue","尽可","curry","所以","还有","length",";","拷贝","会","只能","compose2","那么","是因为","三篇","修改","方法","惰性","<","第三篇","运用","if","并且","组合","一份","但是","然后","off","list","这样","因此","封装","使得","同样","进行","时","理解","的","上去","fns","调用","funcn","res","更","return","fn1","在",".","let","composedfn","给","预设","递归","第三","依次","(","也","概念","原","迭代","使用","像","不会","。","compose","他","作为","计算","之前","提到","返回","性能","可能","result","去","别的","我们","[","局限","可读","last","the","当然","{","=","喜欢","接收","技巧","从左到右","可读性","实现","func1","for","轻易","来","，","/","而是","多个","之所以","while","partialright","好处","two","的话","函数","不","对","参数","一个","0","系列","reduce","输入","这里","方式","-","和","rest","不再","...","如果","func2","减小","fn","中","不用","返回值","从","]","传递","受到","多","copy","fn2","}","数组","甚至","通过","很","类似","一次","文章","了","能","reverse","args",")","pop","这","arguments","在于"," ","因为","尽可能","循环","具备","将","下","fper","可以","要","origvalue","每次","而","当中","长度","两个",">",",","是","pull","还"],"title":"常规函数组合","title_tokens":["函数","常规","组合"]},{"location":"javascript/fp/composing-functions/#pipe","text":"pipe 与 compose 相同，只不过 pipe 是从左往右 let pipe = reverseArgs ( compose ) 你可能会困惑，我们给出详细实现。 let pipe = (... fns ) => result => { let list = [... fns ] while ( list . length > 0 ) { // take the first function from the list // and execute it result = list . shift ()( result ); } return result ; }; 在某些需要 reverse 右边参数的场景，使用 pipe 会更有效率","text_tokens":["the","shift","我们","往右","{","=","take","]","与","return","需要","更","实现","在",".","let","length",";","}","会","你","function","from","，","/","只不过","详细","(","while","reverse","reverseargs","不过","execute",")","给出","it","参数","and","使用","。","compose"," ","0","list","效率","从左往右","pipe","[","first","可能","场景","result","右边","的",">","有效","是","困惑","fns","...","相同","某些","有效率"],"title":"pipe","title_tokens":["pipe"]},{"location":"javascript/fp/composing-functions/#abstraction","text":"抽象是一个重要的能力，他让我们的一些代码只需要写一遍。 思考 let saveComment = txt => { if ( txt != \"\" ) comments [ comments . length ] = txt ; } let trackEvent = evt => { if ( evt . name !== undefined ) { events [ evt . name ] = evt ; } } 我们可以很轻松的发现，上面代码的共性就是存储一个值 function storeData ( store , location , value ) { store [ location ] = value ; } function saveComment ( txt ) { if ( txt != \"\" ) { storeData ( comments , comments . length , txt ); } } function trackEvent ( evt ) { if ( evt . name !== undefined ) { storeData ( events , evt . name , evt ); } } 上面体现了抽象的一个原则，那就是不要重复。 但是注意抽象不要过头。 我们可以隐藏一些细节，就像黑盒子那样 但是被隐藏的细节应该是相对的，比如我们有一个相互依赖的功能 x 和 y 当我们专注 x 的时候 y 是无关紧要的 相反，我们专注 y 的时候 x 是无关紧要的。 我们抽象的目的不是隐藏细节，而是调整聚焦 。 请时刻记住，函数式编程的本质目的是写出更多可读性良好，可维护的代码。 为了分离两个概念，我们会插入一个语义级的分界，在大多数情况下，这个边界就是函数的名称。我们调用时，只在意名称和他的输出。 我们把 怎样 和 什么 分离开来 命令式编程风格说明 怎样 而声明式风格注重 什么 也就是输出，声明式关心结果，将如何实现交给别人。 声明式代码实现了从 how 到 what 的一个抽象 我们应该在声明式和命令式之间找到一个平衡。 声明式简单的将 做什么 和 如何做 分开","text_tokens":["思考","关紧","大多","情况","那样","共性","抽象","如何","编程","多数","length",";","y","相反","记住","边界","会","之间","重复","重要","黑盒","就","storedata","什么","说明","if","细节","但是","时","名称","的","store","紧要","调用","时候","聚焦","风格","存储","不要","需要","更","events","隐藏","在","应该",".","let","location","插入","简单","功能","savecomment","而","(","依赖","代码","也","概念","可","把","像","。","能力","命令","他","无关","大多数","黑盒子","命令式","目的","声明","注重","what","我们","[","可读","关心","那","{","比如","=","undefined","可读性","相对","相互依赖","不是","实现","让","值","到","!","function","，","调整","体现","而是","一遍","无关紧要","盒子","就是","当","分界","函数","一个","专注","平衡","写","分开","value","evt","和","式","x","只","为了","comments","结果","写出","how","级","从","name","]","别人","轻松","怎样","多","做","语义","相互","}","输出","过头","很","了","这个",")","找到","被","本质","分离"," ","\"","上面","注意","有","trackevent","下","将","开来","可以","txt","良好","一些","请","在意","两个",">",",","发现","是","原则","时刻","维护","交给"],"title":"Abstraction","title_tokens":["abstraction"]},{"location":"javascript/fp/composing-functions/#compose-vs-abstract","text":"compose 也是 声明式 的抽象 总而言之，compose 是一项非常有用的技能来将我们命令式的代码转换为可读性更好的声明式的代码。 在 FP 中 compose是极其重要的一种方式，它可能是函数间除了副作用传递数据的唯一方法。","text_tokens":["中","更好","它","传递","抽象","可读性","在","作用","除了","fp","转换","传递数据","重要","来","副作用","间","，","技能","方法","代码","也","一项","函数","总而言之","有用","一种","唯一","非常","。","命令","compose"," ","命令式","数据","为","声明","将","可能","的","方式","极其","极其重要","是","我们","式","而言","可读"],"title":"compose VS abstract","title_tokens":[" ","abstract","vs","compose"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器 Point Style ¶ 当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["情况","parseint","curry","柯里化","of","编程","相反","this","就","什么","拆分","」","一元函数","右边","如","v1","时候","更改","风格","需要","无法","propsobj","let","功能","只不过","|","15","兼容","幸好","spreadargs","装饰","presetpropsobj","为","声明","id","可能","b","但","[","bind","split","可读","the","当然","拿到","=","params","可读性","实现","不是","转换","「","轻易","!","/","另","uncurry","strict","props","argsarr","keys","不太","写","过滤","formatfn","3","...","中","内部","point","]","做","time","期望","¶","类似","很多","则","反转","转发","words","因为","\"","最","上面","有","数量","api","then","场景","每次","是","nextobjprops","只有","ajax","还有","length","必须","用","会","花哨","onresult","prevparam","all","constant","upper","事实","因此","使得","顺序","理解","的","islongenough","nextargs","不动","更","单一","器","叫做","再","object","msg","laterargs","向","那个","也","current","success","传递函数","person","这一","别的","比如","喜欢","接收","技巧","下文","for","来","function","partialright","nextparam","又","并","is","不过","函数","不","传入","style","一个","手动","绑定","filter","人们","位置","x","output","fn","例子","unary","原封不动","开发者","栗子","loosecurry","仍然","user","这个","这","可是","txt","脑子","长度","partialprops",">","nextcurry","操作","直接","如何","identity","呢",";",":","只能","判断","重要","宽松","多余","他们","按照","然后","扰乱","这样","v","优化","看起来","调用","来看","同时","return","事实上","addthree","shit","+","在","给","prevargs","js","可","combinefirsttwo","把","像","。","ret","上下","cache","返回","它","nan","some","{","考虑","如下","让","v2","值","，","later","当","presetargs","参数","map","promise","数传","tostring","下面","和","只","bar","error","帮助","开发","取消","}","甚至","其他"," ","信息","注意","下","将","fper","可以","基于","console","obj","两个","内置","过瘾","一起","高级","还","now","2","partial","参数传递","y","foo","应有","touppercase","那么","原封","方法","<","reverseargs","\\","if","但是","聚合","1","isshortenough","解构","'","提高","log","编写","看起","5","nowobjprops","else",".","curryprops","len","不能","(","没法","代码","promise1","使用","遇见","口中","之前","http","我们","前面","_","s","nextcurried","起来","没有","不定","完全","gatherargs","穿透","举个","偏","？","看","world","hello","reduce","上下文","p2","方式","都","某些","cacheresult","如果","列表","assign","传递","你","12","反向","通过","很","一次","arg","能","args","reverse",")","没","参数信息","避免","砍掉","not","为什么","应用","要","4",",","一元","9"],"title":"Manage Function Inputs","title_tokens":[" ","inputs","manage","function"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["2","parseint","还有","identity",";","用","foo","touppercase","花哨","就","方法","多余","all","constant","\\","只有","upper","但是","1","一元函数","这样","一元","v","的","'","如","log","看起来","来看","更","看起","shit",".","let","单一","给","再","js","msg","不能","(","|","promise1","像","口中","success","传递函数","b","别的","但","我们","[","split","the","nan","{","比如","=","s","起来","转换","值","穿透","for","举个","来","，","/","？","is","看","函数","不","world","参数","map","promise","一个","hello","p2","写","filter","人们","方式","过滤","下面","formatfn","某些","3","...","output","fn","中","bar","unary","]","传递","error","帮助","开发者","做","开发","time","}","甚至","栗子","你","arg","能","这个",")","words"," ","\"","避免","可以","then","txt","脑子","console",",",">","过瘾","还","now"],"title":"一元函数","title_tokens":["函数","一元","一元函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["时候","情况","fn","更改","2","bar","操作","=","无法","]","5","error","如何","+","在","呢","考虑",".","let","y","v2","foo","会","gatherargs","你","12","，","/","反向","(","？","他们",")","函数","不","15","combinefirsttwo","兼容","使用","spreadargs","argsarr","1"," ","3","有","reduce","声明","下","4","的","console","两个",",",">","log","某些","x","[","...","v1","9","一起"],"title":"参数的解构和聚合","title_tokens":["解构","参数","的","聚合","和"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["ajax","partial","直接",";","this","用",":","onresult","reverseargs","但是","因此","右边","的","编写","时候","同时","需要","return","更",".","let","功能","js","laterargs","(","也","可","current","上下","cache","id","person","http","[","bind","some","当然","_","{","=","喜欢","技巧","实现","下文","function","，","/","偏","partialright","并","later","函数","不","presetargs","参数","一个","不太","绑定","上下文","和","某些","cacheresult","只","...","fn","中","]","}","你","很多","user","反转","reverse","args",")","这"," ","因为","\"","最","上面","应用","下","api","fper","可以","场景","基于","obj","两个",",",">"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["fn","nextcurry","curry","柯里化","{","需要","参数传递","=","return","]","接收","params","传递","考虑","如下","else",".","let","不是","length","必须","给","不定","期望","}","你","，","很","偏","len","只不过","一次","(","nextparam","prevparam","则","代码","不过","当",")","函数","传入","if","参数","数传","一个","但是","像","然后"," ","上面","[","手动","将","下","要","每次","的","长度","都",",","和",">","是","只","...","调用"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["参数信息","会","其他","参数","拆分","提高","的","可读性","扰乱"," ","信息","可读"],"title":"为什么使用柯里化和偏函数？","title_tokens":["为什么","函数","柯里化","使用","和","偏","？","什么"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["fn","内部","柯里化","{","return","=","事实上","]","实现","nextcurried","else",".","let","length","「","}","prevargs","loosecurry","，","js","len","(","strict","args",")","if","事实"," ","」","上面","这样","为","nextargs","可以","理解","的","都",",",">","是","我们","[","..."],"title":"更宽松的柯里化","title_tokens":["的","柯里化","更","宽松"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["fn","中","柯里化","{","需要","return","=","of","let","没有","取消","}","for","你","应有","仍然","，","偏","(","uncurry","arg","向","args","当",")","传入","函数","参数","一个","ret"," ","注意","数量","返回","的",">","是","..."],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器","text_tokens":["柯里化","length","只能","重要","那么","方法","按照","if","1","使得","顺序","解构","的","时候","更改","return","nowobjprops","propsobj","else",".","let","器","叫做","再","object","js","curryprops","len","不能","(","没法","代码","幸好","使用","spreadargs","。","装饰","presetpropsobj","可能","我们","它","前面","拿到","{","=","nextcurried","实现","考虑","让","转换","轻易","，","偏","函数","不","传入","参数","props","一个","tostring","keys","位置","都","下面","和","fn","列表","assign","开发者","开发","}","通过","类似","reverse",")","这","没"," ","上面","可是","有","可以","每次","partialprops",",",">","内置","nextobjprops"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/manage-function-inputs/#point-style","text":"当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["2","它","parseint","fn","风格","优化","例子","比如","=","unary","]","接收","addthree","5","+","实现","原封不动",".","let","编程","相反","length","给","完全","判断","你","!","原封","，","/","通过","msg","方法","<","另","(","他们","则","转发","那个","并","又","args","当",")","函数","参数","map","把","一个","遇见","1","isshortenough"," ","砍掉","3","not","之前","有","将","v","...","可以","4","的","这一","两个",">",",","islongenough","某些","我们","[","是","如果","不动"],"title":"Point Style","title_tokens":[" ","point","style"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["情况","尽可","交易","curry","明显","如何","当有","包含","抽象","编程","字符","闭包","一定","y","映射","用","至少","会","那么","是因为","关键字","pain","修改","不传","片段","最好","输入输出","惰性","定义","什么","外部","地","只有","if","不同","并且","但是","数据流","赋值","n","」","跟踪","显式","未来","名","解构","值得","的","隐含","调用","对象","时候","执行","面向","写法","存储","需要","到底","return","更","加上","调试","包括","在","这会","else",".","let","人员","叫做","给","when","用途","副作用","或","递归","字符串","js","(","造成","代码","也","达式","把","使用","入","coding","后面","能力","。","用来","个","不赋","知道","为","声明","可能","关键","返回","确保","清晰","过程","我们","变量","作用","学习","可读","更新","它","最后","前面","{","角度","=","喜欢","可读性","变差","匿名","不是","这种","让","没有","easy","「","发人","引用","值","到","todo","function","空","，","/","偏","多个","？","过于","的话","当","这些","函数","含有","不","或者","参数","一个","意识","bug","或是","输入","表达式","和","式","x","只","如果","说","准确","中","fn","表达","变得","部分","返回值","name","传递","原因","read","开发","命名","一部","}","输出","你","¶","通过","很","一次","临时","参是","文章","则","多次","更加","堆栈","这个","区别",")","本质","清楚","数学","上"," ","数据","常规","因为","尽可能","稳定","一部分","有","应用","自","可以","元","开发人员",",",">","是","化","一段","取出"],"title":"Nature Function","title_tokens":[" ","nature","function"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["函数","是","什么"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["代码","执行","这些","声明","关键","可以","或者","function","的","使用","关键字","，","片段"," ","一次","一段","多次"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["准确","包含","叫做","映射","「","值","输出","或","，","多个","输入输出","也","函数","含有","不同","把","一个","但是"," ","」","n","个","有","输入","可以","元","的","和","我们"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["中","面向","编程","一定","没有","输出","，","输入输出","则","函数","不"," ","稳定","有","输入","可能","的","过程","式"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["「","区别","函数","面向","的","过程","和","式","」","编程"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["中","函数","的","js","能力"," "]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["明显","当有","y","用","至少","修改","不传","最好","输入输出","外部","if","并且","数据流","赋值","显式","解构","的","隐含","对象","时候","写法","存储","需要","return","更","包括","这会","else","let","人员","取出","副作用","(","造成","代码","使用","不赋","返回","清晰","变量","我们","作用","可读","它","最后","{","=","喜欢","可读性","变差","这种","让","发人","空","，","/","多个","当","函数","不","参数","一个","输入","和","x","如果","中","fn","部分","返回值","传递","开发","命名","一部","}","输出","临时","则","更加",")","数据"," ","因为","一部分","有","可以","开发人员",",",">","只有"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["上","应用","到","函数","curry","和","偏"," "],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["时候","情况","尽可","fn","交易","前面","需要","name","加上","调试","匿名","在","如何","抽象",".","字符","原因","read","给","easy","命名","引用","会","用途","when","你","todo","递归","是因为","空","字符串","，","pain","很","参是","过于","堆栈","的话","这个","函数","不","一个","入","清楚","coding"," ","跟踪","尽可能","因为","bug","用来","或是","未来","为","知道","返回","可能","自","确保","可以","名","值得","的",",","是","只","如果","调用","更新"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["会","到","的","后面","。","文章","说"],"title":"惰性表达式","title_tokens":["达式","表达式","表达","惰性"]},{"location":"javascript/fp/side-effect/","text":"一个没有副作用的代码是不存在的。但是可以尽可能的限制。 举个栗子 let y ; let foo = x => { y = x * 2 ; } foo ( 3 ); // 改进 let foo = x => x * 2 ; let y = foo ( 3 ); 很明显，前者是 因果 不相关的，我们需要读 foo 的内部代码，才能知道 y 被修改了。因此可读性很差，这就是副作用。 函数引用了一个自身之外的「自由变量」时，副作用就产生了。 需要注意的是，并不是所有的「自由变量」都是负面的，但是应当要关注这些自由变量。 Side Effects ¶ 副作用意味着代码的读者需要「人肉编译」才能跟踪某个变量的变化。 副作用的产生可能是因为一个返回值中的引用，例如引用的 state 发生了 Mutation「突变」。 因此，所有影响到函数输出的因素都应该作为函数的输入。 固定状态 ¶ 一个约定俗称的规矩是从不覆盖函数的实现，因此函数作为自由变量引用，可以当做引用了一个常量。 考虑两点，当有一个函数时 给定输入，输出是不变的吗？ 引入的自由变量每次都是不变的吗？程序中有其他地方可能会修改这个自由变量吗？ 偶然性 ¶ 随机函数也会产生副作用。 大部分语言中的随机都是采用伪随机算法，有些语言提供了起始值，因此给定相同的起始值生成的随机序列都是一致的。 但是 js 没有提供这项功能，因此 js 中偶然性也是副作用的一种 IO Effects ¶ 最常见的副作用就是 IO 输入输出 比如 DOM，当修改 DOM 之后，事实上就已经产生了副作用 再比如两个依赖自由变量的 ajax，当异步请求的时候，如果回调执行的 顺序 不一致，可能会产生 bug，但是我们难以捕捉他们。 因为很多时候，这些 bug 只会带来 ui 渲染上的不一致，或者只是简单的状态改变。 制裁副作用 ¶ 如果不得不通过副作用修改状态，制裁方式之一是 幂等性 幂等性 ¶ 首先给出一个在「数学」上和「编程」上都不属于幂等的例子 let updateCounter = obj => { if ( obj . count < 10 ) { obj . count ++ ; return true ; } return false ; }; 数学上的幂等性 ¶ 从数学角度来看，幂等性意味着在第一次调用后输出不会改变的操作。 更清晰的例子。 f(x) = f(f(x)) = f(f(f(x))) 在 js 内置的 Math 库中，下面这些例子显然是幂等性的。 Math.min(..) Math.max(..) Math.round(..) Math.floor(..) Math.ceil(..) 我们也可以自己定义一些幂等性的运算 let toPower0 = x => Math . pow ( x , 0 ); let snapUp3 = x => x - ( x % 3 ) + ( x % 3 > 0 && 3 ); toPower0 ( 3 ) == toPower0 ( toPower0 ( 3 )); // true snapUp3 ( 3.14 ) == snapUp3 ( snapUp3 ( 3.14 )); // true 数学角度的幂等性并不仅仅局限于数学运算，js 中基本类型强制转换也是幂等的 let x = 42 , y = 'hello' ; String ( x ) === String ( String ( x )); // true Boolean ( y ) === Boolean ( Boolean ( y )); // true 或是 let upper = v => v . toUpperCase (); let lower = v => v . toLowerCase (); let str = 'Hello World' ; upper ( str ) == upper ( upper ( str )); // true lower ( str ) == lower ( lower ( str ) ); // true 总而言之，幂等性就是满足下列公式的数学表达式 f(x) = f(f(x)) 程序中的幂等性 ¶ 程序中的幂等性没有那么正式，换句话说，当第一次调用 f(x) 与第二次调用的返回值没有区别，从程序的角度，我们认为是幂等的。 就像在 Http 的 RESTapi 中，PUT 被定义为更新服务器资源，当发送多个带有相同参数的 PUT 时，服务器资源都具备相同的结果状态。 // idempotent:幂等 obj . count = 2 ; a [ a . length - 1 ] = 42 ; person . name = upper ( person . name ); // non-idempotent:非幂等 obj . count ++ ; a [ a . length ] = 42 ; person . lastUpdated = Date . now (); 因此，幂等性的定义是，在第一次调用之后，后续怎样的重复调用，程序状态都不会再改变。非幂等性在每次调用都会更改程序状态。 那么在 DOM 更新中如何表现呢？ let hist = document . getElementById ( 'orderHistory' ); // idempotent: hist . innerHTML = order . historyText ; // non-idempotent: let update = document . createTextNode ( order . latestUpdate ); hist . appendChild ( update ); // 隐式的，当前状态是下一状态的一部分 我们并不能总是幂等的定义我们的操作，但这有利于减少副作用的影响。 Pure Bliss ¶ 一个没有副作用的函数称之为 Pure Function ，也就是「纯」函数 纯函数在编程角度来说是幂等的，因为没有任何副作用。 let add = ( a , b ) => a + b 可以发现所有的输入输出都是直接的，没有引用任何自由变量，多次调用 add 函数与只调用一次没有任何区别。所以 add 是一个幂等纯函数。 但是在数学意义中，不是所有纯函数都是幂等的，因为的返回值可能不能作为他们的输入。 let calculateAverage = nums => { let sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } calculateAverage ([ 1 , 2 , 4 , 7 , 11 , 16 , 22 ]); // 9 在这个例子中，返回值并非一个数组，因此不可能「recall」 calculateAverage(calculateAverage(nums)) 纯函数也可以引用自由变量和其他函数，前提是自由变量没有副作用。 const PI = 3.141592 ; let circleArea = radius => PI * radius * radius ; let cylinderVolume = ( radius , height ) => height * circleArea ( radius ); 另一个纯函数引用自由变量的例子就是 闭包 虽然 circleArea 是一个函数对象，我们可以给他添加一个可能「突变」的属性，但是不影响 circleArea 调用。因此只要不重新分配函数，就没有副作用。 验证纯函数的另一种方式是，相同的输入永远产生相同的输出。 如果一个函数给相同的输入产生不同的输出，那么就不是一个纯函数。 在 js 中，写带副作用的代码实在是太容易了。 Purely Relative ¶ let rememberNumbers = nums => fn => fn ( nums ); let list = [ 1 , 2 , 3 , 4 , 5 ]; let simpleList = rememberNumbers ( list ); simpleList 像一个纯函数，但实际上并不是， let median = nums => ( nums [ 0 ] + nums [ nums . length - 1 ]) / 2 ; simpleList ( median ); // 3 list . push ( 6 ); simpleList ( median ); // 3.5 显而易见，当我们修改输入引用的自由变量，返回值就发生了变化。 可以通过复制数组使得 simpleList 变成纯函数。 let rememberNumbers = nums => { // make a copy of the array nums = [... nums ]; return fn => fn ( nums ); } 但是这可能会导致一个更隐蔽的副作用潜伏。 let list = [ 1 , 2 , 3 , 4 , 5 ]; // make `list[0]` be a getter with a side effect Object . defineProperty ( list , 0 , { get : () => { console . log ( \"[0] was accessed!\" ); return 1 ; } } ); let simpleList = rememberNumbers ( list ); // [0] was accessed! 这个副作用看起来无法避免，但是我们可以将它从函数内部转移到调用函数的地方。 let rememberNumbers = (... nums ) => fn => fn ( nums ) let simpleList = rememberNumbers (... list ); // [0] was accessed! 这样做的好处是，rememberNumbers 是纯函数，造成副作用的原因在于 ... 纯函数 + 不纯函数 = 不纯函数 ¶ // yes, a silly contrived example :) let firstValue = nums => nums [ 0 ]; let lastValue = nums => firstValue ( nums . reverse ()); simpleList ( lastValue ); // 5 console . log ( list ); // [1,2,3,4,5] -- OK! simpleList ( lastValue ); // 1 reverse() 方法其实修改了原本的数组，只不过修改的是内部引用的数组。 怎样改进呢？ let rememberNumbers = (... nums ) => fn => fn ([... nums ]); 可以通过传递一个数组拷贝来避免接受该数组的函数在调用时改变原数组。 但是仍然无法保证传递一个不纯的函数。因此，我们只能尽量的让函数 pure，为了可读性。 Referential transparency ¶ 判断一个函数是否纯净的第三种方式，是 Referential transparency 「引用透明性」。如果将值替换函数调用的那一行，行为上没有任何变化，那么该函数就是纯函数。 也就是说，在一个程序当中，我们用一个 val 代替了一个函数调用，在执行上我们看不出任何区别。 如果一个函数存在副作用，但是在程序的任何地方都没有被观察到或者被依赖，那么他还具备「引用透明性」吗？ let sum ; let calculateAverage = nums => { sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } let numbers = [ 1 , 2 , 4 , 7 , 11 , 16 , 22 ]; let avg = calculateAverage ( numbers ); 不得不说它和纯函数几乎没有区别，但是如何看待他取决于你自己 Performance Effects ¶ 观察这个函数 let cache = []; let specialNumber = n => { // if we've already calculated this special number, // skip the work and just return it from the cache if ( cache [ n ] !== undefined ) { return cache [ n ]; } var x = 1 , y = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { x += i % 2 ; y += i % 3 ; } cache [ n ] = ( x * y ) / ( n + 1 ); return cache [ n ]; } specialNumber ( 6 ); // 4 specialNumber ( 42 ); // 22 specialNumber ( 1 E6 ); // 500001 specialNumber ( 987654321 ); // 493827162 我们通过一个缓存来优化多次调用这个函数的性能，但是这看起来很蠢，你可能认为他是纯函数，但是我不这么认为。 let specialNumber = ( function memoization (){ let cache = []; return function specialNumber ( n ){ // if we've already calculated this special number, // skip the work and just return it from the cache if ( cache [ n ] !== undefined ) { return cache [ n ]; } let x = 1 , y = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { x += i % 2 ; y += i % 3 ; } cache [ n ] = ( x * y ) / ( n + 1 ); return cache [ n ]; }; })(); 我们通过 IIFE 来 确保 函数的其他部分不能访问到 cache，而不仅仅是 不允许 在这里至关重要的一点，就是我们能确保，而不仅仅是心灵约定。 Mentally Transparent ¶ 虽然有时将常数和函数调用替换对函数的执行没有影响，但是我们不应该这么做。 不仅仅是因为数据可能是变化的，还为了更好地可读性。 读者会不断地心算一个永远不会变的结果，但是纯函数能够减少这样的花销。 函数提纯 ¶ 可以将副作用从函数内部转移到调用函数的地方，这看起来更明显。 举个栗子 let addMaxNum = arr => { let maxNum = Math . max (... arr ); arr . push ( maxNum + 1 ); } let nums = [ 4 , 2 , 7 , 3 ]; addMaxNum ( nums ); // [4,2,7,3,8] //改进 let addMaxNum = arr => Math . max (... arr ) + 1 ; let nums = [ 4 , 2 , 7 , 3 ]; nums . push ( addMaxNum ( nums )); // [4,2,7,3,8] 我们可以将 addMaxNum 折叠起来了，我们不需要再去观察 addMaxNum 的内部实现。 另外一种方式是采用 immutable 数据结构来实现，我会在下一篇文章说明 我们还可以从这几个角度来分析。 自由变量 ¶ 如果一个函数是不纯的，并且引用了外部的自由变量，我们可以使用作用域来封装。 let users = {}; let fetchUserData = userId => { ajax ( `http://some.api/user/ ${ userId } ` , function onUserData ( user ){ users [ userId ] = user ; }); } // 改进 function safer_fetchUserData ( userId , users ) { // simple, naive ES6+ shallow object copy, could also // be done w/ various libs or frameworks users = Object . assign ( {}, users ); fetchUserData ( userId ); // return the copied state return users ; // *********************** // original untouched impure function: function fetchUserData ( userId ) { ajax ( `http://some.api/user/ ${ userId } ` , function onUserData ( user ){ users [ userId ] = user ; } ); } } 函数的纯度与否其实是由外部决定的，内部也可以适当的采用一些不纯的技术，比如为了性能使用 cache 缓存结果。 但是我们的目标是尽可能的减少副作用。 掩盖 ¶ 有些时候，不纯的函数来自于第三方库，你无法直接将自由变量封装在函数的作用域内 let nums = []; let smallCount = 0 ; let largeCount = 0 ; function generateMoreRandoms ( count ) { for ( let i = 0 ; i < count ; i ++ ) { let num = Math . random (); if ( num >= 0.5 ) { largeCount ++ ; } else { smallCount ++ ; } nums . push ( num ); } } 我们可以通过 brute-force 算法执行以下步骤来改进： 保存未被影响的当前状态 设置初始输入状态 运行不纯的函数 捕获副作用 恢复原状态 返回副作用状态 function safer_generateMoreRandoms ( count , initial ) { // (1) Save original state let orig = { nums , smallCount , largeCount }; // (2) Set up initial pre-side effects state nums = [... initial . nums ]; smallCount = initial . smallCount ; largeCount = initial . largeCount ; // (3) Beware impurity! generateMoreRandoms ( count ); // (4) Capture side effect state let sides = { nums , smallCount , largeCount }; // (5) Restore original state nums = orig . nums ; smallCount = orig . smallCount ; largeCount = orig . largeCount ; // (6) Expose side effect state directly as output return sides ; } 需要注意的是 掩盖 手段只有在处理同步代码时才有效。 规避 ¶ 当我们要处理的副作用是一个 突变 的输入导致的，「数组」或是「对象」我们可以这样做 function handleInactiveUsers ( userList , dateCutoff ) { for ( let i = 0 ; i < userList . length ; i ++ ) { if ( userList [ i ]. lastLogin == null ) { // remove the user from the list userList . splice ( i , 1 ); i -- ; } else if ( userList [ i ]. lastLogin < dateCutoff ) { userList [ i ]. inactive = true ; } } } 先做一个深拷贝 function safer_handleInactiveUsers ( userList , dateCutoff ) { // make a copy of both the list and its user objects let copiedUserList = userList . map ( function mapper ( user ){ // copy a `user` object return Object . assign ( {}, user ); }); // call the original function with the copy handleInactiveUsers ( copiedUserList , dateCutoff ); // expose the mutated list as a direct output return copiedUserList ; } this Revisited ¶ 有的时候 this 作为一个隐式的输入也可能导致副作用 let ids = { prefix : \"_\" , generate () { return this . prefix + Math . random (); } }; 我们可以创建一个包装函数来传入可读的上下文 let safer_generate = context => ids . generate . call ( context ); safer_generate ({ prefix : \"foo\" }); // \"foo0.8988802158307285\" 本质上，我们并没有消除副作用的影响，而是尽可能的做到在运行时能将 bug 定位在仍然使用副作用的代码上。","text_tokens":["因果","复原","已经","done","of","能够","明显","下列","编程","属于","显然","this","看待","消除","重复","就","不变","put","22","as","mentally","输入输出","结构","实际上","太","任何","说明","分配","总而言之","userlist","and","并且","跟踪","」","largecount","lastlogin","with","boolean","effect","时","意味着","一行","中有","时候","几个","更改","16","需要","无法","仅仅","let","添加","简单","设置","伪","min","规矩","类型","功能","之后","永远","发送","第三","只不过","很蠢","ids","因素","yes","隐蔽","hist","包装","为","第二","服务器资源","可能","get","纯","允许","但","有利于","提供","b","去","变量","[","原本","并非","可读","来说","lower","观察","the","作用域","于","角度","=","shallow","work","可读性","实现","我","不是","恢复","转换","「","大部","引用","radius","simple","!","historytext","/","改进","应当","突变","另","来自","库","起始值","pre","利于","强制","减少","nums","相关","性","局限于","或是","数据结构","height","median","userid","有效","3","...","前提","透明","中","表达","内部","circlearea","返回值","从","]","做","输出","负面","¶","深","渲染","了","很多","also","tolowercase","本质","foo0.8988802158307285","写带","才能","因为","最","\"","产生","易见","其实","transparency","透明性","handleinactiveusers","转移","api","有","每次","而","bliss","w","发现","是","&&","只有","尽可","impure","运算","ajax","arr","所以","时能","be","我会","创建","math","length","所有","contrived","拷贝","用","会","remove","是因为","引入","第三种","createtextnode","该","外部","true","upper","3.141592","lastvalue","事实","or","因此","使得","自身","不仅仅","capture","顺序","numbers","its","访问","的","重新分配","固定","吗","而言","objects","二次","之为","对象","函数调用","意味","更","calculateaverage","至关","常见","we","折叠","再","object","公式","也","num","达式","原","不会","作为","换句","换句话说","尽量","正式","将值","确保","person","有利","时才","纯度","自己","大部分","500001","局限","更新","是从","比如","both","undefined","f","第一","总是","11","下文","defineproperty","这项","for","来","行为","function","..","多个","好处","认为","并","make","资源","不过","函数","不","pure","传入","对","specialnumber","一个","带有","ok","不得不","随机","fetchuserdata","关注","calculated","输入","显而易见","io","表达式","约定","这里","special","给定","规避","x","难以","限于","相同","date","output","结果","fn","context","例子","force","3.5","某个","name","读","处理","取决于","偶然","带来","原因","copy","appendchild","存在","mutation","栗子","e6","替换","仍然","常数","两点","user","这个","initial","制裁","捕获","这","非幂","addmaxnum","掩盖","val","地方","容易","referential","满足","simplelist",">","变","看不出","操作","以下","sides","内","直接","程序","was","花销","es6","orderhistory","与","relative","如何","常量","呢","闭包",";","表现","后续","sum",":","三方","只能","判断","performance","重要","random","偶然性","修改","skip","他们","地","不断","不同","覆盖","various","pi","document","splice","第二次","list","generatemorerandoms","心算","这样","封装","影响","v","一点","做到","编译","捕捉","优化","看起来","心灵","getelementbyid","调用","变成","来看","执行","适当","return","事实上","set","这么","+","在","应该","string","add","给","dom","第一次","smallcount","non","js","换句话","memoization","改变","impurity","至关重要","const","序列","just","mapper","push","像","。","决定","他","上下","a","immutable","知道","返回","example","cache","restore","generate","清晰","实在","remembernumbers","它","lastupdated","some","{","隐式","directly","考虑","call","让","异步","不仅","max","目标","，","transparent","缓存","当","显而","前者","参数","map","称之为","42","direct","effects","库中","0","第三方","restapi","orig","state","accessed","987654321","silly","另外","copied","下面","beware","和","null","只","与否","说","意义","回调","服务","safer","不得","调用函数","revisited","状态","后","由","例如","var","保证","虽然","}","数组","是否","topower0","几乎","untouched","纯净","from","定位","文章","`","其他","属性","floor","maxnum","数学","上"," ","数据","提纯","already","注意","下","将","可以","复制","当中","一些","obj","console","两个","round","分析","内置","服务器","6","还","now","2","未","只要","could","inactive","当有","一篇","onuserdata","y","str","count","foo","明性","touppercase","发生","那么","false","就是说","$","基本","方法","<","定义","latestupdate","if","recall","变化","但是","1","innerhtml","语言","n","当做","只是","array","brute","idempotent","firstvalue","之一","7","恢复原","'","当前","log","同步","读者","it","导致","重新","技术","5","看起","493827162","else",".","运行","算法","copieduserlist","libs","副作用","iife","也就是说","不能","naive","(","依赖","实际","造成","代码","number","自由","不纯","一致","使用","初始","潜伏","ve","性能","10","*","http","我们","限制","作用","生成","取决","务器","更好","8","那","_","一","0.5","保存","%","mutated","save","起来","datecutoff","没有","之外","到","只会","举个","：","步骤","frameworks","而是","？","就是","这些","order","幂","一种","world","或者","先","ceil","接受","bug","hello","expose","上下文","snapup3","方式","updatecounter","-","都","up","为了","如果","purely","俗称","部分","代替","assign","ui","++","i","传递","怎样","一部","手段","很差","采用","人","起始","你","original","cylindervolume","通过","三种","很","一次","不出","多次","能","reverse","肉","区别",")","被","给出","update","pow","在于","有些","getter","尽可能","3.14","避免","一部分","prefix","side","avg","具备","验证","首先","要","4","等","users","有时","请求",",","9"],"title":"Side Effects","title_tokens":[" ","side","effects"]},{"location":"javascript/fp/side-effect/#side-effects","text":"副作用意味着代码的读者需要「人肉编译」才能跟踪某个变量的变化。 副作用的产生可能是因为一个返回值中的引用，例如引用的 state 发生了 Mutation「突变」。 因此，所有影响到函数输出的因素都应该作为函数的输入。","text_tokens":["中","意味","需要","返回值","某个","应该","变量","例如","所有","「","引用","mutation","到","输出","副作用","人","是因为","发生","，","了","突变","代码","肉","函数","变化","一个","。","因素","才能","跟踪","」"," ","因为","产生","作为","因此","state","影响","返回","可能","输入","意味着","的","编译","都","读者","作用"],"title":"Side Effects","title_tokens":[" ","side","effects"]},{"location":"javascript/fp/side-effect/#_1","text":"一个约定俗称的规矩是从不覆盖函数的实现，因此函数作为自由变量引用，可以当做引用了一个常量。 考虑两点，当有一个函数时 给定输入，输出是不变的吗？ 引入的自由变量每次都是不变的吗？程序中有其他地方可能会修改这个自由变量吗？","text_tokens":["俗称","中有","是从","程序","实现","常量","考虑","当有","引用","会","输出","规矩","引入","，","不变","修改","了","？","两点","这个","自由","函数","不","其他","一个","覆盖","。","作为"," ","当做","因此","地方","时","输入","可能","可以","约定","每次","的","给定","都","吗","是","变量"],"title":"固定状态","title_tokens":["状态","固定"]},{"location":"javascript/fp/side-effect/#_2","text":"随机函数也会产生副作用。 大部分语言中的随机都是采用伪随机算法，有些语言提供了起始值，因此给定相同的起始值生成的随机序列都是一致的。 但是 js 没有提供这项功能，因此 js 中偶然性也是副作用的一种","text_tokens":["中","部分","生成","偶然","没有","大部","伪","这项","会","算法","采用","副作用","起始","功能","偶然性","，","js","了","也","起始值","函数","一种","序列","一致","但是","。","语言","随机"," ","有些","产生","因此","的","给定","大部分","都","提供","是","作用","相同"],"title":"偶然性","title_tokens":["偶然性","偶然"]},{"location":"javascript/fp/side-effect/#io-effects","text":"最常见的副作用就是 IO 输入输出 比如 DOM，当修改 DOM 之后，事实上就已经产生了副作用 再比如两个依赖自由变量的 ajax，当异步请求的时候，如果回调执行的 顺序 不一致，可能会产生 bug，但是我们难以捕捉他们。 因为很多时候，这些 bug 只会带来 ui 渲染上的不一致，或者只是简单的状态改变。","text_tokens":["时候","执行","已经","ajax","比如","我们","ui","事实上","常见","状态","带来","异步","简单","dom","再","会","输出","只会","副作用","就","渲染","，","之后","修改","输入输出","了","依赖","他们","很多","改变","就是","当","自由","这些","不","或者","一致","但是","事实","。","上"," ","因为","最","产生","bug","只是","输入","可能","顺序","io","的","两个","请求","捕捉","变量","难以","作用","如果","回调"],"title":"IO Effects","title_tokens":[" ","io","effects"]},{"location":"javascript/fp/side-effect/#_3","text":"如果不得不通过副作用修改状态，制裁方式之一是 幂等性","text_tokens":["制裁","之一","状态","幂","副作用","等","不得","方式","，","通过","修改","不得不","是"," ","作用","如果","性"],"title":"制裁副作用","title_tokens":["作用","副作用","制裁"]},{"location":"javascript/fp/side-effect/#_4","text":"首先给出一个在「数学」上和「编程」上都不属于幂等的例子 let updateCounter = obj => { if ( obj . count < 10 ) { obj . count ++ ; return true ; } return false ; };","text_tokens":["例子","{","return","=","++","在","编程",".","let",";","「","属于","count","}","false","<","(","true",")","给出","不","幂","if","一个","数学","上"," ","」","首先","10","等","的","updatecounter","obj","都",">","和"],"title":"幂等性","title_tokens":["幂","性","等"]},{"location":"javascript/fp/side-effect/#_5","text":"从数学角度来看，幂等性意味着在第一次调用后输出不会改变的操作。 更清晰的例子。 f(x) = f(f(x)) = f(f(f(x))) 在 js 内置的 Math 库中，下面这些例子显然是幂等性的。 Math.min(..) Math.max(..) Math.round(..) Math.floor(..) Math.ceil(..) 我们也可以自己定义一些幂等性的运算 let toPower0 = x => Math . pow ( x , 0 ); let snapUp3 = x => x - ( x % 3 ) + ( x % 3 > 0 && 3 ); toPower0 ( 3 ) == toPower0 ( toPower0 ( 3 )); // true snapUp3 ( 3.14 ) == snapUp3 ( snapUp3 ( 3.14 )); // true 数学角度的幂等性并不仅仅局限于数学运算，js 中基本类型强制转换也是幂等的 let x = 42 , y = 'hello' ; String ( x ) === String ( String ( x )); // true Boolean ( y ) === Boolean ( Boolean ( y )); // true 或是 let upper = v => v . toUpperCase (); let lower = v => v . toLowerCase (); let str = 'Hello World' ; upper ( str ) == upper ( upper ( str )); // true lower ( str ) == lower ( lower ( str ) ); // true 总而言之，幂等性就是满足下列公式的数学表达式 f(x) = f(f(x))","text_tokens":["操作","运算","math","下列",";","y","str","显然","touppercase","基本","定义","true","总而言之","upper","boolean","不仅仅","v","意味着","的","'","而言","调用","来看","意味","更","+","在","仅仅",".","let","string","第一次","min","类型","js","公式","(","改变","也","达式","不会","。","清晰","自己","我们","局限","lower","角度","=","f","%","第一","不仅","转换","max","..","，","/","并","就是","这些","幂","world","强制","42","ceil","库中","0","性","局限于","hello","或是","表达式","snapup3","-","下面","3","x","限于","中","表达","例子","从","后","输出","topower0","一次",")","tolowercase","floor","pow","数学"," ","3.14","满足","可以","等","一些","round",">",",","是","内置","&&"],"title":"数学上的幂等性","title_tokens":["幂","等","的","数学","上","性"]},{"location":"javascript/fp/side-effect/#_6","text":"程序中的幂等性没有那么正式，换句话说，当第一次调用 f(x) 与第二次调用的返回值没有区别，从程序的角度，我们认为是幂等的。 就像在 Http 的 RESTapi 中，PUT 被定义为更新服务器资源，当发送多个带有相同参数的 PUT 时，服务器资源都具备相同的结果状态。 // idempotent:幂等 obj . count = 2 ; a [ a . length - 1 ] = 42 ; person . name = upper ( person . name ); // non-idempotent:非幂等 obj . count ++ ; a [ a . length ] = 42 ; person . lastUpdated = Date . now (); 因此，幂等性的定义是，在第一次调用之后，后续怎样的重复调用，程序状态都不会再改变。非幂等性在每次调用都会更改程序状态。 那么在 DOM 更新中如何表现呢？ let hist = document . getElementById ( 'orderHistory' ); // idempotent: hist . innerHTML = order . historyText ; // non-idempotent: let update = document . createTextNode ( order . latestUpdate ); hist . appendChild ( update ); // 隐式的，当前状态是下一状态的一部分 我们并不能总是幂等的定义我们的操作，但这有利于减少副作用的影响。","text_tokens":["2","操作","程序","orderhistory","与","如何","呢","length",";","表现","后续","count",":","会","重复","那么","就","put","定义","createtextnode","latestupdate","upper","1","document","innerhtml","第二次","因此","idempotent","时","影响","的","'","当前","getelementbyid","调用","二次","更改","在",".","let","dom","第一次","再","non","副作用","之后","换句话","发送","不能","(","改变","不会","像","。","换句","换句话说","hist","正式","为","第二","服务器资源","a","返回","person","有利","但","http","有利于","我们","[","作用","更新","务器","lastupdated","一","角度","=","隐式","f","第一","总是","没有","historytext","，","/","多个","？","认为","并","当","资源","order","幂","利于","参数","减少","带有","42","restapi","性","-","都","x","相同","date","结果","中","部分","服务","返回值","从","name","]","++","怎样","状态","一部","appendchild","一次","区别",")","被","这","非幂","update"," ","一部分","具备","下","等","每次","obj","是","服务器","now"],"title":"程序中的幂等性","title_tokens":["中","幂","程序","等","的","性"]},{"location":"javascript/fp/side-effect/#pure-bliss","text":"一个没有副作用的函数称之为 Pure Function ，也就是「纯」函数 纯函数在编程角度来说是幂等的，因为没有任何副作用。 let add = ( a , b ) => a + b 可以发现所有的输入输出都是直接的，没有引用任何自由变量，多次调用 add 函数与只调用一次没有任何区别。所以 add 是一个幂等纯函数。 但是在数学意义中，不是所有纯函数都是幂等的，因为的返回值可能不能作为他们的输入。 let calculateAverage = nums => { let sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } calculateAverage ([ 1 , 2 , 4 , 7 , 11 , 16 , 22 ]); // 9 在这个例子中，返回值并非一个数组，因此不可能「recall」 calculateAverage(calculateAverage(nums)) 纯函数也可以引用自由变量和其他函数，前提是自由变量没有副作用。 const PI = 3.141592 ; let circleArea = radius => PI * radius * radius ; let cylinderVolume = ( radius , height ) => height * circleArea ( radius ); 另一个纯函数引用自由变量的例子就是 闭包 虽然 circleArea 是一个函数对象，我们可以给他添加一个可能「突变」的属性，但是不影响 circleArea 调用。因此只要不重新分配函数，就没有副作用。 验证纯函数的另一种方式是，相同的输入永远产生相同的输出。 如果一个函数给相同的输入产生不同的输出，那么就不是一个纯函数。 在 js 中，写带副作用的代码实在是太容易了。","text_tokens":["2","直接","只要","所以","与","of","编程","闭包","length",";","sum","所有","那么","就","22","输入输出","太","他们","任何","分配","recall","3.141592","不同","但是","1","pi","」","因此","影响","7","的","重新分配","调用","之为","对象","16","calculateaverage","return","重新","+","在",".","let","添加","add","给","副作用","js","永远","不能","(","代码","也","自由","num","const","。","作为","他","a","返回","可能","纯","b","*","实在","变量","[","作用","我们","并非","来说","{","角度","=","不是","没有","11","「","引用","for","radius","function","，","/","另","突变","就是","函数","pure","幂","不","一种","一个","称之为","nums","0","输入","height","方式","都","和","只","前提","相同","如果","意义","中","circlearea","例子","返回值","]","虽然","}","数组","输出","cylindervolume","一次","了","多次","这个","区别",")","其他","属性","写带","数学"," ","因为","产生","容易","验证","可以","4","等",",",">","发现","是","9"],"title":"Pure Bliss","title_tokens":[" ","pure","bliss"]},{"location":"javascript/fp/side-effect/#purely-relative","text":"let rememberNumbers = nums => fn => fn ( nums ); let list = [ 1 , 2 , 3 , 4 , 5 ]; let simpleList = rememberNumbers ( list ); simpleList 像一个纯函数，但实际上并不是， let median = nums => ( nums [ 0 ] + nums [ nums . length - 1 ]) / 2 ; simpleList ( median ); // 3 list . push ( 6 ); simpleList ( median ); // 3.5 显而易见，当我们修改输入引用的自由变量，返回值就发生了变化。 可以通过复制数组使得 simpleList 变成纯函数。 let rememberNumbers = nums => { // make a copy of the array nums = [... nums ]; return fn => fn ( nums ); } 但是这可能会导致一个更隐蔽的副作用潜伏。 let list = [ 1 , 2 , 3 , 4 , 5 ]; // make `list[0]` be a getter with a side effect Object . defineProperty ( list , 0 , { get : () => { console . log ( \"[0] was accessed!\" ); return 1 ; } } ); let simpleList = rememberNumbers ( list ); // [0] was accessed! 这个副作用看起来无法避免，但是我们可以将它从函数内部转移到调用函数的地方。 let rememberNumbers = (... nums ) => fn => fn ( nums ) let simpleList = rememberNumbers (... list ); // [0] was accessed! 这样做的好处是，rememberNumbers 是纯函数，造成副作用的原因在于 ...","text_tokens":["2","was","of","be","length",";",":","会","发生","就","修改","实际上","变化","但是","1","list","with","array","这样","使得","effect","的","log","看起来","调用","变成","导致","更","return","无法","5","看起","+",".","let","副作用","object","(","实际","造成","自由","push","像","。","潜伏","隐蔽","a","返回","可能","get","纯","但","我们","变量","[","作用","remembernumbers","它","the","{","=","不是","起来","引用","defineproperty","到","!","，","/","好处","并","显而","当","make","函数","一个","nums","0","accessed","输入","显而易见","median","-","3","...","fn","内部","3.5","返回值","从","]","调用函数","原因","copy","做","}","数组","通过","了","`","这个",")","这","在于"," ","getter","\"","避免","side","易见","地方","将","转移","可以","4","复制","console","simplelist",">",",","是","6"],"title":"Purely Relative","title_tokens":[" ","relative","purely"]},{"location":"javascript/fp/side-effect/#_7","text":"// yes, a silly contrived example :) let firstValue = nums => nums [ 0 ]; let lastValue = nums => firstValue ( nums . reverse ()); simpleList ( lastValue ); // 5 console . log ( list ); // [1,2,3,4,5] -- OK! simpleList ( lastValue ); // 1 reverse() 方法其实修改了原本的数组，只不过修改的是内部引用的数组。 怎样改进呢？ let rememberNumbers = (... nums ) => fn => fn ([... nums ]); 可以通过传递一个数组拷贝来避免接受该数组的函数在调用时改变原数组。 但是仍然无法保证传递一个不纯的函数。因此，我们只能尽量的让函数 pure，为了可读性。","text_tokens":["2","呢",";","拷贝","contrived",":","只能","修改","方法","该","lastvalue","但是","1","list","因此","firstvalue","时","的","log","调用","无法","5","在",".","let","只不过","(","改变","原","不纯","。","yes","尽量","a","example","我们","原本","[","可读","remembernumbers","=","可读性","让","引用","!","来","，","/","改进","？","不过","函数","pure","一个","nums","ok","0","接受","silly","-","3","...","为了","fn","内部","]","传递","怎样","保证","数组","仍然","通过","了","reverse",")"," ","避免","其实","可以","4","console","simplelist",",",">","是"],"title":"纯函数 + 不纯函数 = 不纯函数","title_tokens":["函数","不","纯","=","+"," "]},{"location":"javascript/fp/side-effect/#referential-transparency","text":"判断一个函数是否纯净的第三种方式，是 Referential transparency 「引用透明性」。如果将值替换函数调用的那一行，行为上没有任何变化，那么该函数就是纯函数。 也就是说，在一个程序当中，我们用一个 val 代替了一个函数调用，在执行上我们看不出任何区别。 如果一个函数存在副作用，但是在程序的任何地方都没有被观察到或者被依赖，那么他还具备「引用透明性」吗？ let sum ; let calculateAverage = nums => { sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } let numbers = [ 1 , 2 , 4 , 7 , 11 , 16 , 22 ]; let avg = calculateAverage ( numbers ); 不得不说它和纯函数几乎没有区别，但是如何看待他取决于你自己","text_tokens":["2","程序","of","如何","length",";","sum","用","明性","看待","判断","那么","就是说","第三种","22","该","任何","变化","但是","1","」","numbers","7","的","吗","一行","调用","执行","函数调用","16","calculateaverage","return","+","在",".","let","副作用","也就是说","第三","依赖","(","num","。","他","将值","纯","自己","我们","[","作用","取决","观察","它","那","{","=","没有","11","「","引用","到","for","行为","，","/","？","就是","函数","或者","一个","nums","不得不","0","方式","都","和","如果","透明","说","代替","不得","]","取决于","是否","存在","}","几乎","你","替换","纯净","三种","不出","了","区别",")","被","上"," ","val","透明性","transparency","referential","地方","具备","avg","当中","4",">",",","是","看不出","还"],"title":"Referential transparency","title_tokens":[" ","transparency","referential"]},{"location":"javascript/fp/side-effect/#performance-effects","text":"观察这个函数 let cache = []; let specialNumber = n => { // if we've already calculated this special number, // skip the work and just return it from the cache if ( cache [ n ] !== undefined ) { return cache [ n ]; } var x = 1 , y = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { x += i % 2 ; y += i % 3 ; } cache [ n ] = ( x * y ) / ( n + 1 ); return cache [ n ]; } specialNumber ( 6 ); // 4 specialNumber ( 42 ); // 22 specialNumber ( 1 E6 ); // 500001 specialNumber ( 987654321 ); // 493827162 我们通过一个缓存来优化多次调用这个函数的性能，但是这看起来很蠢，你可能认为他是纯函数，但是我不这么认为。 let specialNumber = ( function memoization (){ let cache = []; return function specialNumber ( n ){ // if we've already calculated this special number, // skip the work and just return it from the cache if ( cache [ n ] !== undefined ) { return cache [ n ]; } let x = 1 , y = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { x += i % 2 ; y += i % 3 ; } cache [ n ] = ( x * y ) / ( n + 1 ); return cache [ n ]; }; })(); 我们通过 IIFE 来 确保 函数的其他部分不能访问到 cache，而不仅仅是 不允许 在这里至关重要的一点，就是我们能确保，而不仅仅是心灵约定。","text_tokens":["2",";","y","this","重要","22","<","skip","if","and","但是","1","n","不仅仅","访问","一点","'","的","优化","it","看起来","心灵","调用","return","至关","看起","这么","493827162","+","在","we","仅仅","let","iife","不能","memoization","(","很蠢","number","至关重要","just","。","他","ve","cache","性能","可能","确保","纯","允许","*","我们","500001","[","观察","the","{","=","undefined","%","work","我","起来","不仅","到","for","!","来","function","，","/","缓存","认为","就是","函数","不","specialnumber","一个","42","calculated","987654321","约定","这里","special","3","x","部分","]","i","++","var","}","e6","你","from","通过","多次","能","这个",")","其他","这"," ","already","4","而",">",",","是","6"],"title":"Performance Effects","title_tokens":[" ","performance","effects"]},{"location":"javascript/fp/side-effect/#mentally-transparent","text":"虽然有时将常数和函数调用替换对函数的执行没有影响，但是我们不应该这么做。 不仅仅是因为数据可能是变化的，还为了更好地可读性。 读者会不断地心算一个永远不会变的结果，但是纯函数能够减少这样的花销。","text_tokens":["结果","执行","函数调用","更好","花销","能够","这么","可读性","应该","仅仅","不仅","没有","做","虽然","会","替换","是因为","常数","，","永远","读者","函数","不","地","对","不断","变化","减少","但是","一个","不会","。","数据"," ","因为","心算","这样","影响","不仅仅","将","可能","纯","的","有时","和","是","我们","变","为了","调用","还","可读"],"title":"Mentally Transparent","title_tokens":["mentally","transparent"," "]},{"location":"javascript/fp/side-effect/#_8","text":"可以将副作用从函数内部转移到调用函数的地方，这看起来更明显。 举个栗子 let addMaxNum = arr => { let maxNum = Math . max (... arr ); arr . push ( maxNum + 1 ); } let nums = [ 4 , 2 , 7 , 3 ]; addMaxNum ( nums ); // [4,2,7,3,8] //改进 let addMaxNum = arr => Math . max (... arr ) + 1 ; let nums = [ 4 , 2 , 7 , 3 ]; nums . push ( addMaxNum ( nums )); // [4,2,7,3,8] 我们可以将 addMaxNum 折叠起来了，我们不需要再去观察 addMaxNum 的内部实现。 另外一种方式是采用 immutable 数据结构来实现，我会在下一篇文章说明 我们还可以从这几个角度来分析。","text_tokens":["2","arr","我会","明显","math","一篇",";","结构","说明","1","7","的","看起来","调用","几个","更","需要","看起","+","在","折叠",".","let","再","副作用","(","push","。","immutable","去","我们","[","作用","观察","8","{","角度","=","实现","起来","到","max","举个","来","，","/","改进","函数","不","一种","nums","数据结构","另外","方式","3","...","内部","从","调用函数","]","}","栗子","采用","了","文章",")","这","addmaxnum","maxnum","数据"," ","地方","将","转移","下","可以","4",">",",","分析","是","还"],"title":"函数提纯","title_tokens":["函数","提纯"]},{"location":"javascript/fp/side-effect/#_9","text":"如果一个函数是不纯的，并且引用了外部的自由变量，我们可以使用作用域来封装。 let users = {}; let fetchUserData = userId => { ajax ( `http://some.api/user/ ${ userId } ` , function onUserData ( user ){ users [ userId ] = user ; }); } // 改进 function safer_fetchUserData ( userId , users ) { // simple, naive ES6+ shallow object copy, could also // be done w/ various libs or frameworks users = Object . assign ( {}, users ); fetchUserData ( userId ); // return the copied state return users ; // *********************** // original untouched impure function: function fetchUserData ( userId ) { ajax ( `http://some.api/user/ ${ userId } ` , function onUserData ( user ){ users [ userId ] = user ; } ); } } 函数的纯度与否其实是由外部决定的，内部也可以适当的采用一些不纯的技术，比如为了性能使用 cache 缓存结果。 但是我们的目标是尽可能的减少副作用。","text_tokens":["impure","尽可","ajax","could","es6","done","be","onuserdata",";",":","$","外部","并且","但是","various","or","封装","的","适当","return","技术","+",".","let","libs","object","副作用","naive","(","也","自由","不纯","使用","。","决定","性能","cache","可能","纯度","*","http","变量","我们","[","作用","the","作用域","some","_","{","比如","shallow","=","引用","simple","来","function","目标","，","/","frameworks","改进","缓存","函数","减少","一个","fetchuserdata","state","userid","copied","为了","如果","与否","结果","内部","assign","safer","]","由","copy","}","untouched","采用","original","了","user","`","also",")"," ","尽可能","其实","api","可以","一些","users",">",",","w","是"],"title":"自由变量","title_tokens":["自由","变量"]},{"location":"javascript/fp/side-effect/#_10","text":"有些时候，不纯的函数来自于第三方库，你无法直接将自由变量封装在函数的作用域内 let nums = []; let smallCount = 0 ; let largeCount = 0 ; function generateMoreRandoms ( count ) { for ( let i = 0 ; i < count ; i ++ ) { let num = Math . random (); if ( num >= 0.5 ) { largeCount ++ ; } else { smallCount ++ ; } nums . push ( num ); } } 我们可以通过 brute-force 算法执行以下步骤来改进： 保存未被影响的当前状态 设置初始输入状态 运行不纯的函数 捕获副作用 恢复原状态 返回副作用状态 function safer_generateMoreRandoms ( count , initial ) { // (1) Save original state let orig = { nums , smallCount , largeCount }; // (2) Set up initial pre-side effects state nums = [... initial . nums ]; smallCount = initial . smallCount ; largeCount = initial . largeCount ; // (3) Beware impurity! generateMoreRandoms ( count ); // (4) Capture side effect state let sides = { nums , smallCount , largeCount }; // (5) Restore original state nums = orig . nums ; smallCount = orig . smallCount ; largeCount = orig . largeCount ; // (6) Expose side effect state directly as output return sides ; } 需要注意的是 掩盖 手段只有在处理同步代码时才有效。","text_tokens":["2","未","复原","以下","sides","内","直接","math",";","count","三方","random","as","<","if","1","largecount","generatemorerandoms","封装","brute","影响","effect","capture","恢复原","的","当前","同步","时候","执行","需要","return","无法","5","set","在","else",".","let","设置","运行","smallcount","算法","副作用","第三","(","代码","自由","num","impurity","不纯","push","。","初始","返回","restore","时才","我们","变量","[","作用","作用域","于","{","_","=","0.5","保存","恢复","save","directly","for","来","!","function","：","，","步骤","/","改进","来自","库","函数","pre","nums","effects","0","第三方","orig","state","expose","输入","up","-","beware","有效","3","...","output","force","safer","]","i","++","处理","状态","}","手段","你","original","通过","initial",")","捕获","被","有些"," ","掩盖","注意","side","将","可以","4",">",",","是","6","只有"],"title":"掩盖","title_tokens":["掩盖"]},{"location":"javascript/fp/side-effect/#_11","text":"当我们要处理的副作用是一个 突变 的输入导致的，「数组」或是「对象」我们可以这样做 function handleInactiveUsers ( userList , dateCutoff ) { for ( let i = 0 ; i < userList . length ; i ++ ) { if ( userList [ i ]. lastLogin == null ) { // remove the user from the list userList . splice ( i , 1 ); i -- ; } else if ( userList [ i ]. lastLogin < dateCutoff ) { userList [ i ]. inactive = true ; } } } 先做一个深拷贝 function safer_handleInactiveUsers ( userList , dateCutoff ) { // make a copy of both the list and its user objects let copiedUserList = userList . map ( function mapper ( user ){ // copy a `user` object return Object . assign ( {}, user ); }); // call the original function with the copy handleInactiveUsers ( copiedUserList , dateCutoff ); // expose the mutated list as a direct output return copiedUserList ; }","text_tokens":["of","inactive","length",";","拷贝","remove","as","<","true","if","userlist","and","splice","1","」","list","lastlogin","with","这样","its","的","objects","对象","导致","return","else",".","let","copieduserlist","副作用","object","(","mapper","a","我们","[","作用","the","_","{","both","=","mutated","call","datecutoff","「","for","function","，","/","突变","当","make","map","一个","先","direct","0","或是","expose","输入","-","null","output","assign","safer","++","处理","i","]","copy","做","}","数组","深","original","from","user","`",")"," ","handleinactiveusers","可以","要",",","是"],"title":"规避","title_tokens":["规避"]},{"location":"javascript/fp/side-effect/#this-revisited","text":"有的时候 this 作为一个隐式的输入也可能导致副作用 let ids = { prefix : \"_\" , generate () { return this . prefix + Math . random (); } }; 我们可以创建一个包装函数来传入可读的上下文 let safer_generate = context => ids . generate . call ( context ); safer_generate ({ prefix : \"foo\" }); // \"foo0.8988802158307285\" 本质上，我们并没有消除副作用的影响，而是尽可能的做到在运行时能将 bug 定位在仍然使用副作用的代码上。","text_tokens":["时候","导致","尽可","context","_","{","return","=","隐式","safer","时能","创建","+","在","call","math",".","let",";","没有","下文","this","运行",":","}","foo","random","消除","副作用","来","仍然","，","/","而是","定位","(","并","也","代码",")","函数","传入","ids","本质","一个","使用","foo0.8988802158307285","。","作为"," ","上","\"","尽可能","bug","上下","包装","prefix","有","影响","输入","可能","上下文","将","generate","可以","做到","的",",",">","我们","作用","可读"],"title":"this Revisited","title_tokens":[" ","revisited","this"]},{"location":"javascript/fp/value-immutable/","text":"这一节和上节一样，都是为了减少副作用而努力。 如果说编程角度的幂等让一个数值改变的操作变为一次，那么不可变数据结构就是将其变为 0 次。 原始数据类型的 immutable ¶ JavaScript 中的原始类型一直是不可变的，无法修改。 但是 JS 有一种奇怪的「装箱」行为，在访问原始类型的属性时触发。 JS 在这种情况下自动将值包裹在一个「装箱对象」中。 let x = 2 ; x . length = 4 ; // 严格模式下报错 x ; // 2 x . length ; // undefined let x = new Number ( 2 ); // works fine x . length = 4 ; 那么，字符串呢？ \"use strict\" ; let s = new String ( \"hello\" ); s [ 1 ]; // e s [ 1 ] = \"E\" ; // error s . length = 10 ; // error s [ 42 ] = \"?\" ; // OK s ; // \"hello\" // 即使是装箱对象，大部分属性也不可以变 let s = new String ( \"hello\" ); s [ 1 ] = \"E\" ; // error s . length = 10 ; // error s [ 42 ] = \"?\" ; // OK s ; // \"hello\" Value to Value ¶ 首先，必须在心里上有一个清晰地认知，immutable 数据不代表在整个程序中我们不修改这个值。 immutable 的核心理念是在我们需要修改某个值的时候，我们创建一个新的值而不是对已有的值「突变」。 举个栗子 let addValue = arr => [... arr , 4 ]; addValue ([ 1 , 2 , 3 ]); // [1,2,3,4] 这意味着我们可以控制我们程序的状态，除了 addValue，没有任何东西能改变状态。 我们也可以复制对象而不是产生对象的「突变」 let user = { // .. }; function updateLastLogin ( user ) { let newUserRecord = Object . assign ({}, user ); newUserRecord . lastLogin = Date . now (); return newUserRecord ; } user = updateLastLogin ( user ); 非原始数据类型 ¶ 非原始数据类型作为参数传递时会复制一个引用传递，而不是它本身的值。 let arr = [ 1 , 2 , 3 ]; foo ( arr ); console . log ( arr [ 0 ]); 显然，我们不能保证打印的值仍然为 1，这时我们要用到上一节的技巧 let arr = [ 1 , 2 , 3 ]; foo ([... arr ]); // ha! a copy! console . log ( arr [ 0 ]); // 1 Reassignment ¶ 如何定义常量？可能有各种各样不同的回答，但是最接近真相的一个回答就是。 一个不能被再分配的变量 这种挑剔的描述很重要。因为这说明了一个常数与他的值无关，不管常数保持什么值，都不能再为这个常数分配其他的值。 let x = 1 ; // 我们为 x 分配了一个不可以改变的原始值 x = 3 ; // x: 3 const x = 4 ; // 我们定义了一个不可以再分配的变量 x x = 3 ; // Error const x = [ 2 ]; x [ 0 ] = 4 ; // x: [4] x = [] // Error 我想上面的例子清晰地阐述了「常数」和「常量」的区别。 那么对于 FPer 来说，const 有什么作用呢 Intent ¶ const 可以明显的从语义上提示读者这个变量是不可以再分配的。 但是 const 的缺点也很明显，首先，对于引用类型，依旧无法保证「突变」，其次，这和 immutable 数据发生冲突。 const magicNums = [ 1 , 2 , 3 , 4 ]; magicNums = magicNums . concat ( 42 ); // error 所以对于 FPer，我们只使用 const 声明一些简单的常量。 如 const PI = 3.141592653 需要注意的是，我们关心的重点始终是值的「突变」，而不是变量的分配。 Freezing ¶ 有一种简单的方式让对象、数组、函数变成一个 \"immutable value\" let x = Object . freeze ([ 2 ]); freeze 遍历对象与数组的所有属性和索引，将它们变为已读和「不可被重新配置」，所以这些属性不能被「再分配」。 同时，freeze 将对象标记成不可拓展，也就是无法添加新属性。 但是要注意的是，freeze 不可变的层级只有一层。也就是「shadow immutable」。 如果想要深度 immutable，那么需要递归遍历对象。 let x = Object . freeze ([ 2 , 3 , [ 4 , 5 ]]); // not allowed: x [ 0 ] = 42 ; // oops, still allowed: x [ 2 ][ 0 ] = 42 ; 与 const 不同的是，const 让你误以为这个值不可变，而 freeze 才真正做到了这点。 let arr = Object . freeze ([ 1 , 2 , 3 ]); foo ( arr ); console . log ( arr [ 0 ] ); // 1 性能 ¶ 当我们每次都新创建一个值而不是「突变」一个存在的值，下一个要关注的点就是性能问题。 是否可以考虑一种特殊的数组结构，存储每一次「增量修改」。 仅记录与上一个版本的差异，而不是整个原始数据结构的重复。 let state = specialArray ( 4 , 6 , 1 , 1 ); let newState = state . set ( 4 , 2 ); // 在位置 4 上插入 2 state === newState ; // false state . get ( 2 ); // 1 state . get ( 4 ); // undefined newState . get ( 2 ); // 1 newState . get ( 4 ); // 2 newState . slice ( 2 , 5 ); // [1,1,2] specialArray 用 diff 的方式跟踪每个「突变」，且 state 和 newState 指向数值的不同版本。 immutable.js 提供了一个实现 let state = Immutable . List . of ( 4 , 6 , 1 , 1 ); let newState = state . set ( 4 , 2 ); state === newState ; // false state . get ( 2 ); // 1 state . get ( 4 ); // undefined newState . get ( 2 ); // 1 newState . get ( 4 ); // 2 newState . toArray (). slice ( 2 , 5 ); // [1,1,2] immutable.js 采用了复杂的性能优化实现。自己实现太麻烦了~ Treatment ¶ 不管函数接收到一个值是可变的还是不可变的，我们都把它当做 immutable 对待。 总结 ¶ immutable 并不意味着一个变量是不变的。immutable 在状态变更时创建和跟踪一个新的值，而不是对现有的值「突变」。 const 其实与 immutable 无关，而 Object.freeze() 提供了一个很好地方法来保证 immutable。 如果遇见性能瓶颈，可以使用第三方库的不可变数据结构。","text_tokens":["情况","of","心里","深度","明显","javascript","编程","字符","显然","重复","即使","不变","结构","?","太","什么","任何","说明","分配","这点","且","跟踪","」","lastlogin","时","它们","意味着","如","时候","reassignment","需要","无法","let","添加","简单","类型","第三","核心理念","阐述","现有","各种各样","仅","为","声明","可能","get","提供","变量","[","来说","角度","=","实现","我","不是","麻烦","「","大部","引用","concat","!","/","突变","strict","描述","库","减少","数据结构","value","问题","3","...","中","包裹","始终","magicnums","从","]","标记","除了","语义","真正","¶","提示","对待","了","本身","因为","\"","最","产生","上面","有","其实","每次","而","已有","东西","变为","是","只有","arr","所以","创建","各样","报错","length","必须","所有","用","核心","代表","整个","记录","访问","的","oops","对象","意味","newstate","接近","再","object","slice","字符串","次","、","也","addvalue","specialarray","指向","作为","想要","toarray","将值","自己","大部分","关心","diff","新创建","心理","undefined","接收","技巧","用到","shadow","~","来","行为","function","..","遍历","并","函数","不","对","ha","一个","还是","ok","各种","关注","freeze","变更","freezing","位置","allowed","x","date","挑剔","例子","某个","数值","copy","配置","一层","新创","存在","栗子","仍然","常数","user","这个","这","新",">","变","总结","原始数据","intent","操作","程序","保持","与","如何","常量","呢",";",":","三方","重要","这时","语义上","修改","不可","成","冲突","地","不同","原始","pi","list","如果说","非","做到","优化","变成","回答","同时","return","特殊","set","在","string","自动","重新配置","递归","js","改变","const","把","。","控制","他","immutable","a","清晰","认知","以为","每","打印","好","它","{","考虑","这种","让","值","treatment","，","use","当","拓展","参数","数传","42","0","第三方","点","state","和","一节","只","复杂","error","状态","保证","是否","}","努力","数组","newuserrecord","其他","属性","缺点","数据"," ","上","瓶颈","注意","一直","将","下","fper","复制","可以","一些","其次","console","6","now","2","不管","参数传递","重点","已读","foo","那么","发生","false","方法","定义","严格","但是","1","其","当做","still","时会","增量","log","to","读者","误以为","才","存储","重新","5","可变",".","插入","副作用","装箱","fine","发生冲突","不能","上节","(","number","使用","遇见","无关","性能","10","我们","作用","层级","对于","一样","s","触发","没有","到","想","举个","差异","？","版本","就是","这些","e","幂","一种","模式","真相","hello","updatelastlogin","方式","都","为了","如果","奇怪","works","部分","assign","new","传递","3.141592653","每个","你","采用","很","一次","能","区别",")","被","依旧","not","索引","要","4","首先","等",",","理念"],"title":"Value Immutable","title_tokens":[" ","value","immutable"]},{"location":"javascript/fp/value-immutable/#immutable","text":"JavaScript 中的原始类型一直是不可变的，无法修改。 但是 JS 有一种奇怪的「装箱」行为，在访问原始类型的属性时触发。 JS 在这种情况下自动将值包裹在一个「装箱对象」中。 let x = 2 ; x . length = 4 ; // 严格模式下报错 x ; // 2 x . length ; // undefined let x = new Number ( 2 ); // works fine x . length = 4 ; 那么，字符串呢？ \"use strict\" ; let s = new String ( \"hello\" ); s [ 1 ]; // e s [ 1 ] = \"E\" ; // error s . length = 10 ; // error s [ 42 ] = \"?\" ; // OK s ; // \"hello\" // 即使是装箱对象，大部分属性也不可以变 let s = new String ( \"hello\" ); s [ 1 ] = \"E\" ; // error s . length = 10 ; // error s [ 42 ] = \"?\" ; // OK s ; // \"hello\"","text_tokens":["2","情况","呢","javascript","报错","字符","length",";","那么","即使","修改","?","不可","严格","但是","原始","1","」","时","访问","的","对象","无法","在",".","let","string","自动","装箱","类型","fine","字符串","js","(","也","number","。","将值","10","大部分","[","=","undefined","s","这种","触发","「","大部","行为","，","/","？","use","strict","e","不","一种","模式","一个","42","ok","hello","x","奇怪","works","中","包裹","部分","]","new","error",")","属性"," ","\"","有","一直","下","可以","4","是","变"],"title":"原始数据类型的 immutable","title_tokens":["immutable","类型","的","原始","数据"," ","原始数据"]},{"location":"javascript/fp/value-immutable/#value-to-value","text":"首先，必须在心里上有一个清晰地认知，immutable 数据不代表在整个程序中我们不修改这个值。 immutable 的核心理念是在我们需要修改某个值的时候，我们创建一个新的值而不是对已有的值「突变」。 举个栗子 let addValue = arr => [... arr , 4 ]; addValue ([ 1 , 2 , 3 ]); // [1,2,3,4] 这意味着我们可以控制我们程序的状态，除了 addValue，没有任何东西能改变状态。 我们也可以复制对象而不是产生对象的「突变」 let user = { // .. }; function updateLastLogin ( user ) { let newUserRecord = Object . assign ({}, user ); newUserRecord . lastLogin = Date . now (); return newUserRecord ; } user = updateLastLogin ( user );","text_tokens":["2","程序","arr","心里","创建","必须",";","修改","核心","任何","代表","地","整个","1","」","lastlogin","意味着","的","对象","时候","意味","需要","return","在",".","let","object","核心理念","(","改变","也","addvalue","。","控制","immutable","清晰","认知","我们","[","心理","{","=","不是","没有","「","值","举个","function","..","，","/","突变","不","对","一个","updatelastlogin","3","...","date","中","assign","某个","]","状态","除了","}","栗子","newuserrecord","user","能","这个",")","这","上","数据"," ","产生","有","可以","复制","首先","新","4","而","已有","东西",">",",","是","理念","now"],"title":"Value to Value","title_tokens":[" ","value","to"]},{"location":"javascript/fp/value-immutable/#_1","text":"非原始数据类型作为参数传递时会复制一个引用传递，而不是它本身的值。 let arr = [ 1 , 2 , 3 ]; foo ( arr ); console . log ( arr [ 0 ]); 显然，我们不能保证打印的值仍然为 1，这时我们要用到上一节的技巧 let arr = [ 1 , 2 , 3 ]; foo ([... arr ]); // ha! a copy! console . log ( arr [ 0 ]); // 1","text_tokens":["2","它","我们","参数传递","arr","=","]","技巧","传递","不是",".","let","用到","copy",";","保证","引用","显然","值","foo","!","类型","这时","仍然","，","/","不能","(","本身",")","参数","数传","ha","一个","原始","。","1","作为","数据"," ","0","上","非","a","为","时会","复制","要","而","的","console",",","log","3","[","...","打印","原始数据","一节"],"title":"非原始数据类型","title_tokens":["类型","原始","数据","非","原始数据"]},{"location":"javascript/fp/value-immutable/#reassignment","text":"如何定义常量？可能有各种各样不同的回答，但是最接近真相的一个回答就是。 一个不能被再分配的变量 这种挑剔的描述很重要。因为这说明了一个常数与他的值无关，不管常数保持什么值，都不能再为这个常数分配其他的值。 let x = 1 ; // 我们为 x 分配了一个不可以改变的原始值 x = 3 ; // x: 3 const x = 4 ; // 我们定义了一个不可以再分配的变量 x x = 3 ; // Error const x = [ 2 ]; x [ 0 ] = 4 ; // x: [4] x = [] // Error 我想上面的例子清晰地阐述了「常数」和「常量」的区别。 那么对于 FPer 来说，const 有什么作用呢","text_tokens":["2","不管","保持","与","如何","常量","各样","呢",";",":","重要","那么","定义","什么","说明","分配","地","不同","但是","原始","1","」","的","回答","接近","let","再","不能","阐述","改变","const","。","各种各样","他","无关","为","可能","清晰","我们","变量","[","作用","来说","对于","=","我","这种","「","值","想","，","/","？","就是","描述","不","一个","真相","各种","0","都","和","x","3","挑剔","例子","]","error","常数","很","了","这个","区别","其他","被","这"," ","因为","最","上面","有","fper","可以","4"],"title":"Reassignment","title_tokens":["reassignment"]},{"location":"javascript/fp/value-immutable/#intent","text":"const 可以明显的从语义上提示读者这个变量是不可以再分配的。 但是 const 的缺点也很明显，首先，对于引用类型，依旧无法保证「突变」，其次，这和 immutable 数据发生冲突。 const magicNums = [ 1 , 2 , 3 , 4 ]; magicNums = magicNums . concat ( 42 ); // error 所以对于 FPer，我们只使用 const 声明一些简单的常量。 如 const PI = 3.141592653 需要注意的是，我们关心的重点始终是值的「突变」，而不是变量的分配。","text_tokens":["2","所以","明显","常量","重点",";","发生","语义上","冲突","分配","但是","1","pi","」","的","如","读者","需要","无法",".","简单","再","类型","发生冲突","(","也","const","使用","。","immutable","声明","我们","变量","[","关心","对于","=","不是","「","引用","值","concat","，","/","突变","不","42","和","3","只","始终","magicnums","从","]","error","3.141592653","语义","保证","提示","很","这个",")","这","缺点","数据"," ","依旧","注意","fper","可以","首先","4","其次","一些","而",",","是"],"title":"Intent","title_tokens":["intent"]},{"location":"javascript/fp/value-immutable/#freezing","text":"有一种简单的方式让对象、数组、函数变成一个 \"immutable value\" let x = Object . freeze ([ 2 ]); freeze 遍历对象与数组的所有属性和索引，将它们变为已读和「不可被重新配置」，所以这些属性不能被「再分配」。 同时，freeze 将对象标记成不可拓展，也就是无法添加新属性。 但是要注意的是，freeze 不可变的层级只有一层。也就是「shadow immutable」。 如果想要深度 immutable，那么需要递归遍历对象。 let x = Object . freeze ([ 2 , 3 , [ 4 , 5 ]]); // not allowed: x [ 0 ] = 42 ; // oops, still allowed: x [ 2 ][ 0 ] = 42 ; 与 const 不同的是，const 让你误以为这个值不可变，而 freeze 才真正做到了这点。 let arr = Object . freeze ([ 1 , 2 , 3 ]); foo ( arr ); console . log ( arr [ 0 ] ); // 1","text_tokens":["2","arr","所以","与","深度",";","已读","所有",":","foo","那么","不可","成","分配","不同","但是","这点","1","」","still","它们","做到","的","oops","log","误以为","才","变成","对象","同时","重新","需要","无法","5",".","let","添加","简单","再","重新配置","object","递归","不能","、","(","也","const","。","想要","immutable","以为","[","层级","=","让","shadow","「","值","，","/","遍历","就是","这些","函数","拓展","一种","一个","42","0","freeze","方式","value","allowed","和","x","3","如果","]","标记","配置","一层","数组","你","真正","了","这个",")","被","属性"," ","\"","注意","not","有","将","索引","新","要","4","而","console",",","变为","是","变","只有"],"title":"Freezing","title_tokens":["freezing"]},{"location":"javascript/fp/value-immutable/#_2","text":"当我们每次都新创建一个值而不是「突变」一个存在的值，下一个要关注的点就是性能问题。 是否可以考虑一种特殊的数组结构，存储每一次「增量修改」。 仅记录与上一个版本的差异，而不是整个原始数据结构的重复。 let state = specialArray ( 4 , 6 , 1 , 1 ); let newState = state . set ( 4 , 2 ); // 在位置 4 上插入 2 state === newState ; // false state . get ( 2 ); // 1 state . get ( 4 ); // undefined newState . get ( 2 ); // 1 newState . get ( 4 ); // 2 newState . slice ( 2 , 5 ); // [1,1,2] specialArray 用 diff 的方式跟踪每个「突变」，且 state 和 newState 指向数值的不同版本。 immutable.js 提供了一个实现 let state = Immutable . List . of ( 4 , 6 , 1 , 1 ); let newState = state . set ( 4 , 2 ); state === newState ; // false state . get ( 2 ); // 1 state . get ( 4 ); // undefined newState . get ( 2 ); // 1 newState . get ( 4 ); // 2 newState . toArray (). slice ( 2 , 5 ); // [1,1,2] immutable.js 采用了复杂的性能优化实现。自己实现太麻烦了~","text_tokens":["2","与","of","创建",";","用","重复","false","修改","结构","太","整个","不同","记录","原始","且","1","跟踪","」","list","增量","的","优化","存储","特殊","newstate","5","set","在",".","let","插入","slice","js","(","specialarray","指向","。","仅","immutable","toarray","性能","get","自己","提供","每","我们","[","diff","新创建","=","undefined","实现","不是","考虑","麻烦","「","值","~","，","/","差异","突变","版本","就是","当","一种","一个","关注","点","state","方式","问题","都","位置","和","复杂","]","数值","新创","是否","存在","数组","每个","采用","一次","了",")","上"," ","数据","下","可以","要","4","每次","而",",","6","原始数据"],"title":"性能","title_tokens":["性能"]},{"location":"javascript/fp/value-immutable/#treatment","text":"不管函数接收到一个值是可变的还是不可变的，我们都把它当做 immutable 对待。","text_tokens":["它","不管","接收","可变","值","到","，","对待","不可","函数","把","一个","还是","。"," ","当做","immutable","的","都","是","我们","变"],"title":"Treatment","title_tokens":["treatment"]},{"location":"javascript/fp/value-immutable/#_3","text":"immutable 并不意味着一个变量是不变的。immutable 在状态变更时创建和跟踪一个新的值，而不是对现有的值「突变」。 const 其实与 immutable 无关，而 Object.freeze() 提供了一个很好地方法来保证 immutable。 如果遇见性能瓶颈，可以使用第三方库的不可变数据结构。","text_tokens":["意味","与","创建","在","不是","状态",".","「","保证","值","三方","object","来","不变","，","很","方法","第三","结构","不可","突变","(","了","并","库",")","不","地","const","对","现有","一个","使用","。","遇见","数据"," ","跟踪","」","无关","瓶颈","第三方","immutable","freeze","数据结构","其实","时","性能","可以","新","意味着","的","变更","而","提供","和","是","变量","变","如果","好"],"title":"总结","title_tokens":["总结"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["2","arr","明显","近年来","编程","length",";","必须","所有","会","独立","取得","<","一下","什么","成本","细节","可维护性","1","数据流","」","熟练掌握","的","意味着","读者","m","才","变成","时候","干","意味","更","不由","技术","迫不得已","在","应该",".","let","深入","更易","掌握","(","代码","也","潜意识","。","命令","命令式","更少","知道","声明","转变","增加","去","每","阅读","我们","[","过度","可读","关心","自主","{","=","近年","维护性","熟练","可读性","总是","协同","对比","让","一步","「","for","举个","来","，","/","了然","好处","并","多人","函数","不","模式","对","map","一个","不得已","0","意识","bug","平衡","下面","不由自主","和","式","3","都","...","结果","中","一目了然","看出","一目","从","天然","]","i","++","不得","带来","开发","年来","转变成","}","栗子","人","¶","了",")","强","事情","得","数据"," ","因为","循环","要求","技术细节","可以","4","而",",",">","维护","发现","是","主流","化"],"title":"Why FP","title_tokens":[" ","why","fp"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["2","arr","明显","length",";","会","<","一下","什么","细节","可维护性","1","的","m","时候","干","不由","迫不得已","在",".","let","深入","更易","(","代码","也","潜意识","。","更少","知道","去","每","阅读","我们","[","可读","自主","{","=","维护性","可读性","对比","一步","for","举个","来","，","/","了然","map","不得已","0","意识","bug","下面","不由自主","3","...","一目了然","看出","一目","天然","]","i","++","不得","}","栗子","了",")","强"," ","因为","循环","可以","4",",",">","维护","发现"],"title":"函数式编程带来的好处","title_tokens":["函数","的","式","编程","带来","好处"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["结果","更","技术","总是","让","「","过度","人","代码","细节","。","命令","数据流","数据"," ","」","命令式","技术细节","声明","而","的","和","式","读者","关心"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["&","声明","转变","=","的","命令","式"," ","命令式","gt",";"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["意味","我们","关心","熟练","应该","编程","必须","所有","开发","掌握","取得","并","代码","函数","不","成本","一个","事情","得","。"," ","平衡","熟练掌握","意味着","的","去","都","和","式","维护","是","化","才"],"title":"代码中的平衡","title_tokens":["的","代码","平衡","中"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"skills/introduction/","text":"简介 ¶","text_tokens":[" ","¶","简介"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"skills/introduction/#_1","text":"","text_tokens":[],"title":"简介","title_tokens":["简介"]},{"location":"skills/git/git-cz/","text":"why git cz ¶ 给 git commit 添加一段简短有意义且规范的描述 组成 ¶ 一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中 type ¶ feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变 scope ¶ 说明本次代码影响的范围（文件、文件夹） subject ¶ 简短描述 body ¶ 当代码需要一些说明时 foot ¶ 可以用来跟踪 issue 的 ID ，如 Close #123 方便的库 ¶ npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["npm","空格","body","json","path","文件",":","就","工具","修改","<","组成","issue","说明","config","其中","且","件夹","g","然后","跟踪","影响","时","项目","的","提高","如","subject","全局","测试","几个","需要","test","本次","包括","构建","应该","在",".","添加","perf","exact","给","运行","功能","commitizen","、","(","改变","代码","也","安装","scope","去掉","。","why","git","用来","性能","id","footer","过程","close","目录","chore","package","docs","refactor","文件夹","{","conventional","blank","save","没有","换行","来","，","方便","并","描述","cz","当","库","scripts","修复","type","或者","style","一个","文档","123","范围","bug","）","（","-","下面","意义","init","中","部分","i","run","commit","foot","}","标准","¶","提交","通过","简短","了",")","line","fix"," ","\"","changelog","有","规范","#","可以","新","一些","feat",">","一段","只有"],"title":"git-cz","title_tokens":["-","cz","git"]},{"location":"skills/git/git-cz/#why-git-cz","text":"给 git commit 添加一段简短有意义且规范的描述","text_tokens":["给","有","规范","描述","意义","的","且","commit","简短"," ","一段","git","添加"],"title":"why git cz","title_tokens":[" ","git","why","cz"]},{"location":"skills/git/git-cz/#_1","text":"一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中","text_tokens":["几个","部分","body","blank","commit","包括","应该",":","标准","<","(",")","其中","line","type","scope","一个"," ","footer","的","下面",">","subject"],"title":"组成","title_tokens":["组成"]},{"location":"skills/git/git-cz/#type","text":"feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变","text_tokens":["测试","空格","docs","refactor","test","构建","perf","添加","没有","换行","功能","提交","，","工具","修改","(","改变","并","代码","也",")","修复","或者","style","fix","文档","去掉"," ","bug","影响","性能","新","feat","的","提高","过程","chore","意义","只有"],"title":"type","title_tokens":["type"]},{"location":"skills/git/git-cz/#scope","text":"说明本次代码影响的范围（文件、文件夹）","text_tokens":["代码","说明","影响","文件夹","本次","（","的","件夹","文件","范围","）","、"],"title":"scope","title_tokens":["scope"]},{"location":"skills/git/git-cz/#subject","text":"简短描述","text_tokens":["描述","简短"],"title":"subject","title_tokens":["subject"]},{"location":"skills/git/git-cz/#body","text":"当代码需要一些说明时","text_tokens":["代码","说明","当","时","需要","一些"],"title":"body","title_tokens":["body"]},{"location":"skills/git/git-cz/#foot","text":"可以用来跟踪 issue 的 ID ，如 Close #123","text_tokens":["id"," ","#","可以","的","如","close","，","123","跟踪","issue","用来"],"title":"foot","title_tokens":["foot"]},{"location":"skills/git/git-cz/#_2","text":"npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["npm","中","{","i","conventional","json","run","path","commit","在","save",".","exact","添加","运行",":","}","来","就","通过","commitizen","了","安装","cz","config","scripts","g","然后","。"," ","\"","git","changelog","项目","可以","package","-","目录","全局","init"],"title":"方便的库","title_tokens":["的","方便","库"]}]}