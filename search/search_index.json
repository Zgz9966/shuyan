{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["旅行","当然","中","也","了","以下","deploy","buttons",".","参见","试图","浏览","较","编程语言","梳理","indigo","部分","旧","github","practice","api","可以","的","基础知识","可能","green","typescript","缺失","色块",",","建议","两点","着力","前端","不仅","待","what","完善","mkdocs","时","点击","button","accent","比","提升","上述","掌握","document","坚持下去","white","看到","直接","帮助","在于","搜索","主要","其次","此外","成为","经常","地"," ","会","更新","io","md","判断","采用","click","至少","'","理解","善用","google","网上","并","技术","pink","purple","array","鉴于","基本","addeventlistener","语法","你","blue","未来","默认","queryselectorall","刷题","整理","setitem","关于","都","可","做","正在","不断更新","涉及","内容","无前","https","实践","要","¶","坚持","领域","自己","projects","目前","s","并且","编程","深入","css","巩固","来到","，","一往无前","color","data","想","来","blog","阅读","与","不是","orange","首先","不会","主色","比如","列出","更换","}","而","知识","?","{","can","系统","相关","you","好奇","lime","多","(","学习","失效","什么","brown",")","写","新","localstorage","函数","]","在","事项","仅仅","colors","amber","不仅仅","to","较为","永远","将","一往","包含","经历","分支","palette","算法","提问","gh","是","function","管用","body","渴望","chancezyw","保持","red","资料","this","智慧",":","和","teal","一些","dataset","light","其","详细","学识","颜色","primary","=","回顾","how","限于","主题","局限于","\"","核心","风景","更好","deep","以下内容","总是","var","foreach","call","基础","面对","一个","pages","一门","随时","cyan","：","式","下去","调用","prototype","-","局限","[","javascript","因此","语言","grey","mdcoloraccent","专注","辅助","？","见闻","请","对","yellow","mdcolorprimary","。","（","部署","通过","全面","以及","shuyan","欢迎","）","入口","师","/","我","material","build",";","不断","read","色","将会","提交","到","栈"],"title":"Getting Started","title_tokens":[" ","getting","started"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["当然","中","也","了","以下","参见","试图","较","梳理","部分","旧","api","的","基础知识","可能","typescript","缺失","两点","着力","前端","不仅","待","完善","时","上述","看到","在于","主要","此外","成为","经常"," ","会","更新","判断","'","理解","并","技术","鉴于","未来","整理","关于","做","正在","不断更新","涉及","内容","无前","领域","自己","projects","目前","s","并且","编程","深入","css","来到","，","一往无前","想","blog","不是","不会","列出","而","知识","系统","相关","多","失效","写","新","函数","在","事项","仅仅","不仅仅","较为","永远","一往","包含","经历","算法","是","chancezyw","保持","和","详细","回顾","限于","局限于","核心","风景","以下内容","总是","基础","面对","一个","随时","式","调用","局限","javascript","因此","专注","请","。","（","全面","以及","shuyan","欢迎","）","入口","师","我","不断","将会","栈"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["deploy",".","github","pages","可以","在","-","https","将","mkdocs","分支","目前","gh","。","部署","直接","chancezyw","shuyan","blog","/"," ",":","io","提交","采用","到","其"],"title":"How to build？","title_tokens":["how","？"," ","build","to"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["学识","网上","浏览","学习","基本","语法","刷题","可以","的","自己","。","通过","巩固","，","来","其次","资料"," ","首先","一些"],"title":"How to practice？","title_tokens":["practice","how","？"," ","to"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["至少","旅行","善用","google","好奇","并","技术","更好","编程语言","什么","你","可以","的","一门","：","下去","都","建议","实践","要","javascript","坚持","语言","自己","比","见闻","提升","对","提问","掌握","编程","坚持下去","管用","帮助","，","渴望","搜索","保持","阅读","与","地","我","智慧"," ","比如","一些"],"title":"What can you read?","title_tokens":["what","you"," ","read","?","can"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["color","颜色","material","palette","主题"," ","更换"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["=","primary","buttons","主题",".","lime","pink","purple","(","deep","indigo","brown","\"","var","array","blue","foreach","call",")","默认","queryselectorall","的","addeventlistener","green","cyan","localstorage","setitem","}","prototype","]","可","色块",",","amber","-","[","grey","button","点击","yellow","mdcolorprimary","document","white","function","data","body","color","red","this","orange"," ","主色",";","md","teal","更换","dataset","light","{","click"],"title":"Primary colors 主色","title_tokens":[" ","primary","主色","colors"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["=","buttons","主题",".","lime","pink","purple","(","deep","indigo","\"","array","var","foreach","blue","call",")","默认","queryselectorall","的","addeventlistener","green","cyan","localstorage","setitem","}","prototype","]","色块",",","amber","-","[","mdcoloraccent","辅助","button","accent","点击","yellow","document","function","data","body","color","red","this","orange"," ",";","md","teal","色","更换","dataset","light","{","click"],"title":"Accent colors 辅助色","title_tokens":["辅助","accent"," ","色","colors"]},{"location":"introduction/markdown-norm/","text":"采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["sure","中","根据","after","可以","fenced","flavored","建议","单词","mkdocs","时","barbar","looks","为准","搜索","”","简单","md","indent","google","*","console","标题","处理","仅","行末","good","“","其內容","内容","排版","包括","之间","your","标识符","例子","danger","显示","插件","1","abstract","其他","强调","相关","无需","(","多","至多",")","嵌套","标记","以","且","bug","b","first","小写","删除","注明","for","开始","合理","遇到","a","双引号","一级","seo","公式","体验","编码","不必要","规范","清理","原因","使用","/","重复使用","wrapped","wiki","代码","tip","也","warning","必要","多种","github","目录","update","序列表","readme","两个","很","example","pygments","提升","配置","当","会","编写","样式","采用","nested","|","+","搜索引擎","词","数字","间","​","参考","，","而","用","完整","需要","引号","个","list","foo","中英","中文","表达","to","将","it","当前","git","说法","高亮","文件名","省略号","indenting","nice","text","」","be","符号","中文标点","格式","语言","second","。","again","以便",";","自动","无","整句",".","参见","从","的","索引","非","块","更","肯定","表格","8","居中","大小写","指南","标识","引用"," ","有","专有名词","#","缩进","连","numbered","单位","语句","quote","¶","分隔","陈述","行间","章节","全角","与","success","空格","酌情","4","spaces","页面","空行","!","作为","在","下划线","baz","block","and","team","right","是","啰嗦","没有","…","aligned","status","标点符号","看做","question","2","名词","不必","「","文档","中英文","避免","请","markdown","之后","）","cell","提交","两","增加","3","content","特殊","the","划线","为","部分","admonition","适用","note","diff","要求",",","列表","有序","不","口语","行内","$","文件","t","引擎","专有","'","结构","、","bar","代替","c","left","口语化","log","bullet","ide","英文","ctf","尽量","阅读","?","换行","反","后","info","标点","space","js","大小","重复","foofoo","省略","`","center","有名","段落","header","件夹","正文","文字","正确","后缀","语态","下划","utf","添加",":","和","=","直角","##","主题","\"","字符","加","一个","前后","-","bad","failure","主动","文件夹","（","序列","of","只","陈述句","don","半角"],"title":"Markdown Norm","title_tokens":["markdown","norm"," "]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["google",".","搜索引擎","、","划线","为","字符","看做","文档","处理","一个","的","索引","非","连","建议","下划线","-","单词","seo","分隔","将","两个","之间","件夹","8","编码","是","。","文件夹","小写","文件名","，","后缀","原因","参考","搜索","下划","使用","指南","utf","文件"," ","会","md","而","引擎"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["空格","##","开始","中","后","页面","标题","至多","根据","文档","#","从","一个","1","仅","的","目录","空行","good","一级","要求","作为","在","且","间","bad","mkdocs","时","当前","正文","章节","，","配置","之后","当","没有","与","添加","/"," ","采用","有"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["空格","abstract","酌情","中","强调","两","tip","需要","主题","info","、","warning","question","词","不必","部分","必要","admonition","多种","适用","note","一个","行末","的","空行","肯定","在","口语化","内容","ide","表达","避免","语句","quote","段落","陈述","bug","example","时","failure","不","主动","口语","说法","不必要","啰嗦","清理","，","语态","尽量","使用","只","陈述句","删除","danger"," ","会","success","样式","自动","插件","提交","有","换行"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["barbar","foofoo","foo","."," ","bar","1","baz"],"title":"有序列表无需编码","title_tokens":["列表","无需","编码","有","序列","序列表"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["'","空格","indent","nice","4","*","也","结构","后","spaces","无需",".","3","the","个","text","2","list","bar","space","after","缩进","a","嵌套","可以","foo","标记","在","numbered",",","作为","bullet","baz","列表","有序","indenting","and","很","时","looks","it","8","。","，","of","标识符","尽量","使用","当","没有","标识","wrapped","again","don","简单"," ","和","t","1","for","?","nested"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[".","(","\"","参见","console",")","文档","js","块","`","fenced","log","block","语言","​","pygments","高亮","，","使用","以便","注明"," ",";","代码"],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["sure","引号",".","be","`","update","!","且","to","readme","时","your","行内","，","使用","当","引用","文件"," ","代码","md","反"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["|","content","github","left","diff","flavored","以","-","格式","center","second","header","git","right","。","为准","first","markdown","cell"," ",":","aligned","status"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["空格","其他","增加","需要","标点","字符","加","中英","中文","单位","中英文","数字","英文","包括","之间","不","行内","（","全角","与","）"," ","代码"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["直角","标点符号","引号","标点","」","「","代替","重复","的","双引号","符号","省略","“","不","规范","省略号","”","使用","重复使用"," ","…","用"],"title":"标点符号","title_tokens":["标点符号","标点","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["完整","标点","遇到","整句","特殊","、","字符","名词","的","中文","其內容","中文标点","数字","英文","，","全角","使用"," ","半角"],"title":"全角与半角","title_tokens":["与","半角","全角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有","使用","大小","的","大小写","小写","名词","正确","专有名词","有名"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["=","无","合理","+","c","a","可以","的","前后","公式","体验","b","提升","行内","行间","文字","居中","。","，","尽量","使用","阅读","$"," ","显示","和"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["例子","排版","指南","相关","请"," ","中文","更","多","和","。","内容","参考"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["奇淫","敏捷","精通","技巧","icss",".","学习","基础","在线","js","的","days","梁少峰","¶","优质","30","书单","开发","blog","个人"," ","rx"],"title":"Learning Resources","title_tokens":[" ","learning","resources"]},{"location":"introduction/resources/#_1","text":"js 基础学习","text_tokens":[" ","学习","基础","js"],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["奇淫","blog","js","的","days","精通","技巧","icss"," ","梁少峰","个人",".","rx","30"],"title":"优质 blog","title_tokens":["优质"," ","blog"]},{"location":"introduction/resources/#_2","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["今天","不用","明白","中","也","了","症","死亡",".","这些","听","聪明","内","先","衰弱","段时间","e","不管","大脑神经","根据","网络","习惯","起来","可以","的","方案","问题","同时","库存","有助于","形成","白话","时候","执行","知道","拖延","长此以往","才能","解决方案","最大化","更","天才","意味","反馈","睡眠","很","再","不","最","重要","掌握","睡前","法","然而","关联","东西","向","神经网","集中","在于","某些","控制","认为","routine","压缩包","法则","精确","而已"," ","会","运动","思考","打包","高强","信息","去","结合","克服","至少","刚","批判","有利于","信号","方向","办法","结构","技巧","并","制定","最终","整个","工作","闭上眼","加强","你","信念","小而","马云","分解","我们","难免","怎样","推断","间隔","最大","多","这","就是说","即时","智商","发展","有利","都","企业","僵尸","那么","做","老旧","一遍","人","要","大脑","看法","产生","¶","比喻","他","有限","自己","belief","以后","reward","已有","能","聚合","并且","，","成","25","下","意识","穿衣","一点","不是","性价比","忘记","比如","能够","而","知识","用","所以","每天","讲","成大","需要","强度","做事","助于","就是","学习","什么","最好","分解成","消灭","生长","生成","解决","多用","反复","快","数据","精力","普通人","速度","记忆","新","良好","通人","重复","微","神经元","然后","就","在","普通","养成","接受","抽象","g","完","栗子","将","神经","分钟","世界","时间","眼中","为始","是","利于","穿衣服","即使","固化","如何","脑细胞","组块","神经网络","而是","老","以终","大","保持","结果","没有","删除","思维","压缩","练习","一样","从而","上","细胞","难","掉","和","一些","大化","穿","回忆","这个","回顾","开始","类比","一段时间","合理","危险","变","乏味","新陈代谢","高强度","核心","海马","任务","分析","举个","」","物流","「","意味着","特定","这样","番茄","记住","隔离","体","放松","让","目的","所有","只是","单一","衣服","cue","因此","学","做出","也就是说","专注","复习","惯性","？","小","突触","十遍","周末","代谢","对","方式","。","通过","得到","大白话","脑神经","一段","上眼","之前","模式","以往","之后","行为","有助","给予","只","如果","大白","复杂","奖励","接到","这是","给","别人","集中精力","多少","明天","试着"],"title":"Study&Thought","title_tokens":["&","study","thought"]},{"location":"introduction/study-thought/#_1","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["方向","」","生成","「","大脑神经","特定","网络","可以","的","新","记住","记忆","发展","放松","时候","让","在","长此以往","老旧","一遍","大脑","因此","神经","复习","突触","重要","睡前","方式","通过","并且","向","脑神经","，","某些","以往","控制","删除"," ","会","能够","信息"],"title":"大脑结构","title_tokens":["结构","大脑"]},{"location":"introduction/study-thought/#_2","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["有利于","了","变","新陈代谢","助于","就是","海马","聪明","生长","加强","你","就是说","的","新","良好","有助于","体","有利","神经元","大脑","睡眠","产生","也就是说","神经","突触","代谢","能","利于","。","脑细胞","，","有助","细胞"," "],"title":"良好睡眠","title_tokens":["睡眠","良好"]},{"location":"introduction/study-thought/#_3","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["信号","做事","你","信念","这样","的","在","养成","cue","做出","惯性","belief","reward","，","之前","之后","行为","结果","routine"," ","接到"],"title":"僵尸意识","title_tokens":["意识","僵尸"]},{"location":"introduction/study-thought/#_4","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["回忆","这个","中","需要",".","学习","整个","什么","」","你","「","一些","e","起来","的","执行","都","知道","就","在","所有","g","衣服","要","将","以后","不","重要","是","方式","。","关联","穿衣服","能","组块","东西","如何","，","集中","成","模式","下","穿衣","思维","压缩","压缩包","一样"," ","比如","打包","信息","穿"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_5","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["这个","也","了","办法","成大","核心","最终","学习","就是","分解成","解决","你","反复","分解","我们","意味着","普通人","速度","最大","这","方案","同时","的","通人","问题","智商","知道","让","就","普通","接受","解决方案","那么","只是","才能","天才","人","要","意味","因此","最大化","将","专注","有限","再","世界","小","掌握","聚合","。","东西","，","大","保持","没有","上","练习","从而"," ","性价比","大化","知识"],"title":"怎样形成组块","title_tokens":["形成","怎样","组块"]},{"location":"introduction/study-thought/#_6","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["集中","精力","克服","25","给予","自己","分钟","症","的","办法"," ","奖励","然后","这是","拖延","最好","集中精力","，"],"title":"番茄工作法","title_tokens":["工作","番茄","法"]},{"location":"introduction/study-thought/#_7","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["也","一段时间","强度","技巧","并","这些","高强度","工作","学习","内","加强","段时间","生成","反复","大脑神经","网络","番茄","起来","的","记忆","重复","新","放松","抽象","然后","让","在","大脑","神经","很","时间","不","突触","十遍","掌握","重要","是","即使","能","法","固化","东西","神经网络","，","神经网","在于","一段","脑神经"," ","忘记","和","一些","高强","能够","结合"],"title":"间隔重复法则","title_tokens":["重复","间隔","法则"]},{"location":"introduction/study-thought/#_8","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["回顾","可以","的","重复","试着","乏味","上眼","让","闭上眼","。","你","单一","人","难免","，"],"title":"在重复中回顾","title_tokens":["重复","回顾","在","中"]},{"location":"introduction/study-thought/#_9","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["信号","习惯","的","隔离","危险","微"," ","奖励","养成"],"title":"克服拖延症","title_tokens":["克服","症","拖延"]},{"location":"introduction/study-thought/#_10","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["今天","刚","开始","每天","制定","任务","先","小而","的","时候","完","做","不","周末","最","而是","只","精确","复杂","难","不是"," ","明天"],"title":"如何制定任务","title_tokens":["制定","如何","任务"]},{"location":"introduction/study-thought/#_11","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["所以","至少","不用","开始","每天","死亡","衰弱","不管","的","都","神经元","就","在","人","大脑","学","产生","神经","，","老","如果","一点","会","掉","多少","而"],"title":"合理运动和学习","title_tokens":["和","合理","运动","学习"]},{"location":"introduction/study-thought/#_12","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_13","text":"类比和比喻有利于大脑形成组块","text_tokens":["比喻","类比","有利于","形成","有利","和","利于","组块","大脑"],"title":"多用类比和比喻","title_tokens":["和","多用","类比","比喻"]},{"location":"introduction/study-thought/#_14","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["消灭","举个","快","物流","马云","我们","库存","的","更","目的","企业","在","只是","栗子","看法","他","眼中","对","。","是","然而","，","认为","而已"],"title":"以终为始的思维","title_tokens":["的","以终","为始","思维"]},{"location":"introduction/study-thought/#_15","text":"根据已有的数据去分析去推断","text_tokens":["的","已有","分析","数据","去","推断","根据"],"title":"批判思维","title_tokens":["批判","思维"]},{"location":"introduction/study-thought/#_16","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["大白","你","明白","的","白话","会","，","更","给","别人","得到","听","多","讲","大白话","东西","用","学"],"title":"即时反馈","title_tokens":["反馈","即时"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":["addition","concept"," "]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["¶","下文","上下文"," ","上下","执行"],"title":"Execute Context","title_tokens":[" ","context","execute"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["下文","执行","上下文","上下"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["中","hello","可以","error","同时","传递","时候","最","很多","传递函数","某些","nextcurry","信息","并","object","partialright","console","return","http","过瘾","则","脑子","如下","提高","实现","15","nowobjprops","看起","s","开发","基于","1","功能","其他","无法","(","事实",")","prevparam","高级","然后","栗子","uncurry","b","如何","function","formatfn","一起","for","参数传递","touppercase","取消","注意","不太","curry","返回","loosecurry","调用","反向","[","来看","人们","数传","else","使用","/","代码","bind","也","curryprops","接收","可能","v2","presetargs","两个","all","很","length","重要","spreadargs","帮助","应用","直接","当","会","编写","仍然","|","多余","+","y","这","unary","位置","keys","声明","v","，","下","来","person","}","只有","用","需要","可读","按照","foo","就","绑定","将","传入","但是","它","laterargs","开发者","this","_","这个","5","」","constant","穿透","nan","考虑","单一","为什么","partialprops","解构","promise1","没","上下",";","onresult","只能","当然",".","每次","不能","api","期望","的","更","呢","arg","assign","柯里化","current","事实上","prevargs"," ","有","一元","理解","必须","world","我们","参数","fn","顺序","可","都","可读性","那么","应有","¶","cacheresult","filter","能","聚合","过滤","txt","success","参数信息","4","内部","下面","写","]","在","看起来","fper","是","操作","转换","反转",">","没有","下文","ajax","别的","strict","time","喜欢","举个","2","reverse","「","args","这样","later","9","只不过","gatherargs","let","nextobjprops","避免","因此","上面","？","还有","方法","output","len","拆分","id","presetpropsobj","3","propsobj","the","if","为","user","起来","他们","情况","params",",","now","再","obj","手动","不","场景","向","v1","nextcurried","甚至","更改","split","combinefirsttwo","'","如","技巧","words","不定","bar","你","msg","nextargs","右边","一次","is","做","log","argsarr","要","some","口中","因为","宽松","upper","值","不是","比如","shit","{","长度","nextparam","parseint","一元函数","什么","promise","p2","js","map","函数","数量","identity","ret",":","和","兼容","x","=","partial","\"","reverseargs","看","扰乱","一个","\\","还","但","使得","cache","方式","then","of","花哨","12","不过","reduce","...","偏","只","像","上下文","给","props"],"title":"Manage Function Inputs","title_tokens":[" ","inputs","function","manage"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["中","3",".","the","不能","起来","hello","可以","的","error","传递","更",",","now","arg","all","再","不","帮助","传递函数","某些","甚至"," ","split","'","一元","|","多余","如","words","bar","world","你","console","我们","参数","msg","fn","过瘾","unary","脑子","is","做","log","v","口中","filter","能","看起","s","过滤","，","开发","来","upper","txt","值","success","比如","shit","1","}","只有","{","用","parseint","一元函数","下面","(","promise",")","写","p2","js","map","函数","foo","]","就","看起来","栗子","identity","但是","b","开发者","转换","formatfn",">","别的","for","=","touppercase","这个","time","\"","2","举个","constant","穿透","这样","nan","一个","看","\\","还","但","let","单一","[","避免","来看","？","人们","方式","then","花哨","...","promise1","/","像",";","给","还有","方法","output"],"title":"一元函数","title_tokens":["一元函数","一元","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["x","=","4","5","3","+","无法","(",".","bar","2","你","console","y","fn",")","error","的","他们","考虑","函数","情况","foo","9","时候","]","v2","gatherargs","在","呢","let",",","log","argsarr","反向","[","两个","15","声明","不","？","spreadargs","如何","combinefirsttwo","操作","，","v1","12","某些","下","使用",">","...","reduce","/"," ","会","一起","兼容","更改","1","有"],"title":"参数的解构和聚合","title_tokens":["的","和","聚合","解构","参数"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["当然","中","也","id",".","user","api","同时","的","可以","时候","更",",","presetargs","两个","obj","不","最","场景","很多","直接","应用","current","某些"," ","编写","技巧","并","partialright","你","return","参数","fn","http","这","右边","可","实现","cacheresult","some","因为","，","下","基于","person","}","{","用","功能","需要","(",")","js","函数","]","绑定","fper","但是","laterargs","function","反转",">","下文","this","ajax",":","和","_","partial","=","喜欢","\"","reverseargs","reverse","args","不太","一个","later","let","[","因此","上面","cache","...","偏","只","/","上下","上下文",";","onresult","bind"],"title":"偏函数","title_tokens":["偏","函数"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["nextparam","=","len","需要",".","(","每次","if","必须","不定","return","你","参数","fn",")","一个","curry","prevparam","接收","期望","的","则","考虑","函数","传递","params","只不过","都","然后","一次","调用","如下","let",",","]","[","要","将","传入","上面","很","length","手动","但是","数传","else","是","，","柯里化","不过","下","nextcurry",">","偏","只","像","...","当","不是"," ","和","给","代码","}","参数传递","{","长度"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["扰乱","其他","拆分","的"," ","会","可读","可读性","参数信息","信息","提高","参数"],"title":"为什么使用柯里化和偏函数？","title_tokens":["柯里化","使用","偏","？","为什么","函数","和","什么"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["理解","=","len","内部",".","(","事实","为","if","」","return","「","我们","args","fn",")","这样","nextargs","js","可以","的","loosecurry","]","都",",","let","[","实现","上面","length","else","是","，","柯里化","事实上",">","...","strict","nextcurried","prevargs"," ","}","{"],"title":"更宽松的柯里化","title_tokens":["宽松","更","的","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["=","仍然","中","需要","(","return","你","取消","注意","参数","args","fn",")","一个","的","返回","函数","let","arg","应有","数量","uncurry","传入","ret","是","向","，","of","柯里化",">","...","当","没有","偏"," ","}","for","{"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["=","len","presetpropsobj","curryprops","下面","propsobj",".","(","每次","object","if","reverse","return","参数","按照","fn",")","顺序","的","可能","考虑","函数","位置","props","都","keys",",","那么","let","nextobjprops","使得","assign","上面","length","不","nowobjprops","它","重要","partialprops","else","开发者","开发","，","柯里化",">","偏","没","nextcurried"," ","和","代码","}","1","只能","{"],"title":"高级实现","title_tokens":["实现","高级"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["或","也","中","明显","这些",".","if","为","部分","关键字","可以","的","一部分","元","可能","不赋","情况","传递","用途","执行","时候","更","知道",",","递归","很","隐含","清楚","不","开发人员","堆栈","todo","是因为","应用","值得","后面","当","引用","能力","地","过于","easy","pain"," ","n","会","更新","含有","有","至少","交易","过程","取出","多个","不传","显式","return","你","y","我们","参数","未来","fn","尽可能","这种","则","空","输入输出","的话","可读性","一次","常规","那么","达式","¶","声明","区别","包括","数学","命名","写法","化","并且","编程","准确","开发","，","本质","因为","意识","当有","值","不是","赋值","把","副作用","}","只有","人员","{","用","字符串","确保","对象","数据流","需要","尽可","跟踪","(","个","可读","学习","什么","最好","数据",")","js","变量","函数","外部","说","抽象","这会","在","前面","参是","作用","表达","文章","临时","bug","包含","映射","变得","name","但是","一定","它","是","如何","返回值","function","coding","表达式","没有",">","上","一部","和","造成","惰性","x","=","这个","喜欢","或是","到底","最后","字符","加上","」","「","变差","名","关键","片段","一个","输入","curry","返回","或者","修改","入","面向","式","让","调用","闭包","let","清晰","调试","稳定","when","存储","用来","更加","多次","自","？","输出","else","叫做","解构","通过","发人","。","不同","一段","原因","如果","定义","使用","偏","只","/","read","代码","给","角度","到","匿名"],"title":"Nature Function","title_tokens":[" ","nature","function"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["函数","什么","是"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["关键","片段","多次","使用","声明","关键字","可以","的","或者"," ","这些","执行","，","代码","一次","function","一段"],"title":"常规定义","title_tokens":["定义","常规"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["或","也","多个","个","」","我们","「","一个","输入","可以","的","输入输出","元","函数","包含","映射","输出","但是","叫做","不同","准确","，","值"," ","n","把","和","含有","有"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["过程","中","输入","的","则","输入输出","可能","函数","面向","式","稳定","输出","不","一定","编程","，","没有"," ","有"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["过程","区别","的","函数","面向","式","和","」","编程","「"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["中","js","的","能力","函数"," "]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["中","明显","if","部分","不赋","可以","的","一部分","传递","时候","更",",","隐含","不","开发人员","当"," ","有","至少","取出","多个","不传","显式","return","y","我们","参数","fn","这种","则","空","输入输出","可读性","包括","命名","写法","并且","开发","，","因为","当有","赋值","副作用","}","只有","人员","{","用","对象","数据流","需要","(","可读","最好","数据",")","变量","函数","外部","这会","作用","临时","它","返回值",">","一部","和","造成","x","=","喜欢","最后","变差","一个","输入","返回","修改","让","let","清晰","存储","更加","输出","else","解构","发人","如果","使用","/","代码"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["应用","curry","偏","上","函数"," ","和","到"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["交易","这个","确保","需要","或是","尽可","跟踪",".","为","字符","加上","你","名","尽可能","fn","未来","一个","可以","的","入","可能","返回","函数","情况","的话","空","时候","知道","调用","用途","在","抽象","调试","参是","前面",",","when","用来","bug","递归","自","很","name","命名","不","清楚","堆栈","是","如何","todo","因为","，","是因为","原因","如果","值得","coding","只","引用","过于","pain","easy"," ","会","更新","read","给","字符串","匿名"],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["后面","的","会","说","。","到","文章"],"title":"惰性表达式","title_tokens":["表达式","达式","惰性","表达"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["独立","潜意识","熟练","应该","也","中","了","增加","近年来","3",".","天然","明显","转变","得","一目","自主","从","可以","的","一步","时候","知道","更","要求",",","一下","意味","一目了然","length","变成","不","掌握","年来","技术细节","平衡"," ","会","才","去","干","并","技术","必须","我们","成本","了然","可读性","都","发现","人","命令式","arr","¶","更少","声明","近年","化","主流","深入","编程","每","开发","，","因为","对比","来","阅读","循环","意识","看出","}","1","而","{","不得","4","下面","数据流","事情","(","可读","命令","什么","过度","数据","熟练掌握","细节","带来",")","map","函数","]","在","取得","栗子","bug","多人","0","是","不得已","强",">","结果","协同","维护","和","for","=","m","维护性","举个","2","总是","i","」","「","意味着","迫不得已","转变成","不由自主","不由","一个","式","让","所有","let","[","读者","<","更易","++","对","。","模式","...","/","好处",";","代码","可维护性","关心"],"title":"Why FP","title_tokens":[" ","why","fp"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["潜意识","也","了","3",".","天然","明显","一目","自主","可以","的","一步","时候","知道",",","一下","一目了然","length"," ","会","去","干","我们","了然","可读性","发现","arr","更少","深入","每","因为","，","对比","来","阅读","循环","意识","看出","}","1","{","不得","4","下面","(","可读","什么","细节",")","map","]","在","栗子","bug","0","不得已","强",">","维护","for","=","m","维护性","举个","2","i","迫不得已","不由自主","不由","let","[","<","更易","++","。","...","/",";","代码","可维护性"],"title":"函数式编程带来的好处","title_tokens":["带来","的","好处","函数","式","编程"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["数据流","技术","命令","总是","」","过度","数据","「","细节","的","式","让","更","人","命令式","读者","声明","。","结果","技术细节"," ","代码","和","关心","而"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["=","声明","gt","的"," ","&",";","命令","式","转变","命令式"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["熟练","应该","并","事情","得","必须","熟练掌握","我们","意味着","一个","成本","的","函数","式","都","所有","取得","意味","不","掌握","化","。","是","编程","开发","平衡"," ","维护","代码","和","关心","才","去"],"title":"代码中的平衡","title_tokens":["平衡","的","代码","中"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":[" ","getting","started"]}]}