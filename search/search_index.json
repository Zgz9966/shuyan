{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ blog 主题 copy 自 CTF-wiki Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["不仅","colors","函数","语法","'","也","管用","你","想","基础","而","更好","material","wiki","document","永远","chancezyw","试图","可以","javascript","对","实践","坚持下去","copy","lime","queryselectorall","api","做","teal","主题","）","css","deep","智慧","更新","学习","shuyan","light","完善","正在","将会","采用","-","一往无前","var","局限",":","orange","比","全面","color","基本","}","不会","部署","]","相关","是","会","data","部分"," ","to","deploy","将","到","通过","ctf","addeventlistener","浏览","请","，","默认","。","(","accent","md","新","不仅仅","帮助","primary","基础知识","着力","brown","总是","一往","关于","buttons","参见","好奇","较","栈","系统","cyan","yellow","array","function","色","深入","较为","技术","并","经常","一些","风景","一门","包含","编程语言","自","回顾","不断更新","写","s","当然","随时","build","阅读","编程","自己","分支","善用",".","巩固","欢迎","与","因此","https","刷题","=","网上","body","见闻","什么","辅助",",","和","pages","缺失","mdcolorprimary","知识","提问","建议","google","（","判断","事项","以及","点击","色块","dataset","师","pink","来","待","不是","typescript","旅行","下去","两点","理解","专注","purple","foreach","地","click","一个","时","[","mdcoloraccent","blog","鉴于","渴望","以下内容","mkdocs","来到","/","io","gh","领域","以下","局限于","grey","列出","入口","经历","can","amber","\"","this","搜索","{","call","算法","多","indigo","更换","blue","提升","button","限于","prototype","主要","you","学识","上述","red","面对","调用","此外","projects","？","比如","仅仅","涉及","并且","的","旧","提交","坚持","都","资料","palette","整理","不断","green","localstorage","：","内容",";","how","直接","¶","what",")","成为","github","核心","中","其","我","至少","前端","无前","可","看到","setitem","保持","颜色","梳理","语言","?","在于","失效","在","要","主色","目前","了","可能","practice","首先","其次","式","white","详细","read","未来","掌握"],"title":"Getting Started","title_tokens":["getting"," ","started"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["不仅","函数","'","也","想","基础","而","永远","chancezyw","试图","javascript","api","做","）","css","更新","shuyan","完善","正在","将会","一往无前","局限","全面","不会","相关","是","会","部分"," ","请","，","。","新","不仅仅","基础知识","着力","总是","一往","关于","参见","较","栈","系统","深入","较为","技术","并","经常","风景","包含","回顾","不断更新","写","s","当然","随时","编程","自己","欢迎","因此","和","缺失","知识","（","判断","事项","以及","师","待","不是","typescript","两点","理解","专注","一个","时","blog","鉴于","以下内容","来到","领域","以下","局限于","列出","入口","经历","算法","多","限于","主要","上述","面对","调用","此外","projects","仅仅","涉及","并且","的","旧","整理","不断","内容","成为","核心","中","我","前端","无前","看到","保持","梳理","在于","失效","在","目前","了","可能","式","详细","未来"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":[" ","deploy","将","到","。","提交","chancezyw","可以","直接","blog","github","其","mkdocs","/","io","gh","shuyan","采用","-","分支",".","在",":","https","目前","部署","pages"],"title":"How to build？","title_tokens":["to"," ","？","how","build"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":[" ","通过","语法","浏览","，","。","的","来","资料","可以","一些","学习","自己","巩固","刷题","首先","其次","网上","基本","学识"],"title":"How to practice？","title_tokens":["to"," ","？","how","practice"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":[" ","提问","google","管用","你","，","比如","的","坚持","更好","都","下去","旅行","帮助","地","：","可以","javascript","对","实践","好奇","渴望","坚持下去","我","至少","一门","并","技术","一些","智慧","保持","搜索","编程语言","语言","阅读","编程","自己","善用","与","要","提升","比","见闻","什么","建议","掌握"],"title":"What can you read?","title_tokens":[" ","can","what","you","read","?"]},{"location":"#material-color-palette","text":"blog 主题 copy 自 CTF-wiki","text_tokens":[" ","主题","ctf","自","blog","copy","wiki","-"],"title":"Material color palette 更换颜色主题","title_tokens":[" ","主题","更换","颜色","color","material","palette"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":[" ","addeventlistener","点击","dataset","色块","默认","的","(","pink","md","document","primary","green","purple","brown","foreach","click","localstorage",";","buttons","[",")","queryselectorall","lime","cyan","array","yellow","function","teal","主题","grey","this","deep","amber","\"","setitem","light","{","call","-","indigo",".","var","更换","blue","主色","orange","button","white","prototype","=","color","body","}","]",",","可","red","data","mdcolorprimary"],"title":"Primary colors 主色","title_tokens":["主色"," ","colors","primary"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":[" ","addeventlistener","点击","dataset","色块","默认","的","(","pink","md","document","accent","green","purple","foreach","click","localstorage",";","buttons","[",")","mdcoloraccent","queryselectorall","lime","色","array","yellow","function","teal","主题","this","deep","amber","\"","setitem","light","{","call","-","indigo",".","var","更换","blue","orange","button","prototype","=","color","body","}","]","辅助",",","cyan","red","data"],"title":"Accent colors 辅助色","title_tokens":[" ","colors","辅助","accent","色"]},{"location":"introduction/markdown-norm/","text":"采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["间","要求","下划","序列表","重复","陈述句","列表","尽量","文件名","正确","行末","b","代码","主题","有序","标点","有名","list","标识符","显示","名词","是","相关","ctf","请","，","作为","md","注明","…","“","半角","引擎","双引号","标识","left","陈述","主动","之间","google","为","清理","其他","note","索引","文档","编码","单词","强调","mkdocs","center","#","单位","无","​","搜索","页面","无需","用","提升","合理","大小","下划线","章节","专有","中英文","example","居中","件夹","分隔",";","之后","abstract","github","嵌套","增加","至多","结构","「","包括","|","反","建议","遇到","啰嗦","team","很","说法","barbar","bug","看做","符号","特殊","）","quote","连","采用","体验","插件","大小写","例子","会","加","it","to"," ","$","(","of","2","8","代替","只","整句","pygments","a","`","开始","success","不必",".","后","从","your","and","需要","个","（","、","处理","小写","参考","tip","数字","省略号","/","indent","非","文件","!","中文标点","配置","good","flavored","缩进","划线","删除","bar","内容","readme","且","中","行内","bad","语言","表格","在","warning","也","其內容","标记","update","second","以便","前后","引用","nested","换行","适用","口语","sure","为准","字符","-","looks","必要","4","语态","部分","空行","引号","for","使用","文字","省略","参见","+","仅","排版","中文","指南","规范","与","indenting","编写","添加","正文","be","t","git","标点符号","the","格式","酌情","两个","序列","danger","spaces","多","text","重复使用","foo","根据","」","英文","numbered","¶","没有","status","foofoo","c","当前","行间","?","question","不","header","again","”","baz","高亮","搜索引擎","'","而","wrapped","wiki","*","全角","专有名词","bullet","可以","content","不必要","当","空格","表达","diff","space","语句","fenced","口语化",":","样式","right","将","一级","。","块","后缀","原因","info","标题","block","目录","阅读","utf","seo","3","=",",","和","有","中英","log","一个","时","cell","ide","first","nice","admonition","markdown","aligned","\"","文件夹","简单","多种","直角","肯定","段落","避免","don","提交","的","以","failure","更","完整","词",")","自动","js","公式","console","两","##","1","after"],"title":"Markdown Norm","title_tokens":[" ","markdown","norm"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["会"," ","将","下划线","google","搜索引擎","为","，","使用","、","下划","的","。","而","md","划线","索引","处理","后缀","文件名","小写","一个","参考","文档","编码","件夹","分隔","引擎","原因","单词","8","看做","两个","文件夹","搜索","连","非","字符","-","指南","之间","utf",".","文件","seo","是","建议"],"title":"文档格式","title_tokens":["文档","格式"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["good"," ","一级","根据","间","有","空行","章节","添加","，","要求","作为","正文","的","文档","一个","时","且","没有","之后","1","中","mkdocs","/","当","当前","#","空格","标题","目录","bad","仅","采用","页面","开始","与","在","至多","后","从","##","配置"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["部分"," ","空行","有","，","清理","使用","提交","的","啰嗦","陈述句","、","删除","failure","note","example","尽量","行末","一个","时","说法","内容","tip","ide","词","bug","只","中","强调","换行","不必要","酌情","自动","admonition","适用","abstract","info","主题","空格","quote","表达","danger","口语","陈述","主动","语句","插件","success","多种","不必","口语化","在","肯定","必要","段落","question","不","样式","避免","需要","两","语态","会","warning"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["."," ","baz","bar","barbar","foofoo","foo","1"],"title":"有序列表无需编码","title_tokens":["序列","编码","有","序列表","列表","无需"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["it"," ","baz","个","'",",","也","for","again","don","，","使用","。","t","缩进","of","作为","列表","wrapped","2","*","标记","很","尽量","numbered","bullet","时","可以","bar","the","8","没有","nested","nice","当","有序","空格","indent","嵌套","标识","a","spaces","list","space","简单","?","标识符","无需",".","looks","在","结构","text","indenting","3","后","and","foo","4","和","1","after"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[" ","高亮","，","使用","(","块","log","注明","文档","以便",";","代码",")","参见","js","pygments","\"","block","​","语言","`","fenced",".","console"],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["to"," ","引号","，","使用","be","md","update","时","readme","代码","且","引用","当","行内","sure","`",".","文件","!","your","反"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":[" ","flavored","。","以","git","second","cell","格式","first","status","github","content","center","markdown","aligned","diff","left","为准","-",":","header","right","|"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":[" ","（","其他","中英","中英文","英文","全角","代码","数字","单位","）","空格","行内","标点","中文","字符","之间","与","增加","不","包括","需要","加"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":[" ","引号","重复","使用","的","」","…","标点符号","省略","“","双引号","代替","符号","省略号","标点","规范","直角","用","不","重复使用","「","”"],"title":"标点符号","title_tokens":["标点","标点符号","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":[" ","遇到","，","使用","、","的","其內容","英文","全角","完整","半角","数字","整句","标点","特殊","中文","字符","名词","中文标点"],"title":"全角与半角","title_tokens":["半角","与","全角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["大小","有名","正确","小写","名词","专有","大小写","使用","的","专有名词"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":[" ","$","，","使用","。","的","文字","居中","尽量","可以","前后","b","+","c","行内","行间","无","a","公式","阅读","体验","提升","合理","显示","=","和"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":[" ","更","参考","内容","指南","请","排版","中文","。","例子","和","多","相关"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["在线"," ","优质","icss","的","基础","30","精通","技巧","奇淫","¶","blog","梁少峰","敏捷","js","学习","rx","个人",".","开发","书单","days"],"title":"Learning Resources","title_tokens":["learning"," ","resources"]},{"location":"introduction/resources/#_1","text":"js 基础学习","text_tokens":["js"," ","基础","学习"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":[".","技巧"," ","js","奇淫","30","rx","icss","的","blog","梁少峰","个人","days","精通"],"title":"优质 blog","title_tokens":[" ","优质","blog"]},{"location":"introduction/resources/#_2","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","concept","addition"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":[" ","上下","上下文","执行","¶","下文"],"title":"Execute Context","title_tokens":[" ","execute","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["上下文","上下","下文","执行"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["12","你","b","代码","举个","值","api","花哨","他们","这样","is","fper","5","reverseargs","是","参数信息","期望","touppercase","，","不能","帮助","接收","一次","hello","无法","柯里化","msg","_","function","fn","并","formatfn","写","s","当然","长度","向","呢","partialprops","可读性","all","nextparam","current","过滤","脑子","多余","为","很多","prevargs","其他","propsobj","技巧","一起","提高","数传","取消","用","看起来","nextobjprops","constant","开发者",";","presetpropsobj","length","按照","let","重要","some","argsarr","高级","props","「","|","偏","map","考虑","函数","穿透","如下","然后","很","仍然","人们","如","http","做","words","反转","不定","可读","parseint","不过","看起","使得","能","...","v","reduce","会"," ","presetargs","(","of","2","只","id","assign","9","注意","传入","success",".","需要","位置","参数传递","params","像","ret","else","/","为什么","cacheresult","事实","单一","再","给","兼容","filter","一元函数","下","bar","直接","中","reverse","combinefirsttwo","onresult","upper","应用","右边","基于","在","world","可能","也","传递","场景","聚合","只能","最","参数","上下文","绑定",">","还有","过瘾","甚至","宽松","那么","nextcurried","}","]","p2","4","上下","这个","for","使用","+","内部","keys","传递函数","return","v2","但是","一元","开发","因此","什么","txt","编写","loosecurry","now","来","更改","理解","nextargs","应有","the","[","来看","identity","两个","反向","this","{","x","只有","cache","不太","foo","手动","arg","then","转换","则","方法","curry","」","如何","实现","栗子","但","别的","喜欢","user","person","¶","没有","promise","要","不","可","error","'","shit","起来","可以","ajax","下面","事实上","当","拆分","就",":","curryprops","spreadargs","顺序","partial","将","同时","它","口中","object","obj","声明","later","time","情况","bind","必须","partialright","每次","unary","prevparam","还","promise1","3","len","=",",","和","这","有","15","if","信息","不是","log","一个","功能","方式","时候","\"","output","nan","uncurry","因为","我们","laterargs","某些","没","避免","gatherargs","args","调用","？","nextcurry","比如","nowobjprops","strict","的","下文","都","更","操作","看",")","解构","js","只不过","\\","split","数量","console","扰乱","y","返回","上面","v1","1"],"title":"Manage Function Inputs","title_tokens":[" ","inputs","function","manage"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["map","函数","'","穿透","你","shit","传递","起来","可以","下面","人们","如","b","举个","值","做","花哨","words","参数",">","这样","还有","过瘾","甚至","parseint","就","is","看起","能","...","v","}","]","p2"," ","这个","touppercase","，","for","口中","(","不能","2","帮助","hello","msg","time","fn","传递函数","formatfn","写","s","unary","success",".","但是","还","一元","all","开发","promise1","3","=",",","txt","过滤","脑子","多余","像","now","来","log","一个","the","[","来看","方式","/","identity","\"","output","{","nan","单一","只有","再","我们","用","给","某些","看起来","避免","foo","arg","？","filter","比如","then","转换","方法","constant","的","一元函数","栗子","但","别的","更","开发者","bar",";","看",")","中","js","let","upper","\\","split","console","promise","world","不","|","error","1"],"title":"一元函数","title_tokens":["一元函数","一元","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["考虑"," ","12","有","函数","兼容","？","15","你","，","使用","的","(","如何","2","log","更改","下","bar","一起","操作","声明","[",")","无法","4","+","/","combinefirsttwo","fn","情况","时候","两个","反向","let","9","他们",">","argsarr","x","v2",".","呢","在","console","y","不","某些","spreadargs","3","...","=","5","]","foo",",","v1","reduce","error","会","gatherargs","1"],"title":"参数的解构和聚合","title_tokens":["聚合","参数","的","解构","和"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["函数","也","你","场景","可以","ajax","最","http","api","上下文","参数","绑定",">","反转",":","...","fper","}","]","partial","reverseargs"," ","上下","同时","，","presetargs","(","obj","later","只","_","id","function","fn","bind","并","return","partialright","当然",".","但是","因此","=","需要",",","和","这","current","编写","很多","技巧","一个","功能","[","/","时候","两个","this","cacheresult","\"","{","因为","cache","用","不太","laterargs","某些","args","的","下文","实现","喜欢","更","下","user","person",";","直接",")","中","reverse","js","onresult","let","some","应用","右边","基于","不","上面","可","偏"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["手动","考虑"," ","调用","将","期望","函数","params","nextcurry","像","，","你","则","如下","curry","if","(","传递","的","然后","都","不是","很","else","接收","一个","下","一次","代码","[",")","柯里化","只","length","fn","当","let","只不过","参数","return",">","必须","不定","{","传入","每次","prevparam","长度","数传",".","但是","要","不过","给","len","=","...","需要","}","]","上面",",","和","参数传递","是","nextparam","偏"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":[" ","可读性","扰乱","参数","可读","其他","拆分","的","信息","参数信息","会","提高"],"title":"为什么使用柯里化和偏函数？","title_tokens":["函数","？","偏","使用","柯里化","什么","和","为什么"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":[" ","为","loosecurry","，","prevargs","if","strict","的","(","」","都","实现","理解","else","可以","nextargs","[",")","柯里化","事实上","内部","length","fn","js","let","事实","return",">","这样","{",".","我们","「","=","len","nextcurried","...","上面","]","}",",","是","args"],"title":"更宽松的柯里化","title_tokens":["的","更","柯里化","宽松"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":[" ","arg","函数","for","，","ret","你","的","(","of","仍然","一个","应有","没有",")","柯里化","中","fn","当","let","参数","return",">","注意","{","传入","uncurry","向","取消","数量","返回","...","=","需要","}","是","args","偏"],"title":"取消柯里化","title_tokens":["取消","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["考虑"," ","函数","，","nextobjprops","nowobjprops","它","if","的","(","都","object","propsobj","else","开发者","只能","下面","代码","presetpropsobj",")","柯里化","位置","length","按照","reverse","assign","keys","fn","let","重要","参数","return",">","{","每次",".","partialprops","开发","curryprops","使得","不","可能","props","顺序","没","那么","=","len","上面","}","nextcurried",",","和","1","偏"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["一段","函数","也","你","开发人员","输出","传递","很","可以","多次","修改","一定","easy","代码","引用","bug","值","不传","跟踪","当","n","参数","参是","表达","更新","学习",">","最后","可读","字符","pain","这些","这种","角度","尽可","过于","那么","数据流","闭包","}","一部","是","会","部分"," ","通过","面向","更加","到","叫做","上","这个","发人","元","临时","，","name","使用","它","。","(","含有","化","常规","一次","表达式","过程","coding","原因","声明","区别","只","名","让","function","fn","情况","调试","交易","包含","return","自","编程","数学","但是","不同",".","返回值","或者","开发","可读性","当有","尽可能","说","赋值","=","惰性","入","需要","什么",",","和","到底","明显","人员","变量","造成","字符串","用来","个","有","输入输出","稳定","取出","为","堆栈","if","todo","文章","能力","不是","变差","写法","地","else","一个","清楚","前面","外部","确保","when","关键","定义","隐含","一部分","/","时候","或","对象","不赋","或是","变得","这会","{","x","只有","因为","显式","我们","用","后面","给","达式","执行","的话","用途","值得","命名","调用","如果","片段","？","最好","则","并且","curry","的","」","数据","如何","递归","抽象","关键字","加上","喜欢","意识","副作用","更","清晰","多个","¶","没有",")","把","中","解构","存储","匿名","输入","js","至少","let","是因为","知道","准确","应用","本质","作用","在","返回","y","不","可能","「","式","空","包括","映射","read","未来","偏"],"title":"Nature Function","title_tokens":[" ","function","nature"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","什么","函数"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["一段"," ","或者","可以","一次","片段","多次","，","执行","代码","使用","声明","的","关键","这些","关键字","function"],"title":"常规定义","title_tokens":["定义","常规"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":[" ","个","叫做","函数","输入输出","有","也","元","，","输出","的","」","含有","一个","可以","多个","把","值","输入","或","n","包含","准确","但是","不同","我们","「","映射","和"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":[" ","面向","函数","有","输入输出","稳定","，","则","输出","的","过程","一定","没有","中","输入","编程","不","可能","式"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["面向","函数","过程","「","式","的","」","区别","和","编程"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["js"," ","函数","能力","的","中"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["函数","开发人员","输出","传递","可以","修改","代码","不传","当","参数",">","最后","可读","这种","数据流","}","一部","部分"," ","更加","发人","临时","，","使用","它","(","让","fn","return","返回值","可读性","开发","当有","赋值","=","需要",",","和","明显","人员","变量","造成","有","输入输出","取出","if","变差","写法","else","一个","外部","隐含","一部分","/","时候","对象","不赋","这会","{","x","只有","因为","显式","我们","用","命名","如果","最好","则","并且","的","数据","喜欢","副作用","更","清晰","多个",")","中","解构","存储","输入","至少","let","作用","返回","y","不","空","包括"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":[" ","到","函数","上","curry","应用","和","偏"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["用来"," ","调用","如果","这个","函数","name","为",",","，","你","堆栈","的","todo","如何","递归","抽象","加上","很","前面","一个","可以","清楚","read","easy","coding","引用","原因","确保","bug","是","when","只","名","匿名","跟踪","fn","情况","时候","调试","参是","交易","是因为","知道","更新","或是","自","字符","pain","因为",".","尽可能","在","返回","给","尽可","可能","不","过于","的话","入","需要","空","用途","值得","命名","会","未来","字符串"],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["到","后面","说","。","的","文章","会"],"title":"惰性表达式","title_tokens":["惰性","表达","达式","表达式"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["map","函数","强","也","要求","而","i","年来","一目了然","可以","熟练掌握","下面","m","每","代码","举个","对","bug","迫不得已","不由自主","主流","过度","独立",">","可读","一目","事情","人","...","数据流","}","]","潜意识","4","会","是"," ","，","for","。","带来","(","2","化","读者","总是","平衡","不得","声明","让","深入","并","技术","变成","必须","天然","阅读","多人","编程","关心",".","意味着","可读性","开发","近年","从","3","更少","=","好处","什么",",","协同","和","明显","循环","了然","去","熟练","模式","来","arr","转变","一个","0","++","一步","意味","[","不得已","/","命令式","时候","才","维护","所有","{","得","自主","因为","近年来","我们","可维护性","的","<","」","数据","都","结果","栗子","意识","更",";","取得","¶","成本",")","中","length","let","知道","干","技术细节","更易","不由","转变成","看出","在","增加","对比","命令","了","不","应该","「","细节","式","维护性","发现","一下","1","掌握"],"title":"Why FP","title_tokens":["why"," ","fp"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["map","强","也","i","一目了然","可以","下面","m","每","代码","举个","bug","迫不得已","不由自主","一下",">","可读","一目","...","}","]","潜意识","4","会"," ","for","，","。","(","2","不得","深入","天然","阅读",".","可读性","3","更少","=","什么",",","明显","循环","了然","去","来","arr","0","++","一步","[","不得已","/","时候","维护","{","自主","因为","我们","可维护性","的","<","栗子","意识",";",")","length","let","知道","干","更易","看出","在","对比","了","细节","维护性","发现","不由","1"],"title":"函数式编程带来的好处","title_tokens":["函数","式","带来","的","好处","编程"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":[" ","。","的","」","而","数据","结果","读者","总是","更","代码","声明","让","命令式","技术","过度","技术细节","关心","人","命令","「","细节","式","数据流","和"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["转变"," ","gt","&","命令",";","=","声明","式","的","命令式"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":[" ","函数","。","的","去","熟练","都","化","熟练掌握","一个","意味","取得","平衡","代码","成本","才","并","维护","所有","必须","得","编程","关心","事情","意味着","我们","开发","不","应该","式","和","是","掌握"],"title":"代码中的平衡","title_tokens":["中","的","平衡","代码"]}]}