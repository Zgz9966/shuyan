{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["document","包含","专注","鉴于","理解","做","更好","blue","将会","]","提问","随时","经历","addeventlistener","式","，","色","当然","yellow","amber","通过","buttons","较","相关","内容","[","涉及","projects","不仅","风景","梳理","read","编程","api","语言","其次","保持","欢迎","缺失",")","善用","中","white","我","想","限于","github","完善","阅读","一门","网上","prototype","目前","坚持","着力","shuyan","算法","上述","颜色","不断","来","直接","至少","正在","总是","red",",","回顾","=","管用","并","列出","此外","都","也","accent","一些","javascript","旅行","去","blog","teal","(","资料","栈","整理","以及","一往无前",":","data","调用","green","试图","基础","google","辅助","帮助","{","css","无前","how","到","?","下去","colors","会","？","this","的","比如","button","事项","不会","地方","¶","入口","因此","pages","light","详细","较为","是","旧","编程语言","参见","比","提交","）",".","可能","好奇","默认","md","局限于","与","cyan","call","关于","时","学识","localstorage","在","智慧","to","自己","mdcoloraccent","两点","不仅仅","主要","并且","你","不断更新","建议","核心","而","mkdocs","。","color","待","practice","'","：","要","点击","chancezyw","主题","深入","一个","见闻","function","可","写","请","deploy","可以","刷题","知识","了","新","brown","色块","对","pink"," ","（","io","提升","将要","素未谋面","在于","/","you","deep","成为","判断","can","谋面","来到","mdcolorprimary","indigo","var","}","不是",";","首先","purple","queryselectorall","setitem","技术","搜索","巩固","仅仅","掌握","将","material","分支","\"","主色","lime","更新","地","palette","build","部分","orange","系统","面对","采用","实践","渴望","gh","基本","局限","其","语法","click","primary","未来","什么","-","grey","经常","失效","领域","typescript","https","前端","多","函数","s","一往","dataset","永远","那些","故乡","以下","全面","和","部署","what","body","array","以下内容","学习","foreach","基础知识","坚持下去","浏览","更换","看到","师"],"title":"Getting Started","title_tokens":["getting","started"," "]},{"location":"#shuyan","text":"那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["包含","专注","鉴于","理解","做","将会","随时","经历","式","，","当然","较","相关","内容","涉及","projects","不仅","风景","梳理","编程","api","保持","欢迎","缺失","中","我","想","限于","完善","目前","着力","shuyan","算法","上述","不断","正在","总是","回顾","并","列出","此外","都","也","javascript","去","blog","栈","整理","以及","一往无前","调用","试图","基础","css","无前","会","的","事项","不会","地方","因此","入口","详细","较为","是","旧","参见","）","可能","局限于","关于","时","在","自己","两点","不仅仅","主要","并且","不断更新","核心","而","。","待","'","chancezyw","深入","一个","写","请","知识","了","新"," ","（","将要","素未谋面","在于","成为","判断","谋面","来到","不是","技术","仅仅","更新","部分","系统","面对","局限","未来","经常","失效","领域","typescript","前端","多","函数","s","一往","永远","那些","故乡","以下","全面","和","以下内容","基础知识","看到","师"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["在","blog","将",":","分支","mkdocs","采用","。","gh","其","到","chancezyw","-","deploy","github","https","pages","目前","部署","提交"," ","io","shuyan",".","/","直接","可以"],"title":"How to build？","title_tokens":["how","？"," ","to","build"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["学识","首先","自己","一些","巩固","资料","，","浏览","通过","。","基本","语法","其次","的","刷题","网上"," ","学习","来","可以"],"title":"How to practice？","title_tokens":["how","？"," ","to","practice"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["管用","并","都","智慧","更好","自己","技术","搜索","一些","旅行","提问","javascript","掌握","，","你","建议","地","实践","渴望","编程","google","语言","帮助","保持","：","要","下去","什么","善用","见闻","的","比如","我","阅读","一门","编程语言","对","比","坚持"," ","提升","好奇","坚持下去","至少","可以","与"],"title":"What can you read?","title_tokens":["?","what"," ","you","read","can"]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["主题","palette"," ","颜色","color","更换","material"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["=",";","document","localstorage","purple","queryselectorall","blue","]","mdcolorprimary","teal","(","addeventlistener","data","yellow","amber","buttons","\"","主色","call","lime","orange","[","green","color","click","{","点击","primary","主题",",","white","grey","-","this","function","可","的","button","}","light","brown","prototype","色块","setitem","dataset","pink"," ","body",".","md","默认","deep","array","foreach",")","red","更换","indigo","cyan","var"],"title":"Primary colors 主色","title_tokens":["primary"," ","主色","colors"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["=",";","document","localstorage","purple","queryselectorall","blue","]","mdcoloraccent","accent","teal","(","addeventlistener","data","色","yellow","amber","buttons","\"","call","lime","orange","[","green","color","辅助","click","{","点击","主题",",","-","this","function","的","button","}","light","prototype","色块","setitem","dataset","pink"," ","body",".","md","默认","deep","array","foreach",")","red","更换","indigo","cyan","var"],"title":"Accent colors 辅助色","title_tokens":["colors"," ","accent","辅助","色"]},{"location":"algorithm/introduction/","text":"Become stronger ¶ 想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！ 变强的方法 ¶ 参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["时候","感受","参考","加入","题","想起","一点","推荐","千多","！","三千","小","stronger","，","变强","大堆","我要","问","心里","不用","方法","排序","：","一个","的","我","简单","想","找","刷","¶","了","半天","三千多","才","become","大佬","打卡"," ","中值","只有","某位","顺序","出来","阿赖"],"title":"Getting Started","title_tokens":["getting","started"," "]},{"location":"algorithm/introduction/#become-stronger","text":"想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！","text_tokens":["时候","感受","加入","想起","一点","！","小","，","变强","大堆","我要","问","心里","不用","排序","：","一个","的","我","简单","想","找","了","半天","才","打卡","中值"," ","只有","出来","阿赖"],"title":"Become stronger","title_tokens":[" ","stronger","become"]},{"location":"algorithm/introduction/#_1","text":"参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["三千多","参考","大佬"," ","题","某位","的","顺序","推荐","刷","千多","三千","了"],"title":"变强的方法","title_tokens":["变强","方法","的"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["console","标记","indent","center","spaces","无","多种","代码","ctf","省略","list","中","正确","陈述","强调","for","阅读","单位","添加","直角","非","barbar","下划线","根据","wiki","自动","也",":","content","表格","nested","只","?","空行","failure","配置","）","a","header","反","时","编写","在","其他","b","公式","有","team","双引号","用","主题","diff","没有","foo","开始","尽量","$","半角","「","文件","处理","参考","要求","text","搜索","看做","\"","很","当","block","log","utf","使用","可以","嵌套","、","引用","全角","遇到","文件夹","有名","不","中英","​","高亮","划线","换行","相关","内容","`","语言","indenting","flavored","两","缩进","空格","专有名词","显示","danger","8","##","搜索引擎","段落","分隔","连","肯定","be","the","t","有序","词","left","简单","中文标点","排版","warning","example","参见",".","小写","fenced","其內容","1","ide","大小写","cell","foofoo","口语化","样式","标题","语句","删除","aligned","数字","特殊","second","大小","英文","名词","（","/","行末","nice","插件","文档","个","it","啰嗦","序列","多","right","」","sure","status","good","例子","适用","避免","前后","主动","必要","and","looks","省略号","|","列表","行间","包括","github","结构","#","markdown","of",",","=","”","js","(","readme","当前","标识","后","体验","序列表","注明","after","会","为准","之间","2","标点","是","+","提交","后缀","从","章节","与","first","原因","建议","4","。","!","'","更","一个","info","请","字符","不必要","*","提升","符号","目录","标识符",";","一级","question","将","bullet","baz","note","专有","采用","完整","c","引擎","行内","格式","文字","和",")","说法","bug","件夹","两个","update","，","重复","居中","重复使用","success","中英文","清理","至多","tip","bad","…","标点符号","文件名","整句","again","don","酌情","加","合理","bar","索引","google","代替","陈述句","3","“","之后","的","为","¶","正文","md","space","单词","to","git","pygments","以","中文","而","mkdocs","不必","语态","增加","规范","quote","admonition"," ","表达","指南","abstract","仅","numbered","口语","wrapped","your","编码","部分","引号","下划","-","以便","seo","且","无需","页面","块","需要","作为","间"],"title":"Markdown Norm","title_tokens":[" ","norm","markdown"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["team","规范","ctf","wiki","编写"," ","markdown","的","采用","。"],"title":"Markdown 编写规范","title_tokens":["编写"," ","规范","markdown"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["8","原因","参考","、","单词","两个","搜索引擎","文件夹","分隔","连","搜索","看做","文档","，","将","划线","建议","索引","编码","而","。","google","下划","会","处理","-","引擎","一个","的","之间","为","seo","字符","文件名","是"," ","md",".","后缀","指南","utf","小写","非","文件","使用","件夹","下划线"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["仅","时","根据","在","##","要求","一级","文档","有","，","1","当前","当","mkdocs","采用","后","至多","空行","之后","中","一个","标题","bad","的","没有","配置","空格","开始","添加","且","#","页面","good"," ","正文","/","作为","目录","从","章节","与","间"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["时","插件","、","在","question","自动","段落","不","主动","肯定","口语","有","，","必要","换行","内容","ide","部分","note","词","success","不必","语态","清理","多种","只","陈述句","tip","口语化","空行","主题","会","样式","啰嗦","一个","中","陈述","语句","的","删除","info","两","强调","failure","quote","空格","尽量","admonition","不必要","warning","danger","提交","example"," ","表达","需要","行末","酌情","abstract","适用","说法","使用","bug","避免"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":[" ","baz",".","1","foo","barbar","foofoo","bar"],"title":"有序列表无需编码","title_tokens":["无需","序列表","列表","序列","编码","有"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["嵌套","8","时","在","也","text","numbered","个","the","标记","wrapped","，","1","bar","and","indent","t","很","有序","bullet","looks","当","baz","spaces","it","4","标识","。","后","nested","'","?","3","列表","after",",","list","indenting","没有","foo","2","for","简单","缩进","空格","结构","尽量","again","无需","*","和"," ","don",".","a","作为","标识符","of","space","nice","使用","可以"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[";","js","console","文档","pygments","(","​","高亮","，","\"","block","log","fenced","`","语言","代码","注明","以便","参见","块"," ",".",")","使用"],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["时","引用","to","be","readme","update","，","当","your","`","引号","!","代码","行内","且","sure"," ",".","md","反","文件","使用"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["git","以",":","content","left","center","cell","。","|","-","为准","diff","flavored","格式","aligned","github","second","right","status"," ","markdown","header","first"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["全角","其他","不","中英","中文","中英文","增加","代码","行内","之间","包括","数字","空格","英文","单位","字符","标点","（","）"," ","需要","加","与"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["”","不","重复","双引号","省略号","重复使用","引号","代替","用","规范","“","省略","的","…","标点符号","直角","标点","」"," ","符号","「","使用"],"title":"标点符号","title_tokens":["标点符号","符号","标点"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["其內容","、","全角","遇到","，","中文","完整","的","数字","特殊","中文标点","英文","字符","标点","整句","名词","半角"," ","使用"],"title":"全角与半角","title_tokens":["全角","半角","与"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["名词","正确","大小写","专有","的","有名","小写","大小","专有名词","使用"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["=","合理","前后","b","公式","，","居中","无","。","体验","c","行内","行间","的","阅读","显示","尽量","文字","+","$","和"," ","提升","a","使用","可以"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["参考","相关","更","内容","和"," ","中文","例子","指南","请","。","多","排版"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["优质","资源","js","技巧","blog","书单","rx","精通","个人","icss","基础","30","敏捷","的","¶","奇淫"," ",".","开发","在线","梁少峰","学习","days"],"title":"Learning Resources","title_tokens":["learning","resources"," "]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["学习","资源"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":["基础"," ","学习","js"],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["奇淫","30","rx"," ","精通","的","个人",".","js","技巧","梁少峰","days","icss","blog"],"title":"优质 blog","title_tokens":[" ","优质","blog"]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多 五分钟起步法 ¶ 遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["时候","克服","性价比","从而","之前","养成","神经网","内","抽象","然后","中","成","结合","有助","完","给","穿衣服","回顾","快","分解成","根据","也","法则","习惯","利于","一遍","关联","听","集中","网络","思维","只","最大","那么","老","集中精力","belief","知道","而是","cue","一段时间","在","其他","自己","认为","向","聚合","并且","这些","长此以往","然而","用","模式","分钟","没有","智商","高强","开始","起来","刚","高强度","「","最好","特定","推断","眼中","所有","反复","方向","数据","很","死亡","速度","routine","世界","reward","办法","什么","间隔","固化","别人","大","最终","意味着","可以","更好","库存","不","信息","段时间","大脑神经","突触","这样","生成","五分钟","下","聪明","良好","助于","至少","穿","闭上眼","小而","并","一点","脑神经","五分","不用","普通","比如","因此","意味","就是说",".","这是","十遍","成大","最","症","难","马云","难免","新陈代谢","所以","周末","再","运动","组块","而已","要","强度","删除","对","惯性","25","脑细胞","意识","问题","睡眠","他","复习","多少","讲","能够","大化","细胞","重要","人","分析","解决方案","这","以往","多","」","让","学","今天","做出","学习","即时","最大化","有利于","e","做","记住","通人","有利","结果","同时","天才","隔离","保持","奖励","有限","物流","结构","给予","明白","体","分解","信号","一些","技巧","去","目的","单一","加强","做事","遇见","先","会","？","接到","能","代谢","是","接受","得到","企业","生长","整个","栗子","你","上眼","核心","复杂","。","回忆","老旧","以后","但是","更","批判","知识","了","也就是说","有助于","事情","明天","打包","海马","拖延","消灭","神经网络","控制","已有","压缩","掌握","将","就是","普通人","白话","方式","以终","微","和","穿衣","方案","思考","放松","就","只是","专注","危险","试着","大白","小","我们","，","这个","重复","产生","不管","神经","通过","衣服","大脑","番茄","记忆","大白话","工作","如何","信念","东西","睡前","多用","合理","都","忘记","执行","制定","掉","时间","上","才能","解决","精力","举个","之后","压缩包","法","的","再谈","¶","形成","任务","类比","起步","每天","某些","反馈","衰弱","为始","而","练习","精确","g","一样","比喻","即使","不想","新","神经元"," ","在于","变","发展","不是","僵尸","一段","行为","如果","看法","乏味","怎样","需要"],"title":"Study&Thought","title_tokens":["study","thought","&"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["？","和","的","习惯","良好","思考","学习","养成","如何"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["时候","睡前","特定","在","向","记住","控制","脑神经","一遍","某些","方向","并且","，","信息","复习","神经","通过","大脑神经","突触","网络","能够","生成","长此以往","大脑","重要","老旧","会","记忆","的","删除","方式","因此","以往","新","」","让"," ","放松","「","发展","可以"],"title":"大脑结构","title_tokens":["结构","大脑"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["生长","有利于","利于","有利","睡眠","，","加强","产生","神经","你","突触","就是","新陈代谢","细胞","大脑","。","能","代谢","的","有助","了","也就是说","新","有助于","神经元","就是说"," ","脑细胞","聪明","体","良好","变","海马","助于"],"title":"良好睡眠","title_tokens":["良好","睡眠"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["在","信号","之前","养成","结果","，","你","做事","routine","这样","reward","之后","接到","的","belief","行为","惯性","信念"," ","做出","cue"],"title":"僵尸意识","title_tokens":["意识","僵尸"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["穿","整个","都","在","e","执行","一些","不","压缩","所有","将","关联","信息","，","这个","集中","你","思维","衣服","组块","。","回忆","重要","要","以后","模式","g","什么","一样","中","成","压缩包","能","的","方式","比如","如何","是","起来","」","下","知道"," ","打包",".","穿衣","需要","「","学习","东西","穿衣服","就"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["问题","分解成","只是","性价比","分解","专注","也","从而","聚合","通人","掌握","反复","小","我们","将","，","这个","同时","你","就是","上","速度","核心","大化","练习","再","天才","普通人","才能","世界","解决","。","普通","保持","人","办法","要","最大","那么","有限","的","没有","解决方案","这","智商","因此","知识","了","知道","意味","让","接受"," ","大","方案","最终","学习","成大","东西","最大化","意味着","就"],"title":"怎样形成组块","title_tokens":["怎样","组块","形成"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["集中","给予","奖励","25","精力","分钟","克服","集中精力","症"," ","自己","的","这是","然后","最好","拖延","办法","，"],"title":"番茄工作法","title_tokens":["工作","番茄","法"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["并","一段时间","在","也","忘记","神经网络","一些","技巧","不","脑神经","掌握","反复","，","重复","加强","神经","神经网","很","段时间","突触","时间","内","大脑神经","网络","抽象","能够","一段","生成","然后","这些","大脑","番茄","重要","强度","固化","结合","能","记忆","法","的","即使","工作","高强","新","是","起来","让","和"," ","高强度","在于","放松","十遍","学习","东西"],"title":"间隔重复法则","title_tokens":["重复","法则","间隔"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["闭上眼","人","回顾","你","让","上眼","乏味","难免","试着","的","。","可以","单一","重复","，"],"title":"在重复中回顾","title_tokens":["在","中","重复","回顾"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["奖励","危险"," ","的","信号","习惯","隔离","养成","微"],"title":"克服拖延症","title_tokens":["克服","症","拖延"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["小而","不是","时候","每天","难","做","不","制定","周末","复杂","精确","只","先","的","完","开始","刚"," ","明天","今天","而是","最","任务"],"title":"如何制定任务","title_tokens":["制定","如何","任务"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["每天","都","在","一点","，","产生","不管","神经","多少","掉","衰弱","死亡","而","所以","不用","大脑","人","会","老","的","开始","如果","神经元","学","至少","就"],"title":"合理运动和学习","title_tokens":["和","运动","学习","合理"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["有利于","比喻","和","形成","利于","组块","大脑","有利","类比"],"title":"多用类比和比喻","title_tokens":["多用","比喻","和","类比"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["快","只是","在","栗子","认为","库存","目的","眼中","马云","我们","，","他","。","而已","然而","举个","更","物流","的","企业","是","对","看法","消灭"],"title":"以终为始的思维","title_tokens":["思维","为始","以终","的"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["数据","根据","分析","推断","的","去","已有"],"title":"批判思维","title_tokens":["思维","批判"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["多","明白","你","学","会","讲","更","给","别人","大白话","的","白话","东西","大白","得到","，","用","听"],"title":"即时反馈","title_tokens":["即时","反馈"]},{"location":"introduction/study-thought/#_18","text":"遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["但是","分钟","会","事情","五分","做","更好","其他","遇见","的","五分钟","再谈","不想","了","，","先"],"title":"五分钟起步法","title_tokens":["分钟","五分","法","五分钟","起步"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","addition","concept"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["上下"," ","执行","上下文","下文","¶"],"title":"Execute Context","title_tokens":["execute"," ","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["上下文","上下","下文","执行"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/composing-functions/","text":"函数组合 ¶ 函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。 function outputs ¶ 在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。 常规函数组合 ¶ 我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数化只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念性上去去理解 compose","text_tokens":["只是","减小","大多数","if","]","轻易","touppercase",">","拿到","两个","运用","还","理解","不","之前","finalvalue","数组","安全","我们","，","是因为","当然","通过","系列","[","当中","这样","然后","第三篇","length","提到","compose2","还有","fp","返回","使得","具备","fn","list","类似","中","封装","一次","for","上去","容易","考虑","rest","只能","下","通用","给","partialright","惰性","copy","进行","拼","外层","来",",","=","同样","三篇","化","把","arguments","尽可能","性能","也","概念","执行","发生","技巧","去","样子","(","类型","这种","the","night","输出","outputs","从左到右","一份","多个","<","多数","规定","调用","compose","喜欢","不用","reduce","方法","别的","做作","积木","{","最后","会","那么","能","的","origvalue","迭代","2","因此","左","¶","不会","pop","原","从右","是","方块","welcomeuser","func1","长度","+","甚至","的话","小方","上面",".","可能","这是","而是","从","最","约定","现成","概念性","大多","two","composedfn","时","在","循环","向","可读性","计算","第三","...","注意","库","返回值","并且","off","管道","情况","1","你","取出","依次","而","所以","result","尽可","4","。","之所以","welcomeword","'","改进","常规","要","但是","一样","更","一个","function","while","username","像","受到","了","输入","toupper","组合","对","左边","*"," ","运行","reverse","顺序","预设","/","在于","fn2","组成","小方块","curry","直到","}","文章",";","参数","可读","约定俗成","res","长条","修改","放在","库中","将","他","数据","很","last","fn1","lego","args","return","吧","welcome","每次","局限","传递","这里","不再","-","好处","因为","方式","0","这","实现","fper","funcn","多","接收","函数","如果","递归","let","msg","fns","拷贝","good","和","例子","pull","需要","最终","作为","user","func2",")","使用","可以","程序","就"],"title":"Composing Function","title_tokens":[" ","composing","function"]},{"location":"javascript/fp/composing-functions/#_1","text":"函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。","text_tokens":["组成","长条","去","样子","库中","，","管道","数据","你","lego","取出","。","积木","一样","中","的","像","函数","组合","方块","和"," ","小方","需要","拼","从","小方块","现成","可以","程序","就"],"title":"函数组合","title_tokens":["函数","组合"]},{"location":"javascript/fp/composing-functions/#function-outputs","text":"在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。","text_tokens":["只是","大多数","touppercase",">","拿到","安全","我们","，","compose2","fp",")","中","容易","考虑","下","通用","外层",",","=","把","也","执行","发生","(","类型","这种","night","输出","多数","做作","最后","的","origvalue","2","左","是","从右","welcomeuser","+","上面",".","这是","最","约定","大多","在","向","注意","库","情况","1","4","。","welcomeword","'","改进","一个","username","输入","toupper","组合","左边","*"," ","运行","顺序","/","fn2","直到",";","约定俗成","放在","很","fn1","lego","吧","welcome","传递","函数","let","msg","good","例子","需要","最终","作为","user","规定","可以"],"title":"function outputs","title_tokens":["outputs"," ","function"]},{"location":"javascript/fp/composing-functions/#_2","text":"我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数化只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念性上去去理解 compose","text_tokens":["减小","if","]","轻易","两个",">","理解","运用","还","不","之前","finalvalue","数组","我们","，","是因为","当然","通过","系列","[","当中","这样","然后","第三篇","length","提到","还有","compose2","返回","使得","具备","fn","list","类似","中","封装","一次","for","上去","rest","只能","下","给","partialright","惰性","copy","进行","来",",","=","同样","三篇","化","arguments","尽可能","性能","也","概念","技巧","去","(","the","从左到右","一份","多个","<","调用","compose","喜欢","不用","reduce","方法","别的","{","会","那么","能","的","origvalue","迭代","因此","不会","pop","原","长度","是","func1","甚至","的话",".","可能","而是","从","概念性","composedfn","two","时","循环","在","可读性","计算","第三","...","返回值","off","并且","依次","而","所以","result","尽可","。","之所以","要","但是","更","一个","while","像","受到","了","输入","组合","对","reverse"," ","预设","在于","/","fn2","curry","文章","}",";","参数","可读","res","修改","将","他","很","last","fn1","args","return","每次","局限","传递","这里","不再","-","好处","因为","方式","0","这","实现","fper","funcn","多","接收","函数","如果","递归","let","拷贝","fns","和","pull","作为","func2",")","使用","可以"],"title":"常规函数组合","title_tokens":["组合","函数","常规"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器 Point Style ¶ 当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["时候","if","理解","touppercase","presetargs","参数传递","console","数传","之前","promise","keys","但","然后","formatfn","代码","返回","中","没法","for","只能","只不过","strict","some","给","bind","nextobjprops","tostring","把","也","前面",":","<","宽松","喜欢","reduce","别的","帮助","{","只","那么","this","v","constant","nextcurried","shit","长度","style","split","扰乱","在","编写","其他","b","向","聚合","combinefirsttwo","有","注意","另","参数信息","y","params","用","loosecurry","看起","foo","没有","下文","起来","current","reverse","只有","「","判断","_","幸好","later","\"","promise1","很","当","log","args","更改","propsobj","len","传递","else","什么","它","为什么","使用","可以","轻易",">","拿到","不","words","解构","5","onresult","呢","信息","hello","来看","[","手动","这样","length","identity","传递函数","is","考虑","下","upper","v1","unary","直接","并","the","12","一元","上下文","方法","assign","nextcurry","比如","因此","上面",".","最","如下","point","nowobjprops","1","再","curryprops","要","写","像","一元函数","相反","顺序","/","reverseargs","}","可读","spreadargs","传入","不过","id","拆分","每次","重要","v2","上下","fper","这","实现","接收","场景","prevparam","msg","」","让","error","开发","例子","这一","避免","做","]","开发者","优化","15","不能","同时","当然","还有","api","使得","|","列表","如","类似","期望","一次","口中","partialright","基于","of","器","partial","prevargs",",","cache","nextargs","=","ret","js","技巧","(","转换","单一","调用","反转","遇见","花哨","？","会","presetpropsobj","能","2","是","+","应有","又","可能","不动","arg","必须","栗子","情况","你","output","4","。","!","功能","'","object","但是","多余","更","一个","function","可","装饰","操作","那个","nextparam","world","ajax","高级","curry","gatherargs",";","参数","txt","将","partialprops","isshortenough","无法","反向","time","穿透","9","过滤","方式","按照","完全","s","argsarr","let","位置","和","过瘾","user","数量","风格","下面",")","not","就","他们","叫做","两个","还","addthree","obj","map","我们","，","这个","通过","cacheresult","then","success","柯里化","编程","可是","fn","声明","nan","如何","值","p2","来","人们","则","都","砍掉","person","一起","\\","bar","转发","filter","3","原封","举个","的","为","¶","uncurry","now","http","甚至","绑定","很多","内部","islongenough","可读性","...","事实上","某些","props","内置","提高","parseint","没","应用","原封不动"," ","all","不是","取消","兼容","return","不太","事实","仍然","因为","x","偏","看","函数","如果","laterargs","看起来","需要","右边","不定","脑子"],"title":"Manage Function Inputs","title_tokens":["inputs"," ","manage","function"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["做","]","touppercase",">","开发者","还","console","不","words","map","我们","，","这个","不能","promise","hello","来看","[","但","这样","then","success","还有","formatfn","identity","|","传递函数","如","fn","中","口中","for","is","nan","upper","给","unary","值","p2","来","人们",",","=","js","\\","(","the","转换","单一","bar","一元","方法","别的","帮助","filter","{","3","举个","花哨","？","能","的","v","比如","constant","2","shit","now","甚至",".","arg","split","栗子","b","...","某些","1","你","再","output","parseint","用","'","但是","多余","更","一个","看起","foo","写","可以","像","一元函数","world","起来","只有"," ","all","/","}",";","参数","txt","\"","promise1","log","time","传递","穿透","过滤","方式","看","函数","s","let","msg","error","看起来","开发","过瘾","下面",")","避免","脑子","就"],"title":"一元函数","title_tokens":["一元","一元函数","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["时候","=","在","]","两个","兼容",">","console","一起","不","...","combinefirsttwo","(","有","spreadargs","某些","5","呢","，","12","情况","bar","1","15","你","log","[","y","reduce","4","无法","更改","反向","v2","3","9",",","会","？","fn","的","声明","foo","x","2","操作","如何","函数","考虑","argsarr","下","let","+","error"," ","v1",".","/",")","使用","gatherargs","他们"],"title":"参数的解构和聚合","title_tokens":["和","参数","的","聚合","解构"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["时候","]","两个","presetargs",">","不","obj","onresult","，","同时","当然","[","cacheresult","api","fn","中","下","some","partialright","基于","bind","partial","cache",",","直接","=","并","也","js","person","技巧","(",":","反转","喜欢","上下文","{","只","this","的","因此","http","上面","绑定",".","很多","最","编写","...","某些","你","功能","应用","用","但是","更","一个","function","可","下文","ajax","current","reverse"," ","/","reverseargs","}",";","_","later","参数","\"","args","id","return","不太","上下","因为","fper","这","实现","偏","函数","场景","let","laterargs","和","需要","右边","user",")","可以"],"title":"偏函数","title_tokens":["偏","函数"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["如下","=","不是","都","if","参数","]","参数传递",">","数传","...","(","传入","将","，","不过","很","当","你","[","手动","调用","params","return","然后","每次","length","柯里化","len","{","传递","只","代码","else","要","但是",",","fn","一个","nextcurry","期望","的","一次","像","偏","nextparam","接收","函数","考虑","是","只不过","prevparam","下","let","长度","和"," ","给","上面",".","需要","不定",")","curry","必须","则","}"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["扰乱","会","提高"," ","其他","参数","可读","可读性","的","拆分","参数信息","信息"],"title":"为什么使用柯里化和偏函数？","title_tokens":["为什么","什么","？","和","柯里化","偏","使用","函数"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["内部","=","都","if","理解","]",">","js","事实上","...","(","我们","，","args","[","这样","return","length","柯里化","prevargs","len","{","loosecurry","else","事实","fn","nextargs","的","nextcurried","实现","为","是","」","let","strict"," ","上面",".","「",")",",","可以","}"],"title":"更宽松的柯里化","title_tokens":["更","柯里化","宽松","的"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["=","ret","取消","参数",">","向","...","(","传入","注意","，","你","当","args","return","柯里化","{","返回","仍然","fn","中","一个","的","没有","for","偏","uncurry","函数","是","let"," ","应有","需要","数量","of",")","arg","}"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器","text_tokens":["时候","if","叫做","轻易","开发者",">","拿到","不","解构","我们","，","不能","keys","通过","length","柯里化","可是","代码","使得","列表","fn","类似","没法","考虑","只能","nextobjprops","器",",","=","tostring","都","js","(","转换","前面","方法","{","那么","presetpropsobj","assign","的","nextcurried","上面",".","可能","nowobjprops","有","props","1","内置","再","。","没","curryprops","object","一个","装饰","reverse"," ","顺序","}","幸好","参数","传入","spreadargs","partialprops","return","每次","更改","重要","propsobj","len","else","按照","这","实现","偏","它","函数","let","让","位置","和","开发","下面",")","使用","可以"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/manage-function-inputs/#point-style","text":"当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["=","islongenough","并","把","参数","]","两个",">","砍掉","addthree","之前","...","(","优化","5","某些","map","另","将","我们","，","1","有","通过","你","当","<","[","args","转发","遇见","isshortenough","4","方法","parseint","这一","编程","length","!","3","原封","fn",")","一个","的","v","比如","2","实现","not","那个","它","接收","函数","如果","是","完全","let","相反","原封不动","+","msg"," ","给","unary",".","例子","又","/","风格","判断","不动",",","可以","则","他们"],"title":"Point Style","title_tokens":[" ","point","style"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["时候","包含","if","引用","叫做",">","副作用","含有","一定","不","开发人员","解构","调试","我们","式","，","这个","是因为","通过","变差","抽象","name","关键字","read","编程","准确","或者","代码","返回","字符串","fn","当有","中","n","一次","声明","包括","命名","不传","如何","给","值","惰性","值得",",","至少","则","=","用来","化","把","尽可能","也","js","执行","入","(","这种","前面","输出","片段","coding","多个","上","说","调用","过程","喜欢","清楚","或是","人员","表达式","{","只","到","变量","最后","会","那么","？","加上","的","闭包","元","自","能力","¶","为","跟踪","是","映射","空","知道","交易","的话",".","可能","输入输出","不赋","原因","在","稳定","可读性","有","返回值","并且","情况","你","多次","匿名","y","取出","造成","面向","尽可","这些","。","堆栈","应用","用","常规","角度","但是","一部分","本质","对象","一个","更","easy","function","作用","没有","隐含","when","写法","输入","字符","todo","只有"," ","变得","后面","表达","/","意识","「","清晰","最好","达式","curry","不同","显式","}","文章","不是","关键","数据流","参数","可读","个","到底","修改","临时","更加","数据","很","当","存储","更新","地","部分","数学","一段","return","一部","过于","传递","外部","else","这会","未来","什么","因为","发人","赋值","x","明显","用途","它","偏","确保","函数","定义","区别","如果","」","let","让","递归","和","pain","开发","或","需要","学习",")","使用","可以","bug","参是","名"],"title":"Nature Function","title_tokens":[" ","function","nature"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","什么","函数"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["片段","多次","关键"," ","function","的","执行","一次","一段","关键字","声明","这些","使用","可以","或者","，","代码"],"title":"常规定义","title_tokens":["定义","常规"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["把","包含","叫做","也","含有","个","有","我们","，","输出","多个","准确","但是","一个","n","的","元","输入","函数","映射","」","和"," ","值","或","「","输入输出","可以","不同"],"title":"数学角度","title_tokens":["角度","数学"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["稳定","一定","不","有","式","，","输出","过程","面向","编程","中","的","没有","输入","函数"," ","可能","输入输出","则"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["区别","」","和","过程","的","面向","「","编程","式","函数"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":[" ","中","的","js","能力","函数"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["时候","if",">","副作用","开发人员","不","解构","我们","，","变差","返回","代码","fn","当有","中","包括","命名","不传","至少",",","则","=","(","这种","输出","多个","喜欢","人员","{","变量","最后","的","空","输入输出","不赋","可读性","有","返回值","并且","y","取出","造成","用","一部分","更","对象","一个","作用","隐含","写法","输入","只有"," ","/","清晰","最好","显式","}","数据流","参数","可读","修改","临时","更加","数据","当","存储","部分","return","一部","传递","外部","else","这会","因为","发人","赋值","x","明显","它","函数","如果","let","让","和","开发","需要",")","使用","可以"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["到","上","和"," ","偏","curry","应用","函数"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["时候","用来","原因","引用","在","尽可能","入","不","前面","调试","，","这个","情况","是因为","你","很","coding","匿名","更新","调用","抽象","清楚","name","尽可","或是","read","堆栈","过于","返回","只","字符串","未来","fn","会","一个","加上","因为","easy","的","自","when","命名","为","用途","确保","字符","如何","函数","跟踪","如果","空","递归","是","知道","todo","交易","的话","pain"," ","给",".","可能","需要","值得",",","可以","bug","参是","名"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["到","会","说","后面","的","。","文章"],"title":"惰性表达式","title_tokens":["达式","表达式","表达","惰性"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["时候","读者","]",">","不","map","式","，","我们","结果","熟练","过度","[","近年","发现","length","编程","代码","不由","中","不由自主","转变成","声明","for","阅读","近年来","不得","不得已","来",",","总是","=","++","并","化","都","也","成本","命令式","去","(","更少","<","了然","年来","强","天然","{","迫不得已","3","一目了然","举个","会","的","2","¶","协同","是","得","独立","知道","意味","维护","才",".","从","必须","一目","带来","在","栗子","循环","可读性","...","1","细节","变成","一下","维护性","而","干","对比","4","。","每","增加","多人","平衡","模式","应该","深入","更","技术细节","一个","了","关心","对","事情","看出"," ","一步","/","意识","「","i","}",";","数据流","要求","可读","技术","更易","arr","潜意识","掌握","所有","数据","意味着","自主","主流","m","命令","熟练掌握","人","什么","取得","好处","因为","转变","0","明显","函数","可维护性","let","让","」","和","开发","下面",")","可以","bug"],"title":"Why FP","title_tokens":["why"," ","fp"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["时候","]",">","map","我们","，","[","发现","length","代码","不由","不由自主","for","阅读","不得","不得已","来",",","=","++","也","去","(","更少","<","了然","强","天然","{","迫不得已","3","一目了然","举个","会","的","2","知道","维护",".","一目","在","栗子","循环","可读性","...","1","细节","一下","维护性","干","对比","4","。","每","深入","了","看出"," ","一步","/","意识","i","}",";","可读","更易","arr","潜意识","自主","m","什么","因为","0","明显","可维护性","let","下面",")","可以","bug"],"title":"函数式编程带来的好处","title_tokens":["带来","好处","的","编程","式","函数"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["数据流","读者","技术","命令式","式","结果","细节","数据","过度","而","。","命令","代码","人","更","技术细节","的","声明","关心","」","让","和"," ","「","总是"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["=",";","&","式"," ","的","转变","命令式","声明","gt","命令"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["并","化","都","成本","不","去","所有","掌握","式","我们","熟练","。","编程","熟练掌握","代码","平衡","应该","取得","一个","的","函数","是","得","关心","意味","维护","才","事情","和"," ","开发","意味着","必须"],"title":"代码中的平衡","title_tokens":["中","平衡","的","代码"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":["getting","started"," "]},{"location":"skills/introduction/","text":"简介 ¶","text_tokens":["简介"," ","¶"],"title":"Getting Started","title_tokens":["getting","started"," "]},{"location":"skills/introduction/#_1","text":"","text_tokens":[],"title":"简介","title_tokens":["简介"]},{"location":"skills/git/git-cz/","text":"why git cz ¶ 给 git commit 添加一段简短有意义且规范的描述 组成 ¶ 一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中 type ¶ feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变 scope ¶ 说明本次代码影响的范围（文件、文件夹） subject ¶ 简短描述 body ¶ 当代码需要一些说明时 foot ¶ 可以用来跟踪 issue 的 ID ，如 Close #123 方便的库 ¶ npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["save","、","json",">","文件夹","其中","，","改变","通过","换行","path","package","然后","或者","代码","line","如","scripts","中","docs","包括","空格","全局","添加","perf","#","subject","exact","foot","给","run","blank","来","标准","用来","并","测试","简短","性能","也","一些","(",":","说明","<","过程","123","{","test","close","的","¶","跟踪","config","提交","）",".","style","方便","commitizen","时","commit","去掉","在","git","影响","意义","有","库","npm","提高","footer","。","功能","feat","规范","cz","g","应该","issue","一个","构建","没有","安装","描述","了","新","只有"," ","（","init","运行","fix","范围","目录","i","文件","组成","}","why","changelog","文档","工具","修改","refactor","\"","当","部分","id","一段","几个","本次","-","chore","修复","且","type","conventional","scope","项目","body","需要","下面",")","可以","bug","就","件夹"],"title":"git-cz","title_tokens":["-","cz","git"]},{"location":"skills/git/git-cz/#why-git-cz","text":"给 git commit 添加一段简短有意义且规范的描述","text_tokens":["规范","commit"," ","给","简短","git","且","一段","的","意义","有","描述","添加"],"title":"why git cz","title_tokens":["why"," ","cz","git"]},{"location":"skills/git/git-cz/#_1","text":"一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中","text_tokens":["commit",">","(","其中",":","<","部分","footer","几个","line","应该",")","一个","的","包括","type","scope","subject","body"," ","下面","blank","标准"],"title":"组成","title_tokens":["组成"]},{"location":"skills/git/git-cz/#type","text":"feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变","text_tokens":["并","去掉","测试","性能","也","文档","影响","意义","工具","(","修改","，","refactor","改变","换行","提高","过程","功能","或者","feat","代码","test","构建","docs","的","没有","chore","修复","空格","添加","新","perf","提交","只有"," ","style","fix",")","bug"],"title":"type","title_tokens":["type"]},{"location":"skills/git/git-cz/#scope","text":"说明本次代码影响的范围（文件、文件夹）","text_tokens":["说明","、","文件","（","）","的","文件夹","范围","影响","本次","件夹","代码"],"title":"scope","title_tokens":["scope"]},{"location":"skills/git/git-cz/#subject","text":"简短描述","text_tokens":["描述","简短"],"title":"subject","title_tokens":["subject"]},{"location":"skills/git/git-cz/#body","text":"当代码需要一些说明时","text_tokens":["说明","时","当","需要","一些","代码"],"title":"body","title_tokens":["body"]},{"location":"skills/git/git-cz/#foot","text":"可以用来跟踪 issue 的 ID ，如 Close #123","text_tokens":["用来","如","issue","#","close"," ","id","的","123","可以","，","跟踪"],"title":"foot","title_tokens":["foot"]},{"location":"skills/git/git-cz/#_2","text":"npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["save","changelog","commit","在","json","git","npm",":","\"","通过","path","package","然后","。","{","cz","g","scripts","-","中","安装","全局","了","添加","conventional","项目","config","exact"," ","init","运行",".","run","目录","i","来","commitizen","可以","就","}"],"title":"方便的库","title_tokens":["库","方便","的"]}]}