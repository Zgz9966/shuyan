{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ blog 主题 copy 自 CTF-wiki Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["一往无前","永远","prototype",")","梳理","智慧","不是","。","不断更新","how","array","可能","的",",","？","自己",";","一往","面对","/"," ","上述","分支","what","可以","失效","deep","中","wiki","can","mkdocs","function","ctf","更好","brown","document","'","部分","列出","巩固","做","未来","you","md","采用","foreach","调用","javascript","专注","copy","call","直接","一些","全面","风景","点击","practice","整理","限于","我","purple","会","辅助","google","渴望","gh","indigo","目前","更新","var","包含","两点","blue","以及","保持","也","事项","将","其","编程语言","多","鉴于","写","局限","刷题","，","light","无前","并且","api","}","github","green","入口","projects","默认","click","颜色","请","更换","grey","orange","成为","坚持","首先","旅行","yellow","提问","其次","addeventlistener","lime","理解","不仅仅","主色","io","色","data","掌握","来到","buttons","算法","语言",".","并","）","坚持下去","primary","dataset","你","函数","旧","编程","到","色块","build","语法","一个","试图","技术","知识","帮助","想",":","经常","阅读","了","回顾","{","好奇","white","]","来","见闻","部署","[","to","https","比如","当然","自","¶","什么","总是","内容","chancezyw","较","在于","正在","?","：","仅仅","palette","pink","（","下去","对","欢迎","与","着力","学识","可","\"","this","主题","setitem","accent","typescript","mdcoloraccent","相关","cyan","=","师","实践","material","teal","资料","以下内容","主要","css","和","缺失","前端","要","看到","而","新","浏览","s","详细","善用","都","栈","时","因此","学习","一门","red","shuyan","基础","提交","地","涉及","在","建议","color","系统","blog","局限于","至少","通过","colors","pages","amber","完善","mdcolorprimary","localstorage","判断","以下","式","关于","待","较为","不会","是","此外","不仅","领域","核心","参见","button","deploy","queryselectorall","read","将会","不断","网上","经历","搜索","提升","基本","body","-","深入","管用","比","(","基础知识","随时"],"title":"Getting Started","title_tokens":["getting","started"," "]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["一往无前","永远","梳理","不是","。","不断更新","可能","的","自己","一往","面对"," ","上述","失效","中","'","部分","列出","做","未来","调用","javascript","专注","全面","风景","整理","限于","我","会","目前","更新","包含","两点","以及","保持","也","事项","多","鉴于","写","局限","，","无前","并且","api","入口","projects","请","成为","理解","不仅仅","来到","算法","并","）","函数","旧","编程","一个","试图","技术","知识","想","经常","了","回顾","当然","总是","内容","chancezyw","较","在于","正在","仅仅","（","欢迎","着力","typescript","相关","师","以下内容","主要","css","和","缺失","前端","看到","而","新","s","详细","栈","时","因此","shuyan","基础","涉及","在","系统","blog","局限于","完善","判断","以下","式","关于","待","较为","不会","是","此外","不仅","领域","核心","参见","将会","不断","经历","深入","基础知识","随时"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["gh","到","目前","。","将","其",":","/","shuyan"," ","提交","分支","在","可以","blog","部署","https","github","pages","mkdocs","chancezyw","deploy","采用","-","io","直接","."],"title":"How to build？","title_tokens":[" ","build","to","how","？"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["浏览","语法","。","学习","的","自己"," ","可以","刷题","，","来","通过","学识","巩固","首先","网上","其次","基本","一些","资料"],"title":"How to practice？","title_tokens":[" ","practice","to","how","？"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["google","你","要","渴望","编程","智慧","善用","都","一门","帮助","技术","保持","编程语言","的","自己","阅读","地"," ","好奇","建议","可以","，","见闻","至少","比如","什么","更好","：","下去","对","与","坚持","旅行","提问","搜索","提升","javascript","一些","掌握","管用","实践","比","语言","并","我","坚持下去"],"title":"What can you read?","title_tokens":[" ","what","you","read","can","?"]},{"location":"#material-color-palette","text":"blog 主题 copy 自 CTF-wiki","text_tokens":[" ","blog","主题","wiki","自","copy","ctf","-"],"title":"Material color palette 更换颜色主题","title_tokens":["color"," ","更换","主题","material","颜色","palette"]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["色块","indigo","prototype",")","var","array","blue","的",",",";","red"," ","deep","color","white","]","{","light","amber","[","}","green","mdcolorprimary","默认","click","function","localstorage","pink","brown","document","可","更换","\"","grey","orange","button","queryselectorall","主题","foreach","md","this","yellow","addeventlistener","setitem","lime","body","call","主色","-","cyan","data","=","点击","buttons",".","teal","purple","(","dataset","primary"],"title":"Primary colors 主色","title_tokens":["主色","primary"," ","colors"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["色块","indigo","prototype",")","var","array","blue","的",",",";","red"," ","deep","color","]","{","light","amber","[","}","green","默认","click","function","localstorage","pink","document","更换","\"","this","orange","button","queryselectorall","主题","accent","md","foreach","yellow","addeventlistener","mdcoloraccent","setitem","lime","body","call","-","色","cyan","data","=","点击","buttons",".","teal","purple","(","dataset","辅助"],"title":"Accent colors 辅助色","title_tokens":["色"," ","colors","accent","辅助"]},{"location":"introduction/markdown-norm/","text":"采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["索引","词","bad","小写","陈述","ctf","代码","例子","插件","c","不必","章节","会","nice","专有","标识符","且","口语化","双引号","seo","参考","以便","文件夹","，","quote","下划线","请","不必要","#","second","note","it","添加","readme","间","、","一个","阅读","删除","中英","（","主题","名词","##","遇到","更","and","js","your","中文标点","空格","danger","根据","合理","时","log","配置","从","在","`","looks","列表","文字","为","排版","语态","下划","语句","content","info","baz","单位","的","barbar","大小写",";","/","可以","注明","指南","for","标题","之间","header","'","1","部分","again","文件","结构","nested","使用","后缀","google","序列表","缩进","将","字符","github","|","适用","2","spaces","引擎","failure","update","大小","符号","无需","数字","）","专有名词","其他","标点符号","标点","当","当前","git","8","多种","引号","仅","省略","搜索引擎","避免","wrapped","页面","相关","单词","和","bug","「","abstract","提交","包括","两个","不","省略号","after","pygments","是","口语","-","markdown","(","看做","block","主动",")","划线","段落","…","utf","件夹","mkdocs","公式","肯定","行间","md","空行","采用","有名","行末","换行","success","简单","$","numbered","正确","text","加","编写","status","中英文","question","半角","显示","good","前后","​","行内","be","处理","直角","t","要求","表格","left","right",":","to","有序","¶","内容","?","与","嵌套","the","反","sure","diff","正文","admonition","space","英文","文档","作为","分隔","indent","增加","样式","don","至多","of","序列","fenced","重复使用","尽量","a","整句","foofoo","个","。","规范",",","一级"," ","中","wiki","说法","console","自动","清理","!","为准","引用","文件名","」","list","开始","只","高亮","indenting","没有","warning","也","表达","编码","多","bullet","其內容","标识","center","foo","*","居中","重复","很","中文","b","语言",".","目录","酌情","陈述句","4","代替","全角","example","标记","flavored","体验","连","啰嗦","tip","aligned","3","\"","cell","=","强调","bar","必要","之后","而","格式","特殊","两","块","建议","以","用","完整","非","后","“","原因","参见","无","搜索","提升","ide","first","”","team","+","有","需要"],"title":"Markdown Norm","title_tokens":["markdown","norm"," "]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["google","而","看做","索引","、","划线","一个","。","将","文档","的","字符","seo","编码","参考"," ","分隔","建议","连","文件夹","，","8","utf","件夹","两个","小写","下划线","指南","搜索引擎","之间","非","是","原因","为","md","文件","搜索","下划","-","引擎","文件名",".","使用","单词","处理","会","后缀"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["正文","要求","一个","根据","没有","且","时","当","文档","作为","的","当前","/","一级"," ","配置","从","在","，","空格","中","bad","mkdocs","仅","标题","至多","后","与","1","good","页面","空行","#","采用","##","添加","之后","目录","有","章节","开始","间"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["bug","只","danger","、","主动","admonition","一个","段落","词","两","warning","时","example","的","口语化","abstract","表达","删除"," ","提交","在","啰嗦","，","quote","tip","多种","中","info","不","样式","陈述","适用","内容","避免","肯定","说法","不必要","自动","口语","部分","question","主题","空行","清理","行末","语态","换行","ide","note","success","插件","强调","尽量","必要","语句","failure","使用","酌情","陈述句","不必","有","空格","会","需要"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["foo"," ","1","bar","foofoo",".","barbar","baz"],"title":"有序列表无需编码","title_tokens":["序列表","序列","无需","列表","有","编码"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["t","nice","标识符","space","indenting","没有","个","。","a","时","当","作为","也",",","标记"," ","indent","numbered","在","可以","8","bullet","，","text","looks","有序","列表","after","标识","for","3","don","?","foo","后","of","*","'","1","嵌套","2","wrapped","again","结构","the","很","spaces","and","it","bar","尽量","nested","无需","list",".","使用","4","和","空格","简单","baz","缩进"],"title":"嵌套列表","title_tokens":["嵌套","列表"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["block",")","高亮","文档","log",";"," ","块","以便","`","注明","，","pygments","console","\"","参见","代码","​","js","fenced","语言",".","使用","("],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["且","时","当"," ","`","，","to","引号","代码","md","文件","!","反","行内","引用","sure","be","your",".","使用","update","readme"],"title":"行内代码","title_tokens":["行内","代码"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["格式","left","。","right",":","flavored","git"," ","以","github","aligned","|","status","center","header","second","为准","-","markdown","first","cell","content","diff"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["单位","其他","全角","英文","标点","字符"," ","包括","增加","加","不","之间","中英文","中英","（","与","代码","行内","中文","数字","空格","）","需要"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["标点符号","「","标点","规范","的","双引号","…"," ","不","省略号","引号","省略","用","“","重复","”","重复使用","」","使用","符号","代替","直角"],"title":"标点符号","title_tokens":["标点符号","标点","符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["整句","全角","、","特殊","英文","标点","的","字符"," ","，","其內容","完整","半角","名词","遇到","中文","使用","中文标点","数字"],"title":"全角与半角","title_tokens":["全角","与","半角"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有","正确","名词","有名","使用","大小","小写","的","大小写","专有名词"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["合理","。","的","阅读","$"," ","体验","可以","，","公式","文字","行间","显示","无","居中","提升","前后","行内","=","c","尽量","b","+","使用","和","a"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["多","相关","请","更","参考"," ","中文","排版","指南","。","例子","和","内容"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["开发","学习","梁少峰","的","days","基础"," ","blog","奇淫","¶","敏捷","优质","在线","书单","技巧","30","js","精通","rx",".","icss","个人"],"title":"Learning Resources","title_tokens":["resources"," ","learning"]},{"location":"introduction/resources/#_1","text":"js 基础学习","text_tokens":["学习","基础"," ","js"],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["30"," ","js","days","技巧","blog","精通","奇淫","rx",".","icss","梁少峰","的","个人"],"title":"优质 blog","title_tokens":[" ","blog","优质"]},{"location":"introduction/resources/#_2","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":["addition"," ","concept"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":[" ","上下文","下文","执行","¶","上下"],"title":"Execute Context","title_tokens":["execute"," ","context"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["执行","上下","下文","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["nan","但","花哨","方法","constant","开发者","数量","只不过","assign","代码","nextcurried","某些","不定","扰乱","只有","output","方式",">","直接","会","过滤","长度","应用","右边","later","没","，","5","words","反向","}","他们","12","理解","partialright","并","宽松","bind","你","开发","一个","shit","prevparam","return","注意","看起来","当然","时候","len","它","举个","绑定","else","更","js","promise","let","is","如何","这个","重要","因此","能","高级","取消","log","为什么","在","arg","\\","起来","x","为","strict","if","9","presetpropsobj","下","无法","presetargs","curry","情况","可能","的","单一",";","/","再","可以","传入","args","for","'","1","如","技巧","调用","甚至","声明","功能","使用","参数信息","then","还","v2","将","转换","上下","仍然","filter","人们","然后","|","prevargs","2","实现","像","下面","keys","基于","函数","其他","当","propsobj","返回","reverseargs","params","touppercase","避免","可","脑子","this","下文","如下","可读","穿透","和","_","「","一元函数","p2","操作","上面","nextparam","两个","不","obj","是","一元","spreadargs","argsarr","object","这样","(","length",")","v1","不是","很多","？","按照","上下文","function","uncurry","一次","person","场景","success","ret","但是","reduce","每次","world","这","看起","位置","now","同时","编写","id","cache","传递","拆分","msg","txt","只能","nextobjprops","ajax","考虑","向",":","还有","一起","]","nowobjprops","来","[","比如","¶","什么","则","应有","口中","partial","别的","更改","the","nextargs","hello","我们","要","s","可读性","多余","因为","值","呢","看","promise1","reverse","error","gatherargs","loosecurry","of","必须","信息","time","upper","identity","all","内部","顺序","combinefirsttwo",",","http","split","柯里化","fper","15","unary","聚合"," ","formatfn","参数传递","nextcurry","中","current","期望","curryprops","过瘾","console","事实上","做","事实","给","不太","」","onresult","只","接收","没有","也","写","user","api","解构","foo","兼容","some","很","b",".","4","栗子","数传","帮助","...","parseint","{","传递函数","3","不过","partialprops","\"","y","就","最","=","bar","那么","反转","喜欢","fn","都","来看","提高","props","用","laterargs","偏","参数","v","手动","使得","不能","map","+","有","cacheresult","需要"],"title":"Manage Function Inputs","title_tokens":["inputs","function"," ","manage"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":[")","的",",","nan","split","单一","？","但",";","/","unary","再"," ","花哨","formatfn","可以","方法","中","constant","开发者","for","过瘾","'","console","1","做","某些","如","甚至","只有","output","给","方式",">","success","但是","过滤","then","还","world","转换","看起","写","，","now","words","filter","人们","}","|","foo","2","像","下面","传递","b",".","msg","txt","你","函数","开发","栗子","一个","shit","帮助","...","还有","parseint","{","]","来","[","传递函数","比如","看起来","touppercase","3","避免","口中","别的","脑子","\"","举个","就","the","hello","更","js","=","promise","穿透","bar","我们","let","is","这个","s","fn","能","log","来看","一元函数","p2","多余","arg","值","\\","起来","看","不","promise1","用","error","参数","v","time","一元","不能","upper","identity","all","map","这样","("],"title":"一元函数","title_tokens":["函数","一元函数","一元"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["你","函数",")","v1","4","情况","fn","v2","...","考虑","的",",","？","一起","log","/","15"," ","操作","]","在","，","5","反向","[","两个","呢","不","3","error","时候","gatherargs","foo","x","兼容","他们","更改","console","12","1","2","某些","y","spreadargs","9",">","声明","下","=","bar","argsarr",".","使用","无法","let","如何","+","有","(","combinefirsttwo","会","reduce"],"title":"参数的解构和聚合","title_tokens":["聚合","参数","解构","和","的"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["presetargs",")","很多","的",",","http","fper",";","/"," ","上下文","可以","中","args","function","current","person","场景","某些","技巧",">","直接","不太","但是","功能","onresult","只","应用","也","上下","这","右边","later","user","，","api","}","同时","编写","id","实现","some","partialright","cache",".","并","bind","基于","你","函数","一个","return","ajax","...",":","{","]","reverseargs","[","当然","时候","partial","可","this","下文","\"","绑定","最","更","js","=","let","和","_","反转","喜欢","fn","因此","上面","因为","两个","不","obj","reverse","用","laterargs","偏","参数","下","(","cacheresult","需要"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["要","你","函数","每次","只","数传","接收","curry","length",")","一个","长度","prevparam","return","都","fn","不是","当","将","考虑","...","柯里化",",","的"," ","{","nextparam","]","上面","参数传递","传入","，","nextcurry","[","然后","params","}","不过","则","期望","一次","偏","只不过","参数","len","必须","是","代码","手动","如下","调用","if","不定","else","给",">","像","很","但是","下","=","传递",".","let","和","(","需要"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":[" ","其他","参数","可读性","信息","的","拆分","提高","可读","扰乱","会","参数信息"],"title":"为什么使用柯里化和偏函数？","title_tokens":["为什么","函数","偏","使用","什么","和","柯里化","？"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["length",")","「","return","都","fn","...","的","柯里化",","," ","上面","{","]","可以","，","[","args","}","loosecurry","prevargs","len","是","事实上","为","实现","strict","nextcurried","事实","if","else","nextargs","理解",">","js","=","内部","我们","」",".","let","这样","("],"title":"更宽松的柯里化","title_tokens":["的","柯里化","更","宽松"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["你","函数",")","一个","没有","return","fn","当","...","的","向","取消","柯里化"," ","{","返回","仍然","传入","arg","，","注意","中","args","}","for","数量","uncurry","应有","of","参数","偏","是",">","ret","=","let","(","需要"],"title":"取消柯里化","title_tokens":["取消","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["函数","开发","每次","length","只能",")","nextobjprops","那么","重要","return","都","fn","可能","考虑","的","柯里化",",","按照","propsobj"," ","上面","{","没","nowobjprops","位置","，","开发者","}","不","props","reverse","curryprops","偏","参数","partialprops","len","assign","1","它","代码","使得","nextcurried","if","else",">","presetpropsobj","=","下面","顺序","object",".","let","和","(","keys"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["curry","不同",")","输入输出","上","文章","个","不是","跟踪","关键字","情况","过于","可能","。","的","n","？",",","面向","更加","/"," ","的话","发人","可以","隐含","变得","中","这种","明显","达式","堆栈","function","一次","不传","把","一部","部分","代码","清晰","确保","未来","调用","只有","角度","给",">","或是","声明","但是","引用","加上","参是","」","元","造成","使用","多次","稳定","说","赋值","会","交易","变量","能力","只","抽象","更新","让","闭包","没有","返回值","包含","应用","也","字符","名","表达","不赋","对象","，","并且","执行","}","解构","后面","命名","叫做","本质","映射","如果","一段","todo","取出","化","过程","存储","很","传递","这会",".","是因为","写法","你","函数","开发","到","编程","入","副作用","最后","一个","return","开发人员","当","到底","数据","用来","{","返回","用途","自","¶","什么","显式","when","清楚","则","时候","前面","修改","一部分","它","表达式","y","当有","可读","else","尽可","匿名","更","变差","js","=","调试","我们","准确","或","let","数学","空","和","如何","这个","bug","临时","一定","值得","「","那么","喜欢","fn","学习","关键","可读性","这些","片段","知道","地","递归","因为","在","常规","包括","值","或者","至少","通过","不","最好","输出","用","外部","式","x","偏","参数","pain","是","惰性","原因","为","字符串","尽可能","easy","read","coding","作用","人员","if","name","意识","输入","数据流","区别","定义","多个","有","(","含有","需要"],"title":"Nature Function","title_tokens":["nature","function"," "]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["是","函数","什么"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["声明","一次"," ","可以","function","，","或者","一段","执行","代码","使用","关键字","多次","关键","的","这些","片段"],"title":"常规定义","title_tokens":["常规","定义"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["函数","不同","「","一个","输入输出","个","包含","也","的","n"," ","可以","值","，","和","输出","把","叫做","映射","输入","但是","我们","」","元","准确","或","多个","有","含有"],"title":"数学角度","title_tokens":["角度","数学"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["函数","编程","一定","输入输出","没有","可能","的","面向"," ","，","中","不","输出","则","式","过程","输入","稳定","有"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["函数","式","区别","编程","「","」","过程","和","的","面向"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["函数"," ","能力","js","中","的"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":[")","输入输出","的",",","更加","/"," ","发人","可以","隐含","中","这种","明显","不传","一部","部分","代码","清晰","只有",">","造成","使用","赋值","变量","让","返回值","不赋","对象","，","并且","}","解构","命名","如果","取出","存储","传递","这会","写法","函数","开发","副作用","最后","一个","return","开发人员","当","数据","{","返回","显式","则","时候","修改","一部分","它","y","当有","可读","else","更","变差","=","我们","let","空","和","临时","喜欢","fn","可读性","因为","包括","至少","不","最好","输出","用","外部","x","参数","作用","人员","if","数据流","输入","多个","有","(","需要"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["函数"," ","偏","到","curry","上","应用","和"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["你","函数","交易","只","入","抽象","更新","值得","一个","跟踪","情况","fn","过于","可能","的","字符",",","用来","名","知道"," ","的话","返回","递归","可以","在","因为","，","会","用途","自","不","when","堆栈","清楚","命名","时候","pain","前面","是","原因","todo","为","字符串","尽可能","easy","确保","未来","read","coding","调用","name","给","尽可","或是","匿名","很","加上","引用","参是","调试","需要",".","空","如何","是因为","这个","bug","如果"],"title":"匿名函数","title_tokens":["匿名","函数"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["到","文章","。","后面","说","的","会"],"title":"惰性表达式","title_tokens":["表达式","惰性","表达","达式"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["去","length","应该","更易","++",")","命令式","意味着","。","的",",","多人",";","/"," ","模式","可以","中","不由","干","明显","for","所有","1","代码","强",">","声明","迫不得已","了然","一下","技术细节","」","细节","<","维护性","会","i","结果","让","可维护性","熟练","也","天然","关心","过度","意味","人","，","对比","}","年来","0","成本","2","化","不得","好处","掌握","下面","循环","变成",".","近年来","发现","4","自主","并","取得","转变成","带来","开发","函数","栗子","要求","编程","一个","技术","...","数据","阅读","了","{","]","一目了然","来","[","协同","¶","什么","总是","3","arr","时候","得","每","对","举个","m","可读","一步","更少","更","=","我们","let","和","bug","潜意识","熟练掌握","而","「","都","不得已","命令","可读性","主流","知道","从","看出","因为","在","维护","转变","读者","增加","才","不","一目","式","是","平衡","必须","不由自主","独立","意识","数据流","深入","近年","map","事情","("],"title":"Why FP","title_tokens":["why","fp"," "]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["去","length","更易","++",")","。","的",",",";","/"," ","可以","不由","干","明显","for","1","代码","强",">","迫不得已","了然","一下","细节","<","维护性","会","i","可维护性","也","天然","对比","，","}","0","2","不得","下面","循环",".","发现","自主","4","栗子","...","阅读","了","{","]","一目了然","来","[","什么","3","arr","时候","每","举个","m","可读","一步","更少","=","我们","let","bug","潜意识","不得已","可读性","知道","因为","看出","在","维护","一目","不由自主","意识","深入","map","("],"title":"函数式编程带来的好处","title_tokens":["带来","函数","式","好处","编程","的"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["而","结果","命令式","让","「","。","技术","命令","的","数据","关心","过度"," ","人","读者","总是","式","代码","声明","数据流","更","技术细节","」","细节","和"],"title":"命令式 =&gt; 声明式的转变","title_tokens":[";","声明","式"," ","=","&","命令式","gt","转变","命令","的"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["去","函数","开发","应该","编程","熟练","一个","意味着","。","都","的","关心"," ","意味","维护","才","不","得","式","成本","必须","所有","平衡","是","代码","化","掌握","我们","事情","并","和","取得","熟练掌握"],"title":"代码中的平衡","title_tokens":["中","的","平衡","代码"]}]}