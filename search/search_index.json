{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["palette","更换","部分","回顾","什么","技术","首先",")","判断","pink","目前","当然","(","编程","实践","事项","-","浏览","深入","网上","对","一往无前","辅助","call","不是","localstorage","在",":","巩固","var","师","white","鉴于","md","/","栈","green","一个","deep","indigo","array","直接","两点","因此","queryselectorall","刷题","prototype","列出","red","yellow","可能","自己","提交","主要","mkdocs","brown","基本","关于","梳理","随时","google","blue","入口","完善","button","也","：","看到","data","领域","。","shuyan","我","并","you","阅读","提升","风景","提问","pages","保持","projects","语言","以及","分支","式","？","涉及","试图","仅仅","material","整理","foreach","primary","不仅仅","css","并且","经历","更新","管用","how",",","掌握","function","¶","与","}","坚持","经常","学习","相关","主色","多","=","采用","可以","主题","[","较","时","前端","deploy","purple","click","color","未来","以下","新","其次","搜索","资料","api",";","知识","局限","到","了","至少","buttons","基础","正在","将会","build","都","colors","地","中","系统","?","amber","，","来到","好奇","github","想","grey","what","写","色块","light","点击","参见","以下内容","永远","来","上述","在于","cyan","成为","全面","智慧","typescript","失效","帮助","setitem","dataset","的","专注","算法","编程语言","部署","下去","请","'","（","和","基础知识","不仅","函数","欢迎","将","javascript","一门","一些","会","面对","做","practice","默认","document","着力","局限于","要"," ","无前","blog","总是","to","accent","一往","坚持下去","通过","而","待","旅行","）","此外","]","较为",".","不断更新","内容","比","不断","mdcoloraccent","学识","善用","https","颜色","调用","是","can","详细","渴望","限于","s","你","addeventlistener","建议","{","比如","更好","this","包含","\"","色","可","其","缺失","body","旧","mdcolorprimary","read","语法","不会","lime","orange","teal","理解","chancezyw","核心","见闻","io","gh"],"title":"Getting Started","title_tokens":[" ","started","getting"]},{"location":"#shuyan","text":"欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["部分","回顾","技术","判断","目前","当然","编程","事项","深入","一往无前","不是","在","师","鉴于","栈","一个","两点","因此","列出","可能","自己","主要","关于","梳理","随时","入口","完善","也","看到","领域","。","shuyan","我","并","风景","保持","projects","以及","式","涉及","试图","仅仅","整理","不仅仅","css","并且","经历","更新","经常","相关","多","较","时","前端","未来","以下","新","api","知识","局限","了","基础","正在","将会","中","系统","，","来到","想","写","参见","以下内容","永远","上述","在于","成为","全面","typescript","失效","的","专注","算法","请","'","（","和","基础知识","不仅","函数","欢迎","javascript","会","面对","做","着力","局限于"," ","无前","blog","总是","一往","而","待","）","此外","较为","不断更新","内容","不断","调用","是","详细","限于","s","包含","缺失","旧","不会","理解","chancezyw","核心"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["。","shuyan","pages","目前","分支",".","-","github","https",":","在","/","部署","直接","采用","可以","其","将","deploy","提交","mkdocs","chancezyw","blog","到"," ","io","gh"],"title":"How to build？","title_tokens":["how","to","build"," ","？"]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["。","通过","首先","，","浏览","网上","学识","来","巩固","的","学习","可以","刷题","一些","语法","自己","其次","基本","资料"," "],"title":"How to practice？","title_tokens":["how","to","practice"," ","？"]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["阅读","我","提升","都","并","坚持下去","地","提问","什么","旅行","保持","技术","，","语言","编程","实践","好奇","对","比","善用","渴望","管用","智慧","你","掌握","帮助","建议","与","的","编程语言","坚持","下去","比如","更好","可以","一门","javascript","一些","自己","google","搜索","要","见闻"," ","至少","："],"title":"What can you read?","title_tokens":["read","you","what","?","can"," "]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["palette","更换","color","material","颜色","主题"," "]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["更换","]","amber",")","pink",".","(","-","grey","色块","call","light","点击","foreach","primary","localstorage","var","cyan","white","md",",","addeventlistener","function","setitem","{","}","green","的","主色","deep","indigo","=","array","dataset","this","主题","\"","[","queryselectorall","可","prototype","body","red","yellow","mdcolorprimary","lime","click","purple","orange","color","默认","teal","blue","brown","document",";","button"," ","buttons","data"],"title":"Primary colors 主色","title_tokens":[" ","primary","colors","主色"]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["更换","accent","]","amber",")","pink",".","(","-","辅助","色块","mdcoloraccent","call","light","点击","foreach","localstorage","var","cyan","md",",","addeventlistener","function","setitem","{","}","green","的","=","deep","indigo","dataset","array","this","主题","\"","[","色","queryselectorall","prototype","body","red","yellow","lime","click","purple","orange","color","默认","teal","blue","document",";","button"," ","buttons","data"],"title":"Accent colors 辅助色","title_tokens":["accent","辅助","colors","色"," "]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["git","前后","部分","!","遇到","且","代码","and","正确","空行","md","一个","note","不","序列","其他","提交","中文标点","google","8","markdown","中文","章节","阅读","标识符","4","1","使用","success","要求","标记","指南","foo","¶","语句","下划","多","肯定","failure","looks","添加","the","seo","间","文件名","barbar","中英文","github","处理","bug","显示","避免","语态","例子","删除","second","##","list","样式","update","其內容","陈述","wiki","*","开始","口语化","体验","readme","半角","没有","特殊","索引","至多","(","单词","3","left","为","在",":","反","/","nice","只","info","两个","陈述句","「","fenced","无需","a","两","。","header","省略号","加","适用","嵌套","文档","专有名词","your","目录","标点","注明","相关","first","主题","可以","ide","时","页面","console","quote","wrapped","?","规范","，","清理","啰嗦","space","当前","'","名词","空格","foofoo","abstract","会","增加","warning","仅","danger","排版","主动","to","非","符号","js",".","文件","代替","强调","公式","for","后缀","合理","建议","pygments","text","$","\"","aligned","分隔","配置","序列表","、","“","英文","admonition","行间","utf","block","中英","b","插件","块","必要","单位","尽量","小写","段落","换行","mkdocs","口语","status","+","提升","numbered","表格","语言","自动","baz","直角","整句","#","content","文字",",","列表","原因","高亮","=","nested","引号","2","bullet","搜索",";","划线","cell","编写","good","it","sure","包括","」","参见","不必","文件夹","的","（","重复使用","居中","again","ctf","don","作为","数字","完整","参考"," ","team","right","双引号","）","以","内容","”","标识","bad","of","下划线","之间","从","编码","看做","引用","大小","flavored","很","专有",")","根据","不必要","-","之后","diff","center","行末","表达","以便","简单","indent","缩进","酌情","bar","更","也","用","标点符号","格式","词","tip","需要","一级","重复","与","说法","采用","标题","大小写","be","当","多种","为准","搜索引擎","中","省略","结构","个","后","example","​","请","和","`","spaces","将","连","indenting","行内","question","有名","件夹","而","引擎","…","无","log","是","c","有","正文","有序","t","after","全角","字符","|"],"title":"Markdown Norm","title_tokens":["markdown"," ","norm"]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["ctf","。","的","采用","编写","规范","wiki","markdown"," ","team"],"title":"Markdown 编写规范","title_tokens":["markdown"," ","规范","编写"]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["索引","件夹","。","非","而","搜索引擎","文件名","使用","，","引擎",".","文档","-","处理","单词","文件","指南","是","为","utf","文件夹","后缀","md","建议","原因","下划线","的","一个","下划","之间","两个","编码","将","小写","字符","连","会","看做","分隔","搜索","google","划线","8","seo","参考"," ","、"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["##","章节","1","中","且","，","good","至多","根据","要求","文档","之后","开始","bad","目录","#","空行","当前","在","后","有","一级","/","与","正文","的","一个","从","采用","标题","添加","时","空格","当","配置","作为","mkdocs","没有","页面","仅"," ","间"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["主动","两","样式","部分","陈述","中","使用","success","，","清理","啰嗦","自动","适用","不必要","admonition","词","多种","内容","行末","表达","tip","需要","bug","不必","空行","question","强调","在","有","插件","口语化","必要","避免","说法","example","的","一个","语句","不","note","只","info","肯定","主题","ide","failure","陈述句","尽量","酌情","时","空格","abstract","会","段落","语态","换行","warning","提交","删除","口语","quote"," ","danger","、"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["foo","bar","1"," ",".","barbar","foofoo","baz"],"title":"有序列表无需编码","title_tokens":["列表","无需","编码","序列","序列表","有"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["list","。","标识符","4","numbered","wrapped","1","?","使用","，","*","space",".","嵌套","it","baz","and","标记","3","标识","结构","个","of","在","for","indent","简单","后",",","列表","foo","nice","缩进","nested","有序","text","和","'","可以","t","spaces","looks","也","尽量","时","空格","the","again","bar","don","当","2","作为","indenting","没有","bullet","after","无需","8"," ","a","很"],"title":"嵌套列表","title_tokens":["列表","嵌套"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":[")","使用","，","js","语言","(",".","文档","代码","log","参见","以便","block","块","高亮","注明","​","pygments","\"","`",";","fenced","console"," "],"title":"代码块","title_tokens":["块","代码"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["to","update","!","且","使用","，",".","sure","代码","文件","your","md","反","引号","`","readme","时","be","当","引用","行内"," "],"title":"行内代码","title_tokens":["代码","行内"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["为准","git","。","right","格式","cell","header","以","-","github","diff","center","left","content",":","status"," ","first","markdown","aligned","second","flavored","|"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["英文","）","加","中英文","代码","包括","需要","标点","中英","单位","与","不","之间","（","其他","字符","空格","增加","数字","全角","行内"," ","中文"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["用","标点符号","“","双引号","符号","省略号","使用","规范","省略","…","直角","」","”","标点","代替","重复","的","不","引号","重复使用","「"," "],"title":"标点符号","title_tokens":["标点","符号","标点符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["特殊","英文","其內容","遇到","使用","，","整句","标点","的","名词","字符","半角","数字","中文标点","全角","完整"," ","中文","、"],"title":"全角与半角","title_tokens":["全角","半角","与"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["专有名词","有名","专有","的","大小","正确","名词","使用","大小写","小写"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["+","阅读","提升","前后","。","使用","，","无","行间","显示","文字","公式","b","c","合理","体验","的","=","$","和","可以","尽量","居中","行内"," ","a"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["内容","例子","。","相关","多","请","和","更","指南","参考"," ","中文","排版"],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["基础","书单","资源","js",".","rx","在线","敏捷","奇淫","精通","¶","优质","梁少峰","学习","的","个人","icss","days","开发","技巧","30"," ","blog"],"title":"Learning Resources","title_tokens":[" ","learning","resources"]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["学习","资源"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":[" ","学习","基础","js"],"title":"在线学习","title_tokens":["在线","学习"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["技巧","梁少峰","的","30","days","个人","icss","奇淫","js","精通"," ",".","blog","rx"],"title":"优质 blog","title_tokens":["优质"," ","blog"]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["开发","敏捷"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["库存","重要","高强","明天","任务","即时","做事","belief","一段","学","给予","什么","办法","这是","回顾","每天","根据","g","信息","怎样","速度","放松","之后","死亡","危险","意味着","对","精确","难免","而已","reward","代谢","一样","一段时间","长此以往","养成","不是","回忆","在","僵尸","固化","接到","为始","那么","不","马云","只","生成","因此","能","脑细胞","助于","惯性","十遍","普通","行为","大脑神经","自己","试着","意识","有限","「","就是","段时间","栗子","隔离","以往","成大","更","快","方式","也","结合","记忆","突触","神经","最","推断","用","一点","同时","。","集中精力","并","闭上眼","强度","神经网","完","而是","运动","这样","听","保持","所以","明白","有利","有助","25","周末","复杂","下","？","然而","海马","普通人","意味","小而","网络","才能","工作","类比","需要","起来","大化","并且","压缩","穿衣服","细胞","成","掌握","方案","¶","习惯","天才","routine","学习","法","然后","重复","也就是说","这些","这","微","大脑","可以","性价比","多少","多","讲","整个","法则","时间","大白","问题","不管","就","新","以后","抽象","如何","乏味","内","聪明","某些","知识","了","有利于","脑神经","奖励","至少","看法","白话","体","组块","反复","打包","关联","都","举个","神经元","解决","有助于","中","克服","，","知道","智商","向","发展","之前","穿衣","企业","」","从而","最大化","难","如果","批判","复习","结构","所有","去","衣服","压缩包","在于","东西","通人","cue","新陈代谢","这个","神经网络","的","专注","就是说","一遍","和","不用","老","掉","将","人","最大","特定","睡眠","即使","反馈","一些","会","多用","产生","做","他","只是","接受","删除","信念","要","刚","分析","记住"," ","方向","世界","小","单一","别人","大白话","眼中","通过","而","大","再","最好","良好","利于","结果","集中","解决方案","模式","比喻","高强度",".","变","以终","已有","数据","执行","老旧","做出","开始","加强","分解","练习","聚合","思考","分钟","拖延","症","忘记","制定","是","衰弱","目的","e","认为","思维","合理","时候","你","形成","分解成","信号","我们","今天","上眼","生长","得到","上","比如","最终","精力","给","先","消灭","间隔","物流","技巧","没有","能够","控制","核心","番茄","睡前","很","穿","让"],"title":"Study&Thought","title_tokens":["study","thought","&"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["习惯","的","学习","思考","如何","和","养成","良好","？"],"title":"如何学习","title_tokens":["学习","如何"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["重要","通过","，","信息","向","放松","发展","老旧","网络","」","复习","长此以往","并且","在","记忆","时候","的","一遍","神经","大脑","生成","因此","可以","特定","大脑神经","会","删除","新","「","能够","控制","以往","某些","方式","脑神经","记住"," ","方向","睡前","突触","让"],"title":"大脑结构","title_tokens":["大脑","结构"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["。","神经元","有助于","良好","利于","有利","，","有助","变","海马","加强","代谢","细胞","你","新陈代谢","的","生长","就是说","也就是说","神经","大脑","能","脑细胞","助于","睡眠","产生","新","就是","聪明","了","有利于"," ","突触","体"],"title":"良好睡眠","title_tokens":["良好","睡眠"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["做事","belief","这样","结果","，","之后","做出","之前","reward","养成","在","你","cue","信号","接到","的","routine","惯性","行为","信念"," "],"title":"僵尸意识","title_tokens":["意识","僵尸"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["组块","重要","打包","。","关联","都","中","什么","集中","，","知道","模式",".","g","信息","下","执行","穿衣","」","一样","所有","需要","起来","是","回忆","衣服","在","压缩","压缩包","e","东西","思维","穿衣服","成","这个","你","的","学习","不","比如","能","将","整个","一些","就","以后","「","如何","要","方式"," ","穿"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["反复","同时","。","解决","大","再","办法","保持","，","解决方案","知道","智商","世界","速度","普通人","意味","意味着","分解","练习","从而","聚合","最大化","才能","通人","大化","东西","你","掌握","这个","分解成","方案","天才","我们","专注","的","那么","学习","上","最终","这","性价比","因此","将","人","最大","普通","问题","只是","就","接受","有限","没有","就是","成大","核心","要","知识","了"," ","也","小","让"],"title":"怎样形成组块","title_tokens":["组块","形成","怎样"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["集中精力","然后","自己","的","拖延","分钟","给予","精力","这是","集中","克服","症","，","奖励","25","最好"," ","办法"],"title":"番茄工作法","title_tokens":["法","工作","番茄"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["反复","高强","重要","并","一段","神经网","强度","，","高强度","放松","网络","加强","忘记","工作","一段时间","起来","是","在","在于","东西","掌握","重复","神经网络","法","然后","固化","的","学习","这些","不","神经","和","大脑","能","生成","脑神经","即使","十遍","一些","时间","大脑神经","技巧","抽象","新","段时间","能够","突触","内","番茄"," ","也","结合","记忆","很","让"],"title":"间隔重复法则","title_tokens":["法则","间隔","重复"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["你","重复","。","试着","的","难免","上眼","闭上眼","乏味","回顾","可以","人","，","单一","让"],"title":"在重复中回顾","title_tokens":["回顾","在","重复","中"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["危险","信号","习惯","的","微","隔离","养成","奖励"," "],"title":"克服拖延症","title_tokens":["克服","拖延","症"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["明天","完","而是","每天","周末","复杂","小而","开始","精确","难","制定","不是","时候","任务","今天","的","不","只","先","做","刚"," ","最"],"title":"如何制定任务","title_tokens":["任务","制定","如何"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["一点","都","神经元","而","学","所以","每天","，","死亡","开始","如果","衰弱","在","的","多少","大脑","不用","老","掉","人","会","产生","不管","就","至少","神经"],"title":"合理运动和学习","title_tokens":["和","合理","运动","学习"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["组块","形成","类比","和","利于","大脑","有利","比喻","有利于"],"title":"多用类比和比喻","title_tokens":["和","多用","比喻","类比"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["眼中","库存","。","举个","，","然而","企业","对","而已","是","在","目的","认为","我们","的","马云","消灭","物流","他","只是","栗子","快","更","看法"],"title":"以终为始的思维","title_tokens":["的","以终","为始","思维"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["已有","的","去","推断","根据","数据","分析"],"title":"批判思维","title_tokens":["批判","思维"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["用","大白","你","会","的","得到","学","明白","听","多","给","更","，","讲","白话","别人","东西","大白话"],"title":"即时反馈","title_tokens":["反馈","即时"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":[" ","addition","concept"]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["执行","上下","¶","下文"," ","上下文"],"title":"Execute Context","title_tokens":[" ","context","execute"]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["下文","执行","上下","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["重要","12","fn","当然","代码","一个","不","其他","上下","可能","取消","不定","看","甚至","reverseargs","每次","同时","4","1","upper","user","使用","success","？","但","props","起来","更改","传入","foo","function","解构","然后","¶","x","传递函数","为什么","一元","the","参数传递","unary","formatfn","如何","presetargs","current","api","应有","看起","举个","数量","向","还","宽松","一起","partial","避免","这个","http","过瘾","它","args","一次","因为","参数信息","v1","人们","要","v2","再","]","v","值","必须","聚合","调用","时候","我们","不过","spreadargs","可","过滤","手动","技巧","没有","喜欢","now","time","filter","(","信息","如下","person","3","为","在",":","/","高级","nextobjprops","nextcurry","只","两个","多余","方法","栗子","「","output","方式","world","partialright","gatherargs","then","这样","下","5","object","}","很多","可以","[","返回","shit","接收","constant","\\","console","keys","注意","9","脑子","some","，","all","写","id","loosecurry","帮助","'","功能","later","上下文","会","单一","转换","curry","js","15","扰乱",".","呢","len","hello","不太","parseint","反向","for","s","\"","return","基于","理解","声明","操作","_","b","可读","words","assign","按照","最","+","兼容","txt","propsobj","情况","combinefirsttwo",",","=","应用","argsarr","2","只不过",";","如","某些","cache","都","编写","onresult","y",">","数传","」","来","口中","obj","reduce","msg","的","开发者","别的","函数","只能","没","实现","绑定","做","可读性"," ","位置","则","事实上","partialprops","看起来","参数","prevparam","cacheresult","prevargs","柯里化","下面","of","{","场景","this","给","uncurry","来看","is","一元函数","上面","很","像","无法","promise1","花哨",")","fper","什么","nowobjprops","不是","nextcurried","考虑","那么","直接","能","因此","map","开发","bar","error","更","只有","也","用","并","传递","p2","if","下文","需要","presetpropsobj","ajax","事实","还有","identity","右边","这","内部","提高","ret","就","当","bind","reverse","中","...","nextparam","promise","和","不能","将","使得","touppercase","curryprops","strict","仍然","期望","laterargs","他们","长度","偏","let","length","split","arg","nextargs","params","log","是","有","你","但是","反转","比如","穿透","nan","拆分","else","顺序","|"],"title":"Manage Function Inputs","title_tokens":[" ","manage","function","inputs"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["像","filter","promise1","fn","花哨",")","(","3","b","/","一个","words","不","能","多余","方法","map","开发","bar","栗子","error","看","output","更","只有","甚至","world","方式","用","then","1","upper","这样","txt","传递","success","？","p2","但","起来","还有","identity",",","foo","}","=","可以","传递函数","[","一元","shit","the","unary","就","2","formatfn","constant",";","\\","console","如","某些","看起","脑子","举个","中","，",">","all","还","...","写","来","口中","避免","这个","帮助","promise","msg","的","过瘾","'","开发者","别的","不能","函数","做","touppercase","人们","单一"," ","转换","看起来","再","参数","]","js","let",".","v","值","split","hello","arg","parseint","log","下面","for","s","你","但是","我们","{","比如","给","\"","穿透","nan","过滤","来看","is","now","一元函数","time","|"],"title":"一元函数","title_tokens":["一元","一元函数","函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["无法","+","兼容","他们","4","12","fn","1","使用",")","]","，","15","let","y","(","呢",">","下","？",".","5","情况","3","...","log","combinefirsttwo","一起","v2","更改","考虑","反向","在","有","foo","你","时候",",","/","reduce","的","=","不","argsarr","x","两个","spreadargs","[","函数","会","bar","2","v1","error","声明","如何","操作","console","某些"," ","gatherargs","9"],"title":"参数的解构和聚合","title_tokens":["解构","的","聚合","参数","和"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["fn",")","fper","(","当然","person","_",":","/","一个","不","只","直接","两个","因此","上下","更","partialright","reverseargs","也","最","用","同时","并","user","下","下文","需要","ajax",",","右边","function","}","=","应用","很多","这","可以","[","bind",";","presetargs","current","api","某些","reverse","cache","some","中","编写","，","onresult",">","...","id","partial","obj","http","的","和","功能","函数","args","因为","上下文","later","实现","绑定"," ","laterargs","参数","]","js","偏","let",".","cacheresult","不太","你","时候","但是","{","反转","场景","this","\"","return","基于","可","技巧","喜欢","上面"],"title":"偏函数","title_tokens":["偏","函数"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["像","每次","都","上面","传递","curry","fn","参数",")","]","长度","，","偏","let","(","len",".","下","length",">","prevparam","如下","代码","数传","params","if","必须","柯里化","...","需要","不是","nextparam","调用","考虑","是","传入",",","你","但是","然后","{","}","一个","=","的","nextcurry","只","不过","和","给","return","[","函数","将","一次","else","参数传递","手动","接收","当","只不过","不定","要","期望"," ","很","则"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["会","可读","的","参数","可读性","提高","拆分"," ","扰乱","其他","信息","参数信息"],"title":"为什么使用柯里化和偏函数？","title_tokens":["柯里化","和","什么","使用","偏","为什么","？","函数"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["都","fn","这样",")","]","，","js","let","(","len",".","length",">","nextargs","if","prevargs","柯里化","」","...","nextcurried","是","为","事实","loosecurry",",","我们","{","}","的"," ","=","内部","可以","return","[","args","实现","else","「","理解","strict","上面","事实上"],"title":"更宽松的柯里化","title_tokens":["的","更","宽松","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["数量","fn","中","参数",")","，","偏","let","(",">","向","arg","柯里化","...","需要","是","of","for","传入","你","{","}","的","=","一个","return","返回","args","函数","uncurry","ret","当","取消","没有","仍然","应有"," ","注意"],"title":"取消柯里化","title_tokens":["取消","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({})","text_tokens":["重要","每次","都","partialprops","上面","fn","1","参数",")","，","偏","let","(",">","propsobj",".","len","nowobjprops","length","代码","object","if","柯里化","props","下面","presetpropsobj","nextcurried","考虑",",","{","}","的","那么","=","不","nextobjprops","它","assign","和","开发者","return","函数","只能","开发","没","else","可能","顺序","使得","按照","curryprops","keys"," ","位置","reverse"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["一段","部分","表达式","fn","什么",")","当有","(","编程","含有","存储","todo","代码","显式","字符串","表达","能力","不是","为","在","过程","可读","/","最后","一个","变得","关键","不","那么","多个","这种","开发人员","变差","闭包","只","人员","开发","取出","到底","命名","后面","可能","作用","意识","「","尽可","只有","更","也","一部分","赋值","或","用","更加","加上","。","传递","递归","使用","元","式","？","面向","if","返回值","情况","需要","变量","说","并且","副作用","更新",",","function","解构","¶","这些","}","原因","学习","叫做","=","应用","化","值得","x","可以","返回","修改","对象","自","明显","把","当","抽象","未来","如何","到","关键字","至少","外部","数学","隐含","coding","地","多次","中","堆栈","名","，","知道","y","清晰",">","包括","或是","」","如果","个","name","bug","交易","参是","临时","达式","跟踪","定义","这个","的","它","匿名","和","稳定","的话","函数","一次","片段","因为","不赋","是因为","会","惰性","一定","准确","本质","前面","可读性","常规"," ","则","数据流","入","输入","通过","区别","curry","文章","最好","参数","js","偏","let","调试",".","值","数据","执行","一部","输入输出","不同","输出","n","发人","不传","是","映射","调用","easy","用来","有","写法","时候","但是","我们","你","{","用途","或者","上","尽可能","when","包含","return","给","空","确保","清楚","过于","else","read","这会","引用","没有","喜欢","声明","造成","角度","pain","字符","很","让"],"title":"Nature Function","title_tokens":[" ","nature","function"]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["什么","函数","是"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["代码","执行","function","这些","的","一段","关键","或者","多次","声明","可以","使用","，","关键字","片段","一次"," "],"title":"常规定义","title_tokens":["定义","常规"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["或","输入","，","元","值","含有","输入输出","」","不同","个","输出","n","映射","有","但是","我们","的","一个","叫做","多个","和","包含","可以","函数","把","准确","「"," ","也"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["输入","中","，","式","编程","面向","输入输出","输出","有","过程","的","不","稳定","函数","一定","可能","没有"," ","则"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["面向","」","的","「","区别","和","函数","式","编程","过程"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["的","中","能力","js","函数"," "]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["部分","fn",")","当有","(","存储","代码","显式","可读","最后","/","这种","一个","开发人员","多个","不","变差","人员","开发","取出","命名","作用","只有","更","一部分","赋值","用","更加","传递","使用","if","返回值","需要","变量","并且","副作用",",","解构","}","=","x","可以","返回","修改","对象","明显","当","至少","外部","隐含","中","，","y",">","清晰","包括","如果","临时","的","它","和","函数","因为","不赋","可读性"," ","数据流","则","输入","最好","参数","let","数据","一部","输入输出","输出","发人","不传","有","写法","时候","我们","{","return","空","else","这会","喜欢","造成","让"],"title":"解构赋值","title_tokens":["解构","赋值"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["应用","curry","上","和","到","函数","偏"," "],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["入","加上","coding","堆栈","fn","递归","名","，","知道","调试",".","todo","情况","或是","如果","字符串","name","需要","bug","交易","调用","是","参是","为","在","用来","easy","更新","跟踪",",","你","时候","这个","用途","原因","值得","的","一个","不","尽可能","匿名","只","when","给","可以","的话","函数","返回","空","因为","清楚","确保","命名","字符","是因为","过于","会","read","自","可能","引用","抽象","未来","前面","如何","pain","尽可"," ","很"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["会","。","的","文章","说","到","后面"],"title":"惰性表达式","title_tokens":["表达式","惰性","达式","表达"]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["命令式","0","自主","什么",")","技术","(","编程","代码","独立","深入","意味着","对","3","arr","不得","取得","在","可读","/","一个","不","更少","潜意识","年来","一目了然","map","开发","i","意识","栗子","「","技术细节","更","也","可维护性","转变","一目","。","维护性","阅读","4","并","熟练掌握","1","平衡","一步","要求","式","意味","<","干","维护",",","掌握","¶","}","=","过度","化","命令","可以","[","看出","关心","明显","2",";","带来","不由自主","了","++","近年","近年来","举个","都","协同","中","，","更易","知道",">","成本","」","...","去","所有","bug","来","了然","不由","主流","的","和","迫不得已","函数","人","因为","循环","增加","会","对比","可读性","细节"," ","变成","数据流","总是","才","得","而","应该","读者","]","结果","模式","let",".","length","好处","数据","熟练","必须","m","发现","下面","天然","是","for","事情","时候","每","我们","{","强","一下","从","多人","声明","不得已","转变成","让"],"title":"Why FP","title_tokens":[" ","why","fp"]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["0","自主","什么",")","(","代码","深入","3","arr","不得","在","可读","/","更少","潜意识","一目了然","map","i","意识","栗子","也","可维护性","一目","阅读","维护性","。","4","1","一步","<","干","维护",",","}","=","可以","[","看出","明显","2",";","不由自主","了","++","举个","更易","，","知道",">","...","去","bug","来","了然","不由","的","迫不得已","因为","循环","会","对比","可读性","细节"," ","]","let",".","length","m","发现","下面","天然","for","时候","每","我们","{","强","一下","不得已"],"title":"函数式编程带来的好处","title_tokens":["的","带来","函数","式","编程","好处"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["总是","命令式","。","而","读者","结果","技术","式","数据","代码","」","的","过度","命令","和","人","关心","「","技术细节","声明","细节","更"," ","数据流","让"],"title":"命令式 =&gt; 声明式的转变","title_tokens":["命令式","的","=","gt",";","声明","命令","&"," ","式","转变"]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["才","并","得","都","。","熟练掌握","应该","平衡","式","编程","熟练","意味","代码","必须","成本","意味着","去","所有","取得","维护","是","事情","掌握","我们","的","一个","不","化","和","函数","开发","关心"," "],"title":"代码中的平衡","title_tokens":["平衡","的","代码","中"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":[" ","started","getting"]}]}