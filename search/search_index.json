{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"shuyan ¶ 那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。 How to build？ ¶ blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支 How to practice？ ¶ 首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。 What can you read? ¶ 我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 Material color palette 更换颜色主题 ¶ Primary colors 主色 ¶ 默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors 辅助色 ¶ 默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["部署","色","palette","pink","以下内容","mkdocs","cyan","随时","见闻","点击","foreach","，","更换","pages","全面","prototype","旧","可","写","想",";","一门","局限于","call","brown","领域","编程语言","'","https","不是","md","地方","完善","无前","google","列出","data","blue","并且","管用","分支","s","至少","经历","queryselectorall","var","其次","array","因此","栈","请","green","shuyan","内容","build","到","不断更新","function","dataset","当然","整理","式","以下","read","gh","理解","基础","缺失","colors","系统","入口","巩固","目前","相关","此外","通过","purple","故乡","chancezyw","color","了","色块","grey","document","较","知识","github","自己","会","来到","涉及","-","学习","部分","语言","主题","素未谋面","light","成为","比","掌握","localstorage","要","提问","mdcolorprimary","辅助","其","以及","不会","直接","setitem","编程","去","风景","渴望","practice","搜索","保持","都","智慧","那些","。","什么","技术","建议","button","判断","中","red",")","帮助","\"","to","实践","待","默认","[","采用","不仅仅","调用","参见","？"," ","blog","资料","amber","多","可能","做","主色","较为","事项","详细","typescript","一些","deep","can","旅行","更好","一往","正在","javascript","提交","：",",","what","）","css",".","你","总是","body","新","?","前端","师","算法","primary","click","是","欢迎","我","将","永远","you","颜色","}","]","对","专注","限于","（","谋面","刷题","material","更新","时","基础知识","首先","accent","包含","的","局限","{","yellow","深入","梳理","上述","网上","仅仅","坚持","this","经常","坚持下去","基本","将会","和","学识","看到","来","buttons","核心","io","语法","鉴于","浏览","回顾","¶","也","不断","=","将要","提升","(","着力","函数","下去","在于","teal","两点","阅读","可以","lime","how","比如","一个","indigo","deploy","api","与","主要","善用","在","而","white",":","好奇","试图","/","orange","并","关于","未来","不仅","一往无前","mdcoloraccent","addeventlistener","面对","地","失效","projects"],"title":"Getting Started","title_tokens":["started","getting"," "]},{"location":"#shuyan","text":"那些将要去的地方，都是素未谋面的故乡。 欢迎来到 shuyan 。 shuyan （chancezyw's blog）是较为全面的前端技术栈整理。 shuyan 涉及较多领域。我试图整理一个系统的入口，判断自己缺失的技术栈，并且专注核心，主要在于理解核心而不是成为 api 调用师。 目前， shuyan 主要包含 JavaScript 的基础知识，并正在着力完善以下内容 JavaScript 中的函数式编程 算法相关 关于上述部分待完善内容，请参见 shuyan 的 Projects ，详细列出了正在做的事项以及待做事项。 当然， shuyan 不会局限于 JavaScript ，在未来， shuyan 将会 深入 TypeScript 深入 Css 此外，鉴于以下两点 我不仅仅想写 blog，我试图梳理我的经历和看到的风景，可能会经常回顾，也会一往无前。 技术总是保持不断更新，旧的技术在面对新的技术时随时可能失效。 因此， shuyan 永远保持更新。","text_tokens":["以下内容","随时","，","全面","旧","写","想","局限于","领域","'","不是","地方","完善","无前","列出","并且","s","经历","因此","栈","请","shuyan","内容","不断更新","当然","整理","式","以下","理解","基础","缺失","系统","入口","目前","相关","此外","故乡","chancezyw","了","较","知识","自己","会","来到","涉及","部分","素未谋面","成为","以及","不会","编程","去","风景","保持","都","那些","。","技术","判断","中","待","不仅仅","调用","参见"," ","blog","多","可能","做","较为","事项","详细","typescript","一往","正在","javascript","）","css","总是","新","前端","师","算法","是","欢迎","我","永远","专注","限于","（","谋面","更新","时","基础知识","包含","的","局限","深入","梳理","上述","仅仅","经常","将会","和","看到","核心","鉴于","回顾","也","不断","将要","着力","函数","在于","两点","一个","api","主要","在","而","试图","并","关于","未来","不仅","一往无前","面对","失效","projects"],"title":"shuyan","title_tokens":["shuyan"]},{"location":"#how-to-build","text":"blog 目前采用 mkdocs 部署在 https://chancezyw.github.io/shuyan/ 。 mkdocs gh-deploy 可以将其直接提交到 gh-pages 分支","text_tokens":["部署","mkdocs","目前","采用","chancezyw","pages","github","-"," ","blog","io","其","https","直接","提交",".","。","可以","shuyan","到","deploy","将","在",":","gh","/","分支"],"title":"How to build？","title_tokens":["to","build","how","？"," "]},{"location":"#how-to-practice","text":"首先，可以通过浏览网上资料来学习一些基本的语法。 其次，可以通过刷题巩固自己的学识。","text_tokens":["巩固","的","通过","网上","，","学习","基本","自己"," ","学识","来","资料","语法","浏览","一些","其次","。","可以","刷题","首先"],"title":"How to practice？","title_tokens":["practice","to","how","？"," "]},{"location":"#what-can-you-read","text":"我的旅行见闻 一些建议： 阅读 提问的智慧 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 JavaScript 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去","text_tokens":["的","见闻","，","坚持","坚持下去","自己","语言"," ","一门","比","掌握","要","提问","编程语言","一些","google","旅行","更好","提升","编程","javascript","管用","渴望","至少","：","保持","都","下去","你","智慧","什么","建议","阅读","可以","比如","技术","与","善用","我","帮助","好奇","对","并","实践","地","搜索"],"title":"What can you read?","title_tokens":["you","read","what","can","?"," "]},{"location":"#material-color-palette","text":"","text_tokens":[],"title":"Material color palette 更换颜色主题","title_tokens":["palette","颜色","color","更换","主题","material"," "]},{"location":"#primary-colors","text":"默认 white 点击色块可更换主题的主色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","text_tokens":["默认","pink","的","cyan","[","点击","yellow","foreach","purple","更换","document","色块","color","可","grey","prototype","this","-","主题"," ",";","buttons","amber","light","call","brown","localstorage","mdcolorprimary","主色","deep","=","md","setitem","data","blue","(","queryselectorall",",",".","var","teal","array","body","lime","green","indigo","button","function","dataset","click","primary","red","white",")","orange","}","]","\"","addeventlistener","{"],"title":"Primary colors 主色","title_tokens":["主色","primary","colors"," "]},{"location":"#accent-colors","text":"默认 red 点击色块更换主题的辅助色 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","text_tokens":["默认","色","pink","的","cyan","[","点击","yellow","accent","foreach","purple","更换","document","色块","color","prototype","this","-","主题"," ",";","buttons","amber","辅助","light","call","localstorage","deep","=","md","setitem","data","blue","(","queryselectorall",",",".","var","teal","array","body","lime","green","indigo","button","function","dataset","click","red",")","orange","}","]","\"","mdcoloraccent","addeventlistener","{"],"title":"Accent colors 辅助色","title_tokens":["色","accent","辅助","colors"," "]},{"location":"algorithm/introduction/","text":"Become stronger ¶ 想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！ 变强的方法 ¶ 参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["我要","的","三千多","刷","心里","，","排序","了","题","找","时候","阿赖"," ","想","只有","一点","参考","顺序","半天","感受","¶","方法","出来","打卡","！","问","某位","大佬","：","become","不用","一个","推荐","stronger","千多","想起","加入","中值","才","我","小","变强","三千","简单","大堆"],"title":"Getting Started","title_tokens":["started","getting"," "]},{"location":"algorithm/introduction/#become-stronger","text":"想起加入小打卡的时候，阿赖问我一个简单的大堆找中值不用排序，我想了半天才想出来 我的心里只有一点感受：我要变强！","text_tokens":["我要","的","心里","，","排序","了","找","时候","阿赖","想"," ","只有","一点","半天","感受","出来","打卡","！","问","：","不用","一个","想起","加入","中值","才","我","小","变强","简单","大堆"],"title":"Become stronger","title_tokens":["stronger"," ","become"]},{"location":"algorithm/introduction/#_1","text":"参考某位刷了三千多题大佬的 推荐顺序","text_tokens":["某位","参考","顺序","大佬","的","三千多","刷","三千","了"," ","题","推荐","千多"],"title":"变强的方法","title_tokens":["变强","方法","的"]},{"location":"introduction/markdown-norm/","text":"Markdown 编写规范 ¶ 采用 CTF Wiki Team 的 Markdown 编写规范。 文档格式 ¶ 使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8 标题 ¶ 根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行 段落 ¶ 使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式 列表 ¶ 有序列表无需编码 ¶ 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz. 嵌套列表 ¶ 在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar. 代码 ¶ 代码块 ¶ 代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档 行内代码 ¶ 行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`! 表格 ¶ 以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | 排版 ¶ 空格 ¶ 中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 标点符号 ¶ 不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 …… 全角与半角 ¶ 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 ¶ 专有名词使用正确的大小写 公式 ¶ 合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$ 其他 ¶ 更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["酌情","，","bad","$","使用","foo","段落","内容","log","直角","全角","符号","数字","有序","github","会","个","after","content","仅","主动","字符","*","居中","双引号","两","文档","to","有","`","utf","大小","分隔","专有","indent","+","“","2","文件夹","git","提交","baz",".","）","of","编写","配置","代替","小写","是","center","非","口语","（","合理","标点符号","的","status","重复","」","¶","也","提升","diff","阅读","可以","页面","完整","「","搜索","前后","mkdocs","编码","your","list","且","反","bug","'","更","md","公式","名词","行内","note","aligned","样式","划线","b","don","简单","序列","多种","team","标题","章节","相关","高亮","注明","right","缩进","看做","语言","主题","部分","a","需要","格式","。","说法","中","间",")","\"","文件","遇到","first","cell","当前","left","采用","排版","参见"," ","行间","多","js","无","、","后","|","将","text","只","空行","行末","时","文件名","tip","重复使用","结构","info","seo","适用","引擎","正确","=","之后","readme","一个","与","fenced","而","清理","显示","连","标点","bar","整句","t","numbered","从","不必","两个","请","danger","例子","序列表","标识符","中英文","目录","嵌套","wrapped","参考","英文","markdown","啰嗦","ctf","开始","特殊","建议","有名","强调","引号","and","后缀","根据","下划线","quote","删除","尽量","无需","example","​","again","当","be","半角","其他","for","?","正文","没有","failure","indenting","专有名词","单位","省略","很","加","语态","增加","索引","header","件夹","pygments","和","避免","the","列表","”","不必要","second","指南","good","中文","块","barbar","block","/","looks","规范","update","nice","文字","!","wiki","为准","4",";","console","标识","8","以","it","google","代码","1","表达","bullet","下划","搜索引擎","#","…","体验","为","question","标记","##","-","引用","包括","space","单词","换行","处理","之间","中文标点","admonition","abstract","肯定","口语化","插件","success","中英","3","c",",","原因","要求","一级","warning","ide","至多","sure","省略号","词","添加","必要","空格","foofoo","spaces","其內容","以便","自动","(","表格","作为","用","nested","在","陈述",":","语句","陈述句","不","大小写","flavored"],"title":"Markdown Norm","title_tokens":["norm","markdown"," "]},{"location":"introduction/markdown-norm/#markdown","text":"采用 CTF Wiki Team 的 Markdown 编写规范。","text_tokens":["ctf","的","wiki","采用","。","规范"," ","编写","markdown","team"],"title":"Markdown 编写规范","title_tokens":["规范","markdown","编写"," "]},{"location":"introduction/markdown-norm/#_1","text":"使用 .md 后缀 文件夹、文件名使用小写，单词之间使用连字符 - 分隔 建议使用连字符而非下划线的原因是，搜索引擎会将连字符处理为两个单词，而将下划线看做一个单词。参考 Google SEO 指南 。 文档编码使用 UTF-8","text_tokens":["为","文件名","utf","的","编码","索引","，","分隔","seo","件夹","连","下划线","看做","会","-"," ","引擎","参考","8","单词","处理","使用","md","之间","google","文件夹","指南",".","。","、","建议","字符","两个","划线","原因","一个","下划","小写","搜索引擎","是","将","非","而","文档","后缀","文件","搜索"],"title":"文档格式","title_tokens":["格式","文档"]},{"location":"introduction/markdown-norm/#_2","text":"根据 MkDocs 的要求，文档中至多有一个一级标题 # ，当没有一级标题时采用目录配置中的标题作为当前页面的一级标题 章节标题从 ## 开始 章节标题在 ## 后添加空格，且之后没有 ## // bad ##章节1 // bad ## 章节1 ## // good ## 章节1 章节标题与正文间有且仅有一个空行","text_tokens":["当前","至多","根据","标题","章节","的","mkdocs","采用","，","bad","目录","添加","##"," ","且","空格","good","作为","开始","从","之后","仅","当","页面","1","一个","后","中","要求","配置","与","一级","没有","正文","间","在","#","文档","/","空行","有","时"],"title":"标题","title_tokens":["标题"]},{"location":"introduction/markdown-norm/#_3","text":"使用空行换行，尽量不适用两空格换行 部分 IDE 会在提交时自动清理行末的空格 一个段落只表达一个主题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免啰嗦、口语化的语句 需要强调的内容酌情使用 Admonition 插件 ，有 note 、 abstract 、 info 、 tip 、 success 、 question 、 warning 、 failure 、 danger 、 bug 、 example 、 quote 多种样式","text_tokens":["口语化","的","tip","酌情","插件","，","info","question","词","必要","会","适用","quote"," ","主题","删除","部分","空格","success","避免","尽量","bug","换行","自动","使用","不必要","example","段落","啰嗦","提交","需要","admonition","主动","不必","note","、","danger","样式","内容","一个","强调","表达","说法","中","两","failure","在","陈述","语句","清理","口语","warning","只","空行","ide","行末","陈述句","不","abstract","肯定","有","多种","时","语态"],"title":"段落","title_tokens":["段落"]},{"location":"introduction/markdown-norm/#_4","text":"","text_tokens":[],"title":"列表","title_tokens":["列表"]},{"location":"introduction/markdown-norm/#_5","text":"1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Baz.","text_tokens":["barbar","foofoo","baz",".","1","bar","foo"," "],"title":"有序列表无需编码","title_tokens":["无需","编码","序列表","列表","序列","有"]},{"location":"introduction/markdown-norm/#_6","text":"在有序和无需嵌套列表时使用 4 空格缩进。 1. 2 spaces after a numbered list. 4 space indent for wrapped text. 2. 2 spaces again. * 3 spaces after a bullet. 4 space indent for wrapped text. 1. 2 spaces after a numbered list. 8 space indent for the wrapped text of a nested list. 2. Looks nice, don't it? * 3 spaces after a bullet. 当没有嵌套时，也尽量使用 4 空格缩进。 * Foo, wrapped. 1. 2 spaces and 4 space indenting. 2. 2 spaces again. 当列表结构很简单时，可以在标识符后使用 1 个空格作为标记。 * Foo * Bar * Baz. 1. Foo. 2. Bar.","text_tokens":["标识符","结构","，","标记","有序","list","缩进","嵌套","4","indent","和"," ","wrapped","个","空格","after","无需","spaces","尽量","space","8","标识","the","'","列表","也","使用","2","it","foo","bar","3","a","t","作为","numbered","baz",",","again",".","of","。","当","可以","*","1","for","?","后","bullet","没有","nested","don","在","text","and","indenting","looks","简单","很","nice","时"],"title":"嵌套列表","title_tokens":["列表","嵌套"]},{"location":"introduction/markdown-norm/#_7","text":"","text_tokens":[],"title":"代码","title_tokens":["代码"]},{"location":"introduction/markdown-norm/#_8","text":"代码块使用 Fenced Block ​```js console.log(\"\"); ​``` 代码块注明语言，以便代码高亮，参见 Pygments 文档","text_tokens":["，","高亮","注明","pygments","参见","语言"," ",";","console","以便","使用","(","js","​",".","代码","块","fenced",")","block","文档","log","\"","`"],"title":"代码块","title_tokens":["代码","块"]},{"location":"introduction/markdown-norm/#_9","text":"行内代码使用反引号，且当引用文件时使用行内代码 Be sure to update your `README.md`!","text_tokens":["!","sure","，","your"," ","且","引用","反","使用","md","行内",".","当","代码","be","readme","引号","to","文件","update","`","时"],"title":"行内代码","title_tokens":["代码","行内"]},{"location":"introduction/markdown-norm/#_10","text":"以 GitHub Flavored Markdown 格式为准。 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff |","text_tokens":["left","status","为准","header","right","github","-"," ","以","markdown","second","git","content","格式","diff","。","aligned","|","center",":","flavored","first","cell"],"title":"表格","title_tokens":["表格"]},{"location":"introduction/markdown-norm/#_11","text":"","text_tokens":[],"title":"排版","title_tokens":["排版"]},{"location":"introduction/markdown-norm/#_12","text":"中英文之间需要增加空格（包括行内代码） 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格","text_tokens":["全角","增加","中英文","数字"," ","标点","空格","包括","中英","英文","之间","需要","行内","）","代码","字符","中文","其他","与","单位","（","不","加"],"title":"空格","title_tokens":["空格"]},{"location":"introduction/markdown-norm/#_13","text":"不重复使用标点符号 用直角引号 「」 代替双引号 “” 使用规范的省略号 ……","text_tokens":["的","符号","省略号","重复使用"," ","重复","标点","」","“","使用","”","用","直角","双引号","引号","代替","…","「","规范","省略","不","标点符号"],"title":"标点符号","title_tokens":["标点","符号","标点符号"]},{"location":"introduction/markdown-norm/#_14","text":"使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点","text_tokens":["的","全角","数字","，"," ","标点","其內容","使用","英文","整句","名词","中文标点","特殊","、","字符","中文","完整","半角","遇到"],"title":"全角与半角","title_tokens":["全角","半角","与"]},{"location":"introduction/markdown-norm/#_15","text":"专有名词使用正确的大小写","text_tokens":["小写","的","大小","专有名词","使用","专有","有名","正确","大小写","名词"],"title":"名词","title_tokens":["名词"]},{"location":"introduction/markdown-norm/#_16","text":"合理使用行内公式和行间公式，前后无文字的尽量使用行间公式，可以居中显示，提升阅读体验。 行内公式 $ a + b = c $ 行间公式 $$ a + b = c $$","text_tokens":["前后","的","，","和"," ","+","行间","$","尽量","使用","=","公式","提升","a","c","行内","。","无","阅读","可以","居中","b","体验","显示","合理","文字"],"title":"公式","title_tokens":["公式"]},{"location":"introduction/markdown-norm/#_17","text":"更多排版相关内容和例子请参考 中文排版指南 。","text_tokens":["参考","多","指南","相关","。","请","更","排版","中文","内容","例子","和"," "],"title":"其他","title_tokens":["其他"]},{"location":"introduction/resources/","text":"学习资源 ¶ 在线学习 ¶ js 基础学习 优质 blog ¶ ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js 书单 ¶ 敏捷开发","text_tokens":["敏捷","的","icss","学习","个人"," ","blog","days","¶","开发","书单","技巧","30","优质","js",".","在线","精通","奇淫","梁少峰","基础","资源","rx"],"title":"Learning Resources","title_tokens":["resources","learning"," "]},{"location":"introduction/resources/#_1","text":"","text_tokens":[],"title":"学习资源","title_tokens":["学习","资源"]},{"location":"introduction/resources/#_2","text":"js 基础学习","text_tokens":["学习","js","基础"," "],"title":"在线学习","title_tokens":["学习","在线"]},{"location":"introduction/resources/#blog","text":"ICss 奇淫技巧 梁少峰的个人 blog 30 days 精通 Rx.js","text_tokens":["奇淫","梁少峰","js","blog","的","30",".","days","精通","技巧","icss","个人","rx"," "],"title":"优质 blog","title_tokens":["优质","blog"," "]},{"location":"introduction/resources/#_3","text":"敏捷开发","text_tokens":["敏捷","开发"],"title":"书单","title_tokens":["书单"]},{"location":"introduction/study-thought/","text":"如何学习 ¶ 如何养成良好的学习习惯和思考习惯？ 大脑结构 ¶ 在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展 良好睡眠 ¶ 良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。 僵尸意识 ¶ cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念 组块 ¶ 组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样 怎样形成组块 ¶ 核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比 番茄工作法 ¶ 集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法 间隔重复法则 ¶ 反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触 在重复中回顾 ¶ 单一的重复难免让人乏味，你可以试着闭上眼回顾。 克服拖延症 ¶ 隔离危险的信号 养成微习惯 奖励 如何制定任务 ¶ 只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务 合理运动和学习 ¶ 人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点 思维 ¶ 多用类比和比喻 ¶ 类比和比喻有利于大脑形成组块 以终为始的思维 ¶ 举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。 批判思维 ¶ 根据已有的数据去分析去推断 即时反馈 ¶ 学得到的东西用大白话讲给别人听，你会明白更多 五分钟起步法 ¶ 遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["做事","也就是说","，","天才","时间","reward","技巧","即时","衣服","接到","法","学","因此","信号","问题","分解成","某些","如果","belief","老旧","小而","这个","让","向","然后","海马","企业","学习","知识","会","自己","穿衣","睡眠","大","脑神经","保持","能够","什么","网络","组块","别人","加强","危险","e","最好","压缩包","接受","一点","g","更好","物流","十遍","最大化",".","看法","知道","以终","是","合理","的","通人","方式","明天","如何","给予","重复","核心","」","难","¶","也","同时","可以","解决方案","意味着","「","先","并","举个","分钟","快","神经网络","复杂","只是","起步","人","高强","练习","更","代谢","记住","并且","为始","眼中","内","周末","那么","生长","方向","就是说","完","所有","了","分析","时候","最","奖励","精确","掌握","有利于","要","生成","习惯","隔离","速度","需要","闭上眼","衰弱","都","。","今天","类比","任务","多少","中","消灭","神经","这样","突触","集中","上眼","结果","？"," ","多","做","老","一些","特定","最大","25","你","难免","办法","番茄","将","下","大白话","只","最终","死亡","结构","忘记","微","而是","变","试着","回顾","然而","之后","马云","讲","已有","成","解决","普通","但是","而","产生","从而","推断","做出","细胞","遇见","至少","睡前","聪明","听","大脑神经","有助","穿衣服","发展","强度","惯性","穿","复习","方案","开始","形成","不用","以后","固化","神经网","症","而已","法则","僵尸","根据","放松","删除","分解","运动","上","成大","再谈","思考","新","单一","信息","其他","没有","routine","专注","压缩","很","结合","这是","利于","和","怎样","关联","多用","有助于","意识","克服","制定","信念","模式","这些","比喻","数据","目的","我们","给","就","精力","起来","即使","这","拖延","能","不是","智商","整个","就是","大化","栗子","大脑","刚","库存","小","集中精力","通过","性价比","思维","才能","所以","不管","再","认为","去","大白","反复","助于","普通人","一段","东西","明白","重要","脑细胞","体","世界","批判","神经元","间隔","掉","良好","事情","打包","之前","反馈","工作","执行","段时间","对","五分","cue","行为","有限","记忆","一样","以往","抽象","养成","一段时间","回忆","控制","聚合","乏味","白话","在于","新陈代谢","比如","不想","每天","用","他","在","长此以往","高强度","得到","意味","有利","五分钟","不","一遍"],"title":"Study&Thought","title_tokens":["thought","&","study"]},{"location":"introduction/study-thought/#_1","text":"如何养成良好的学习习惯和思考习惯？","text_tokens":["的","思考","良好","如何","习惯","养成","学习","？","和"],"title":"如何学习","title_tokens":["如何","学习"]},{"location":"introduction/study-thought/#_2","text":"在放松的时候，大脑神经网络会生成新的 突触 并且「删除」某些老旧的突触 因此可以通过睡前复习一遍的方式让新的突触记住某些重要信息，长此以往能够控制记忆向特定的方向发展","text_tokens":["的","放松","通过","，","方式","时候","会"," ","删除","记忆","发展","」","以往","生成","一遍","特定","记住","并且","复习","控制","脑神经","因此","能够","新","可以","信息","睡前","大脑","大脑神经","神经","某些","在","网络","长此以往","老旧","「","重要","让","向","突触","方向"],"title":"大脑结构","title_tokens":["结构","大脑"]},{"location":"introduction/study-thought/#_3","text":"良好的睡眠能加强脑细胞的新陈代谢，有利于新突触的生长 睡眠有助于大脑海马体产生新的神经元，也就是说，你变聪明了。","text_tokens":["体","的","海马","就是说","也就是说","加强","，","了","利于","神经元","细胞"," ","变","有利于","良好","睡眠","能","代谢","就是","有助于","你","。","新陈代谢","新","聪明","大脑","助于","有助","神经","生长","有利","脑细胞","产生","突触"],"title":"良好睡眠","title_tokens":["良好","睡眠"]},{"location":"introduction/study-thought/#_4","text":"cue 在你做事之前的信号 routine 惯性，在接到信号之后你的行为 reward 做出这样行为之后的结果 belief 养成信念","text_tokens":["做事","的","cue","，","行为","做出","结果"," ","reward","惯性","养成","接到","之后","你","之前","信号","信念","在","routine","belief","这样"],"title":"僵尸意识","title_tokens":["僵尸","意识"]},{"location":"introduction/study-thought/#_5","text":"组块是在集中的思维模式下的重要学习方式。将一些信息关联起来，打包成「压缩包」 以后要回忆这个组块中的所有东西，都不需要整个执行。 e.g 比如你穿衣服，你就能知道如何穿，穿什么一样","text_tokens":["集中","的","所有","方式","，","思维","如何","e","就","学习","压缩包","起来"," ","穿衣","一样","」","要","一些","g","关联","能","回忆","穿","打包","整个","需要","衣服","都",".","你","。","什么","比如","知道","信息","以后","成","中","是","将","在","下","执行","「","模式","东西","重要","这个","组块","压缩","不","穿衣服"],"title":"组块","title_tokens":["组块"]},{"location":"introduction/study-thought/#_6","text":"核心办法 分解 聚合 专注 将大的问题分解成小的问题，将小的问题反复练习从而掌握，再将小的解决方案聚合成大的解决方案，那么你最终就解决了这个问题 同时你要知道人的智商有限，世界上没有天才，我们只是普通人，这意味着接受东西的速度有限。因此保持专注才能让你的学习速度最大化，也就是知识 性价比","text_tokens":["的","世界","性价比","通人","，","了","我们","就","才能","只是","天才","接受","学习","人"," ","有限","分解","知识","核心","掌握","要","这","练习","上","大","也","再","成大","智商","速度","同时","聚合","就是","方案","保持","最大","最大化","你","大化","。","因此","知道","问题","办法","分解成","反复","解决方案","解决","普通","没有","那么","将","普通人","意味着","小","东西","这个","专注","意味","让","最终","从而"],"title":"怎样形成组块","title_tokens":["形成","组块","怎样"]},{"location":"introduction/study-thought/#_7","text":"集中精力 25 分钟，然后给予自己奖励，这是克服拖延症的最好办法","text_tokens":["给予","集中","奖励","的","办法","症","25","然后","克服","，","拖延","集中精力","这是","最好","分钟","精力","自己"," "],"title":"番茄工作法","title_tokens":["番茄","法","工作"]},{"location":"introduction/study-thought/#_8","text":"反复能够加强神经网络突触的记忆，即使是很抽象的东西重复十遍也能掌握 反复的技巧在于和番茄工作法结合起来，在一段时间内高强度的学习，然后放松一段时间，让大脑神经网络固化这些新生成突触，并忘记一些不重要的突触","text_tokens":["神经网络","的","放松","加强","，","忘记","学习","起来","和","重复"," ","高强","即使","记忆","时间","掌握","生成","也","抽象","能","强度","技巧","一段时间","一些","十遍","结合","脑神经","法","在于","能够","新","然后","工作","内","反复","大脑","番茄","大脑神经","神经","是","神经网","在","网络","一段","段时间","固化","东西","高强度","重要","并","让","这些","很","不","突触"],"title":"间隔重复法则","title_tokens":["间隔","法则","重复"]},{"location":"introduction/study-thought/#_9","text":"单一的重复难免让人乏味，你可以试着闭上眼回顾。","text_tokens":["闭上眼","的","乏味","你","上眼","难免","，","试着","回顾","。","让","单一","可以","人","重复"],"title":"在重复中回顾","title_tokens":["在","中","回顾","重复"]},{"location":"introduction/study-thought/#_10","text":"隔离危险的信号 养成微习惯 奖励","text_tokens":["奖励","的","信号","危险","微","养成","习惯","隔离"," "],"title":"克服拖延症","title_tokens":["症","拖延","克服"]},{"location":"introduction/study-thought/#_11","text":"只制定明天的任务 任务小而精确 今天做不完的任务不是明天做而是周末做 每天刚开始的时候先做最复杂难做的任务","text_tokens":["的","完","明天","复杂","时候","最"," ","精确","而是","难","做","不是","开始","今天","制定","每天","任务","周末","刚","小而","先","只","不"],"title":"如何制定任务","title_tokens":["如何","任务","制定"]},{"location":"introduction/study-thought/#_12","text":"人的大脑每天都在产生神经元，如果不用掉就会死亡，而老的神经元开始衰弱，所以每天不管学多少，至少学一点","text_tokens":["的","死亡","，","神经元","就","所以","会","人","一点","掉","不管","老","开始","至少","衰弱","都","学","不用","每天","多少","大脑","神经","在","如果","而","产生"],"title":"合理运动和学习","title_tokens":["合理","学习","运动","和"]},{"location":"introduction/study-thought/#_13","text":"","text_tokens":[],"title":"思维","title_tokens":["思维"]},{"location":"introduction/study-thought/#_14","text":"类比和比喻有利于大脑形成组块","text_tokens":["比喻","形成","有利于","有利","利于","组块","类比","和","大脑"],"title":"多用类比和比喻","title_tokens":["多用","比喻","和","类比"]},{"location":"introduction/study-thought/#_15","text":"举个栗子，我们对物流的看法只是更快而已。然而在马云眼中他认为物流的目的是消灭企业的库存。","text_tokens":["的","目的","，","企业","我们","只是","更","认为","然而","物流","马云","看法","。","栗子","眼中","他","库存","消灭","是","而已","在","对","举个","快"],"title":"以终为始的思维","title_tokens":["思维","的","以终","为始"]},{"location":"introduction/study-thought/#_16","text":"根据已有的数据去分析去推断","text_tokens":["根据","推断","的","数据","已有","分析","去"],"title":"批判思维","title_tokens":["思维","批判"]},{"location":"introduction/study-thought/#_17","text":"学得到的东西用大白话讲给别人听，你会明白更多","text_tokens":["的","多","大白","学","白话","你","，","东西","得到","大白话","讲","明白","更","别人","给","用","会","听"],"title":"即时反馈","title_tokens":["即时","反馈"]},{"location":"introduction/study-thought/#_18","text":"遇见不想做但是做了会更好的事情，先做五分钟，再谈其他","text_tokens":["分钟","的","但是","事情","再谈","，","做","先","了","五分钟","其他","五分","不想","更好","会","遇见"],"title":"五分钟起步法","title_tokens":["法","五分","五分钟","分钟","起步"]},{"location":"javascript/introduction/","text":"","text_tokens":[],"title":"Addition Concept","title_tokens":["concept","addition"," "]},{"location":"javascript/core/execute-context/","text":"执行上下文 ¶","text_tokens":["上下文","执行","上下","¶","下文"," "],"title":"Execute Context","title_tokens":["execute","context"," "]},{"location":"javascript/core/execute-context/#_1","text":"","text_tokens":[],"title":"执行上下文","title_tokens":["执行","上下","下文","上下文"]},{"location":"javascript/core/promise/","text":"","text_tokens":[],"title":"Promise","title_tokens":["promise"]},{"location":"javascript/fp/composing-functions/","text":"函数组合 ¶ 函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。 function outputs ¶ 在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。 常规函数组合 ¶ 我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念上去理解 compose pipe ¶ pipe 与 compose 相同，只不过 pipe 是从左往右 let pipe = reverseArgs ( compose ) 你可能会困惑，我们给出详细实现。 let pipe = (... fns ) => result => { let list = [... fns ] while ( list . length > 0 ) { // take the first function from the list // and execute it result = list . shift ()( result ); } return result ; }; 在某些需要 reverse 右边参数的场景，使用 pipe 会更有效率 Abstraction ¶ 抽象是一个重要的能力，他让我们的一些代码只需要写一遍。 思考 let saveComment = txt => { if ( txt != \"\" ) comments [ comments . length ] = txt ; } let trackEvent = evt => { if ( evt . name !== undefined ) { events [ evt . name ] = evt ; } } 我们可以很轻松的发现，上面代码的共性就是存储一个值 function storeData ( store , location , value ) { store [ location ] = value ; } function saveComment ( txt ) { if ( txt != \"\" ) { storeData ( comments , comments . length , txt ); } } function trackEvent ( evt ) { if ( evt . name !== undefined ) { storeData ( events , evt . name , evt ); } } 上面体现了抽象的一个原则，那就是不要重复。 但是注意抽象不要过头。 我们可以隐藏一些细节，就像黑盒子那样 但是被隐藏的细节应该是相对的，比如我们有一个相互依赖的功能 x 和 y 当我们专注 x 的时候 y 是无关紧要的 相反，我们专注 y 的时候 x 是无关紧要的。 我们抽象的目的不是隐藏细节，而是调整聚焦 。 请时刻记住，函数式编程的本质目的是写出更多可读性良好，可维护的代码。 为了分离两个概念，我们会插入一个语义级的分界，在大多数情况下，这个边界就是函数的名称。我们调用时，只在意名称和他的输出。 我们把 怎样 和 什么 分离开来 命令式编程风格说明 怎样 而声明式风格注重 什么 也就是输出，声明式关心结果，将如何实现交给别人。 声明式代码实现了从 how 到 what 的一个抽象 我们应该在声明式和命令式之间找到一个平衡。 声明式简单的将 做什么 和 如何做 分开 compose VS abstract ¶ compose 也是 声明式 的抽象 总而言之，compose 是一项非常有用的技能来将我们命令式的代码转换为可读性更好的声明式的代码。 在 FP 中 compose是极其重要的一种方式，它可能是函数间除了副作用传递数据的唯一方法。","text_tokens":["因为","功能","，","约定","值","声明","使用","技巧","reverseargs","因此","计算","不要","evt","某些","如果","这里","的话","原则","这个","最后","输出","向","然后","让","概念","现成","惰性","写出","本质","会","reduce","传递","递归","情况","outputs","abstraction","依赖","什么","*","非常","文章","维护","同样","别人","有","func2","进行","受到","touppercase","平衡","undefined","+","封装","长度","存储","length","2","更好","多数","实现","有用","fp","what",".","comments","那样","依次","是","有效率","效率","]","开来","分界","的","<","局限","尽可能","方式","如何","类似","重复","composedfn","体现","¶","也","take","trackevent","发生","函数","方块","共性","可以","how","上去","极其重要","{","唯一","轻松","res","result","可","list","只是","第三篇","user","'","更","记住","并且","off","pop","pull","困惑","样子","到","y","大多","给出","当然","级","那么","简单","一项","安全","了","finalvalue","只能","时候","最","要","喜欢","运用","无关","需要","别的","往右","welcome","。","规定","中","极其","间",")","考虑","\"","这样","尽可","first","[","时刻","这种","从左往右","调用","funcn","结果","拿到"," ","多","username","做","像","方法","详细","一些","相对","还","two","通用","origvalue","数组","copy","你","arguments","细节","rest","将","下","fn","只","最终","组成","时","一种","取出","上面","风格","具备","吧","关心","来","而是","黑盒子","=","是因为","积木","应该","一个","events","与","但是","而","reverse","从右","性能","聚焦","写","第三","args","storedata","多个","大多数","无关紧要","组合","提到","每次","甚至","边界","从","预设","长条","减小","两个","外层","请","例子","msg","式","相同","作用","技能","有效","它","找到","func1","不会","last","编程","execute","compose","vs","不用","使得","过头","库","直到","and","交给","return","隐藏","总而言之","被","容易","转换","副作用","分开","fper","可能","...",">","做作","from","partialright","toupper","思考","小方块","当","fn1","for","shift","pipe","专注","管道","很","从左到右","接收","相反","welcomeuser","这是","savecomment","和","好处","怎样","顺序","可读性","the","value","good","原","常规","相互依赖","盒子","/","传递数据","location","参数","!","数据","目的","x","返回","我们","给","就","迭代","4",";","这","不过","拼","能","if","不是","it","一份","循环","就是","插入","curry","返回值","代码","改进","function","1","为了","场景","理解","修改","只不过","为","通过","night","所以","-","分离","不再","轻易","左","系列","之间","之所以","去","能力","命令式","放在","运行","小方","lego","相互","语义","重要","那","abstract","fns","store","在意","发现","welcomeword","右边","还有","良好","说明","0","拷贝",",","之前","程序","一次","注意","关紧","把","黑盒","执行","while","}","对","当中","约定俗成","库中","name","一样","而言","紧要","除了","抽象","左边","(","作为","类型","在于","命令","比如","他","调整","txt","fn2","可读","在","三篇","名称","不","let","compose2","一遍","注重","输入"],"title":"Composing Function","title_tokens":["function","composing"," "]},{"location":"javascript/fp/composing-functions/#_1","text":"函数的组合就像拼 Lego 一样，你可以从现成的积木库中取出小方块和长条去组成程序中数据需要的管道样子。","text_tokens":["的","取出","数据","，","现成","就","和"," ","一样","拼","像","组合","去","管道","需要","函数","从","你","积木","小方块","程序","长条","方块","。","可以","样子","中","小方","lego","组成","库中"],"title":"函数组合","title_tokens":["函数","组合"]},{"location":"javascript/fp/composing-functions/#function-outputs","text":"在函数组合中，很容易发生这种情况，一个函数的输出作为下一个函数的输入传递，直到拿到最终的输出 let toUpper = msg => msg . toUpperCase () let welcome = msg => msg + 'GOOD NIGHT' let username = toUpper ( 'User' ) let welcomeUser = welcome ( username ) // 改进 let welcomeWord = msg => welcome ( toUpper ( msg )) let welcomeUser = welcomeWord ( 'User' ) 考虑一个通用的组合函数 let compose2 = ( fn2 , fn1 ) => origValue => fn2 ( fn1 ( origValue )); 注意函数的运行顺序从右向左，左边的函数在最外层最后执行。 这是大多数 FP 的库的约定俗成的规定。 需要注意的是，函数的组合需要注意类型安全，上面只是一个做作的例子。 我们可以把 2 * 2 的 Lego 放在 1 * 4 的 Lego 上面，也可以吧 1 * 4 的 Lego 放在 2 * 2 的 Lego 上面。","text_tokens":["，","我们","约定","只是","4","user",";","大多数","'","组合","改进","外层","1","大多","例子","msg","最后","输出","向","安全","night","最","左","传递","需要","情况","welcome","。","规定","*","放在","运行","中","库","lego","直到",")","考虑","这种","touppercase","welcomeword","拿到"," ","+","容易","username",">","做作","2","通用","toupper","origvalue","多数",",","fp",".","fn1","注意","把","是","下","执行","最终","很","约定俗成","的","welcomeuser","上面","这是","吧","let","顺序","也","=","左边","(","good","作为","发生","函数","类型","可以","一个","fn2","在","/","从右","compose2","输入"],"title":"function outputs","title_tokens":["outputs","function"," "]},{"location":"javascript/fp/composing-functions/#_2","text":"我们如果可以轻易的组合两个函数，那么同样的，我们也可以组合多个函数 finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue let compose = (... fns ) => res => { let list = [... fns ] while ( list . length > 0 ) { res = list . pop ()( res ) } return res } 这里之所以使用 list copy 一份函数数组是因为，如果不拷贝的话，返回的组合函数只能使用一次。 pop 方法会修改原数组，使得 fns 长度减小 然后我们可以对之前的函数进行组合。并且可以使用系列第三篇文章提到的 partialRight 来预设要组合的函数。 当然，也可以使用 curry 和 reverse 来从左到右的依次组合。 这和数组的 reduce() 方法很像，因此我们还有别的实现 compose 的方式 let compose = (... fns ) => res => [... fns ]. reverse (). reduce (( result , fn ) => fn ( result ), res ) 这样实现的好处是更具备可读性，也是 FPer 喜欢的方式，他的性能也和使用 for 循环类似。 但是这样实现每次迭代函数只能接收一个参数。 当然，我们也可以使用一个惰性函数封装 let compose = (... fns ) => fns . reverse (). reduce (( fn1 , fn2 ) => (... args ) => fn2 ( fn1 (... args ))) 在每次 reduce 中，我们不再计算函数的返回值，而是将函数作为输入传递给下一次迭代的函数。这样我们可以尽可能多的传递参数，而不用受到局限。 在这样实现 compose 的技巧当中，我们运用了 惰性计算 的方式。 这样实现在每次调用组合函数时，将不会调用 reduce 循环 甚至，我们还可以通过递归的方式去调用 compose2 方法 let compose = (... fns ) => { // pull off the last two arguments let [ fn1 , fn2 , ... rest ] = fns . reverse () let composedFn = (... args ) => fn2 ( fn1 ( ... args ) ) if ( rest . length == 0 ) return composedFn ; return compose ( ... rest . reverse (), composedFn ) } 递归的好处在于我们能从概念上去理解 compose","text_tokens":["因为","，","res","result","返回","我们","给","迭代","list","第三篇","第三","args",";","多个","这","更","使用","if","组合","技巧","提到","每次","能","一份","并且","循环","甚至","off","curry","返回值","从","pop","预设","pull","因此","减小","两个","计算","当然","那么","如果","这里","理解","的话","然后","修改","概念","通过","了","finalvalue","惰性","所以","只能","会","-","func1","reduce","要","喜欢","运用","不再","轻易","不会","系列","传递","之所以","last","递归","去","compose","性能","别的","。","不用","使得","中","文章",")","同样","这样","尽可","fns","func2","进行","[","return","受到","调用","funcn"," ","封装","长度","多","还有","fper","可能","...",">","像","0","partialright","length","方法","还","two","origvalue","实现","拷贝",",","数组","copy",".","之前","一次","fn1","arguments","for","rest","依次","是","将","下","while","}","]","对","fn","当中","很","时","从左到右","接收","的","<","局限","尽可能","方式","具备","类似","和","好处","来","而是","composedfn","可读性","the","也","=","(","是因为","作为","原","函数","在于","可以","一个","他","上去","fn2","可读","但是","三篇","在","而","reverse","/","不","参数","let","compose2","{","输入"],"title":"常规函数组合","title_tokens":["函数","常规","组合"]},{"location":"javascript/fp/composing-functions/#pipe","text":"pipe 与 compose 相同，只不过 pipe 是从左往右 let pipe = reverseArgs ( compose ) 你可能会困惑，我们给出详细实现。 let pipe = (... fns ) => result => { let list = [... fns ] while ( list . length > 0 ) { // take the first function from the list // and execute it result = list . shift ()( result ); } return result ; }; 在某些需要 reverse 右边参数的场景，使用 pipe 会更有效率","text_tokens":["只不过","的","[","return","，","从左往右","result","我们","list","会"," ",";","右边","不过","可能","...",">","take","0","详细","length","=","the","from","it","使用","更","(","execute","compose","需要","实现","有效","你",".","往右","reverseargs","困惑","。","first","function","给出","与","相同","是","shift","某些","在",")","场景","效率","有效率","while","and","/","pipe","]","}","reverse","参数","let","fns","{"],"title":"pipe","title_tokens":["pipe"]},{"location":"javascript/fp/composing-functions/#abstraction","text":"抽象是一个重要的能力，他让我们的一些代码只需要写一遍。 思考 let saveComment = txt => { if ( txt != \"\" ) comments [ comments . length ] = txt ; } let trackEvent = evt => { if ( evt . name !== undefined ) { events [ evt . name ] = evt ; } } 我们可以很轻松的发现，上面代码的共性就是存储一个值 function storeData ( store , location , value ) { store [ location ] = value ; } function saveComment ( txt ) { if ( txt != \"\" ) { storeData ( comments , comments . length , txt ); } } function trackEvent ( evt ) { if ( evt . name !== undefined ) { storeData ( events , evt . name , evt ); } } 上面体现了抽象的一个原则，那就是不要重复。 但是注意抽象不要过头。 我们可以隐藏一些细节，就像黑盒子那样 但是被隐藏的细节应该是相对的，比如我们有一个相互依赖的功能 x 和 y 当我们专注 x 的时候 y 是无关紧要的 相反，我们专注 y 的时候 x 是无关紧要的。 我们抽象的目的不是隐藏细节，而是调整聚焦 。 请时刻记住，函数式编程的本质目的是写出更多可读性良好，可维护的代码。 为了分离两个概念，我们会插入一个语义级的分界，在大多数情况下，这个边界就是函数的名称。我们调用时，只在意名称和他的输出。 我们把 怎样 和 什么 分离开来 命令式编程风格说明 怎样 而声明式风格注重 什么 也就是输出，声明式关心结果，将如何实现交给别人。 声明式代码实现了从 how 到 what 的一个抽象 我们应该在声明式和命令式之间找到一个平衡。 声明式简单的将 做什么 和 如何做 分开","text_tokens":["聚焦","!","轻松","功能","，","x","目的","可","我们","写","就","storedata",";","值","大多数","无关紧要","声明","更","不是","if","记住","就是","插入","边界","从","代码","请","两个","function","到","y","大多","不要","evt","式","级","为了","原则","这个","让","输出","注重","简单","概念","了","找到","写出","时候","本质","会","分离","之间","编程","无关","需要","能力","命令式","情况","。","依赖","什么","过头","维护",")","相互","语义","重要","\"","那","别人","有","store","在意","交给","[","发现","时刻","调用","结果","平衡","undefined","隐藏"," ","被","多","分开","良好","说明","存储","做",">","像","一些","length","相对","多数","实现",",","what","思考",".","当","comments","细节","注意","关紧","那样","黑盒","是","把","将","下","}","]","只","专注","开来","很","时","name","分界","相反","的","上面","风格","如何","关心","savecomment","和","重复","怎样","而是","可读性","紧要","体现","也","抽象","黑盒子","=","value","(","trackevent","函数","相互依赖","命令","共性","盒子","可以","应该","比如","how","一个","他","events","调整","txt","可读","但是","在","而","名称","location","let","一遍","{"],"title":"Abstraction","title_tokens":["abstraction"]},{"location":"javascript/fp/composing-functions/#compose-vs-abstract","text":"compose 也是 声明式 的抽象 总而言之，compose 是一项非常有用的技能来将我们命令式的代码转换为可读性更好的声明式的代码。 在 FP 中 compose是极其重要的一种方式，它可能是函数间除了副作用传递数据的唯一方法。","text_tokens":["一种","为","的","它","数据","一项","，","方式","我们","总而言之"," ","来","转换","可读性","副作用","而言","声明","除了","可能","也","方法","抽象","传递","更好","compose","有用","命令式","fp","函数","命令","。","代码","非常","中","式","极其","间","是","可读","将","在","作用","技能","极其重要","重要","传递数据","唯一"],"title":"compose VS abstract","title_tokens":["compose","vs","abstract"," "]},{"location":"javascript/fp/manage-function-inputs/","text":"一元函数 ¶ 给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar ) 参数的解构和聚合 ¶ 某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15 偏函数 ¶ let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs ) 柯里化 ¶ 柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度 为什么使用柯里化和偏函数？ ¶ 提高可读性 拆分会扰乱可读性的其他参数信息 更宽松的柯里化 ¶ 事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([]) 取消柯里化 ¶ let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数 高级实现 ¶ 上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器 Point Style ¶ 当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["因为","obj","功能","，","操作","他们","拆分","值","偏","声明","使用","技巧","arg","foo","内部","人们","reverseargs","因此","shit","某些","如果","这个","log","让","向","然后","仍然","propsobj","nextcurry","这一","会","curryprops","reduce","过滤","time","传递","then","优化","情况","什么","now","帮助","v1","有","nan","位置","touppercase","下文","+","长度","all","提高","length","2","params","如下","实现","addthree",".","of","看起","编写","叫做","unary","参数传递","point","是","filter","]","words","v","过瘾","的","<","方式","不定","upper","如何","类似","」","¶","也","nextparam","同时","内置","另","函数","数量","可以","api","spreadargs","「","并","举个","{","脑子","高级","则","反转","那个","onresult","可","user","'","更","promise","5","uncurry","s","柯里化","cacheresult","y","当然","b","那么","nowobjprops","isshortenough","花哨","split","时候","只能","最","assign","只有","喜欢","要","没","开发","some","需要","别的","都","。","判断","中","nextobjprops",")","http","identity","\"","考虑","这样","看起来","传入","presetpropsobj","formatfn","_","[","调用","拿到","？"," ","hello","宽松","做","像","方法","还","呢","js","current","期望","你","不太","扰乱","幸好","|","将","下","fn","只","前面","应用","上面","上下","风格","很多","来","数传","=","必须","一个","但是","reverse","不能","更改","参数信息","按照","又","写","error","nextargs","如","args","len","一元函数","bar","每次","遇见","甚至","来看","无法","两个","例子","msg","器","presetargs","应有","它","loosecurry","一起","口中","一元","prevparam","直接","编程","partialprops","prevargs","keys","开发者","可是","使得","world","砍掉","多余","return","原封","parseint","转换","argsarr","fper","可能","...",">","partialright","ajax","为什么","当","单一","兼容","信息","object","其他","for","output","没有","上下文","原封不动","很","cache","接收","相反","this","islongenough","和","解构","顺序","避免","可读性","the","列表","绑定","p2","穿透","15","12","promise1","/","not","constant","参数","!","strict","is","x","返回","我们","给","就","4","起来",";","console","这","不过","能","if","不是","curry","代码","栗子","function","1","9","map","partial","场景","理解","bind","nextcurried","later","只不过","转发","为","person","通过","事实上","事实","轻易","再","基于","手动","v2","重要","gatherargs","取消","但","\\","props","右边","看","success","laterargs","还有","else","3",",","之前","一次","style","注意","把","}","ret","没法","传递函数","id","tostring","装饰","不动","完全","(","聚合","反向","比如","combinefirsttwo","用","txt","可读","在",":","下面","不","let"],"title":"Manage Function Inputs","title_tokens":["inputs"," ","function","manage"]},{"location":"javascript/fp/manage-function-inputs/#_1","text":"给函数单一的参数 这样做可以避免参数穿透，举个栗子 [ '1' , '2' , '3' ]. map ( parseInt ) // [1, NaN, NaN] 我们可以写一个帮助函数来过滤多余的参数 let unary = fn => arg => fn ( arg ) [ '1' , '2' , '3' ]. map ( unary ( parseInt )) 甚至你还可以用的更花哨 来看下面这个函数 let identity = v => v ; 这个函数看起来就像人们口中的 shit 但是只有脑子 shit 的开发者 let words = \" Now is the time for all... \" . split ( /\\s|\\b/ ) words // [\"\",\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\",\"\"] words . filter ( identity ) // [\"Now\",\"is\",\"the\",\"time\",\"for\",\"all\",\"...\"] 还不过瘾？再看下面这个 let output = ( msg , formatFn = identity ) => { msg = formatFn ( msg ) console . log ( msg ) } let upper = txt => txt . toUpperCase () output ( \"Hello World\" , upper ) // HELLO WORLD output ( \"Hello World\" ) // Hello World 一元函数还有别的方式，比如某些不能传递值参数但能传递函数的方法 如 js 中的 Promise 的 then 方法 // error promise1 . then ( foo ). then ( p2 ). then ( bar ) // success promise1 . then ( foo ). then (() => p2 ). then ( bar ) 我们可以写一个值转换函数 let constant = v => () => v promise1 . then ( foo ). then ( constant ( v )). then ( bar )","text_tokens":["脑子","，","is","我们","写","给","就","error","起来","如",";","值","console","'","更","能","promise","一元函数","arg","bar","foo","甚至","s","来看","人们","shit","栗子","1","msg","b","某些","map","这个","log","花哨","split","只有","过滤","口中","一元","开发","再","time","传递","别的","then","now","开发者","中","world",")","帮助","多余","identity","\"","这样","看起来","nan","formatfn","但","[","\\","touppercase","？"," ","hello","parseint","看","success","all","还有","转换","...","做",">","像","方法","2","还","3","js",",",".","你","看起","单一","for","unary","output","|","filter","}","]","fn","v","words","过瘾","的","传递函数","方式","upper","来","避免","the","=","(","p2","函数","穿透","可以","比如","一个","用","txt","但是","promise1","下面","/","constant","举个","不能","不","参数","let","{"],"title":"一元函数","title_tokens":["一元","函数","一元函数"]},{"location":"javascript/fp/manage-function-inputs/#_2","text":"某些时候，你会有两个不兼容的函数，在无法更改声明的情况下，如何一起使用他们呢？ let foo = ( x , y ) => console . log ( x + y ) let bar = fn => fn ([ 3 , 9 ]) bar ( foo ) // error let spreadArgs = fn => argsArr => fn (... argsArr ) bar ( spreadArgs ( foo )) // 12 考虑反向操作 let gatherArgs = fn => (... argsArr ) => fn ( argsArr ) let combineFirstTwo = ([ v1 , v2 ]) => v1 + v2 [ 1 , 2 , 3 , 4 , 5 ]. reduce ( gatherArgs ( combineFirstTwo )) // 15","text_tokens":["的","[","，","x","操作","如何","他们","error","不","时候","会","？","4"," ","+","一起","reduce","console","argsarr","声明","...",">","使用","=","2","5","呢","foo","bar","(","3","反向",",","函数","你",".","情况","无法","两个","15","兼容","combinefirsttwo","1","y","12","9","某些","在",")","下","spreadargs","v2","/","fn","log","]","考虑","v1","更改","let","有","gatherargs"],"title":"参数的解构和聚合","title_tokens":["聚合","的","参数","和","解构"]},{"location":"javascript/fp/manage-function-inputs/#_3","text":"let partial = ( fn ,... presetArgs ) => (... laterArgs ) => fn (... presetArgs , ... laterArgs ) js 中的 bind 也可实现上面的功能，但是 FPer 不太喜欢，因为绑定 this 上下文和偏函数应用很多时候并不同时需要这两个功能 反转参数 let reverseArgs = fn => (... args ) => fn (... args . reverse ()) let cache = {}; let cacheResult = reverseArgs ( partial ( reverseArgs ( ajax ), function onResult ( obj ){ cache [ obj . id ] = obj }) ) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID }) 某些场景下，你只需要反转最右边的参数，因此可以编写一个基于反转参数的函数 function partialRight ( fn ,... presetArgs ) { return reverseArgs ( partial ( reverseArgs ( fn ), ... presetArgs . reverse ()) ) } let cacheResult = partialRight ( ajax , function onResult ( obj ){ cache [ obj . id ] = obj }) // later: cacheResult ( \"http://some.api/person\" , { user : CURRENT_USER_ID } ) 当然，可以用更直接的技巧 let partialRight = ( fn ,... presetArgs ) => (... laterArgs ) => fn ( ... laterArgs , ... presetArgs )","text_tokens":["因为","obj","反转","功能","，","onresult","可","user","args",";","偏","这","更","技巧","reverseargs","cacheresult","因此","两个","function","当然","某些","partial","场景","bind","presetargs","later","person","时候","最","喜欢","直接","基于","some","需要","中",")","http","\"","_","[","return","下文"," ","右边","laterargs","fper","...",">","partialright","ajax","js","current","实现",",",".","不太","你","编写","上下文","下","}","fn","]","只","cache","应用","的","上面","上下","id","this","很多","和","也","=","(","绑定","同时","函数","可以","一个","用","api","但是",":","reverse","/","并","不","参数","let","{"],"title":"偏函数","title_tokens":["函数","偏"]},{"location":"javascript/fp/manage-function-inputs/#_4","text":"柯里化和偏函数很像，只不过柯里化每次都只接收一个参数，然后将参数传递给下一次调用，考虑如下代码 let curry = ( fn , len = fn . length ) => ( nextCurry = prevParam => nextParam => { let params = [... prevParam , nextParam ] if ( params . length >= len ) { return fn (... params ) } else { return nextCurry ( params ) } })([]) 上面的 len 不是必须要传递的参数，但是当你要 curry 的函数是不定参数的函数，则需要手动传入一个期望长度","text_tokens":["只不过","接收","nextcurry","的","则","[","return","上面","，","不定","调用","给","和"," ","长度","偏","要","不过","数传","...","像",">","length","len","=","prevparam","if","params","传递","每次","如下","nextparam","(","很","else","不是","传入","需要","期望",",","函数","都","curry","柯里化",".","一次","当","你","代码","必须","一个","参数传递","是","手动","将","但是",")","下","}","fn","考虑","只","]","然后","参数","let","{"],"title":"柯里化","title_tokens":["柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_5","text":"提高可读性 拆分会扰乱可读性的其他参数信息","text_tokens":["参数信息","可读","的","可读性","参数","提高","扰乱","信息","拆分","其他","会"," "],"title":"为什么使用柯里化和偏函数？","title_tokens":["为什么","偏","函数","柯里化","什么","使用","？","和"]},{"location":"javascript/fp/manage-function-inputs/#_6","text":"事实上 js 内部实现的柯里化都是这样，上面我们实现的柯里化可以理解为「strict」 let looseCurry = ( fn , len = fn . length ) => ( nextCurried = prevArgs => (... nextArgs ) => { let args = [... prevArgs , ... nextArgs ] if ( args . length >= len ) { return fn (... args ) } else { return nextCurried ( args ) } } )([])","text_tokens":["为","的","[","上面","return","strict","，","事实上","我们","loosecurry","nextargs"," ","args","」","事实","...",">","length","len","=","if","else","(","js","内部","实现","prevargs",",","都",".","柯里化","可以","是",")","理解","「","}","fn","]","nextcurried","这样","let","{"],"title":"更宽松的柯里化","title_tokens":["宽松","更","的","柯里化"]},{"location":"javascript/fp/manage-function-inputs/#_7","text":"let unCurry = fn => (... args ) => { let ret = fn for ( let arg of args ) { ret = ret ( arg ) } return ret } 需要注意的是，当你没有向取消柯里化中传入应有数量的参数，返回的仍然是一个偏函数","text_tokens":["的","return","，","返回"," ","args","偏","...",">","=","arg","传入","uncurry","(","需要","函数","你","柯里化","数量","of","当","一个","注意","for","中","是","没有",")","}","应有","fn","ret","向","参数","let","仍然","{","取消"],"title":"取消柯里化","title_tokens":["柯里化","取消"]},{"location":"javascript/fp/manage-function-inputs/#_8","text":"上面的柯里化和偏函数都只能按照参数的顺序，开发者不可能每次都 reverse 参数 考虑下面的代码 它使得参数的位置没那么重要 let partialProps = ( fn , presetPropsObj ) => propsObj => fn ( Object . assign ({}, presetPropsObj , propsObj )) let curryProps = ( fn , len = 1 ) => ( nextCurried = nowObjProps => ( nextObjProps = {}) => { let props = Object . assign ({}, nowObjProps , nextObjProps ) if ( Object . keys ( props ). length >= len ){ return fn ( props ) } else { return nextCurried ( props ) } } )({}) 可是有的时候我们没法更改传入的函数的参数，这使得我们不能轻易的使用解构。 幸好 js 有一个内置方法叫做 toString() 可以让我们拿到函数的参数列表，再通过类似前面 spreadArgs 的转换，实现一个函数装饰器","text_tokens":["按照","，","我们","不","偏","这","len","if","使用","每次","柯里化","代码","1","那么","器","nextcurried","让","nowobjprops","propsobj","它","通过","只能","时候","curryprops","assign","没","轻易","开发","再","partialprops","都","。","keys","开发者","可是","使得","nextobjprops",")","重要","考虑","传入","presetpropsobj","有","return","位置","props","拿到"," ","转换","可能",">","方法","length","else","js","实现",",",".","幸好","object","叫做","}","fn","前面","的","没法","上面","tostring","装饰","类似","和","解构","顺序","列表","=","(","内置","函数","可以","一个","spreadargs","下面","reverse","不能","更改","参数","let","{"],"title":"高级实现","title_tokens":["高级","实现"]},{"location":"javascript/fp/manage-function-inputs/#point-style","text":"当我们遇见某些函数，他们接收参数，并将参数原封不动的 转发 给另一个函数，我们可以把它砍掉 let addThree = v => v + 3 [ 1 , 2 , 3 , 4 , 5 ]. map ( v => addThree ( v )) // 优化 [ 1 , 2 , 3 , 4 , 5 ]. map ( addThree ) 如果是之前 parseInt() 的那个例子，则可以通过 unary 方法实现这一编程风格 又比如你有两个完全相反的判断 let isShortEnough = msg => msg . length <= 5 let isLongEnough = msg => msg . length > 5 // let not = fn => (... args ) => ! fn (... args ) let isLongEnough = not ( isShortEnough )","text_tokens":["转发","!","接收","这一","的","则","它","[","那个","原封","通过","相反","，","<","风格","isshortenough","我们","他们","又","给","不动","4","islongenough"," ","+","args","parseint","...",">","方法","length","2","=","5","完全","编程","遇见","3","(","实现","addthree","另","函数",",",".","优化","之前","你","当","两个","可以","比如","1","一个","判断","例子","unary","msg","把","是","某些","将","砍掉","map",")","如果","/","not","原封不动","]","并","v","fn","参数","let","有"],"title":"Point Style","title_tokens":["style","point"," "]},{"location":"javascript/fp/nature-function/","text":"学习函数式编程，我们需要清晰地意识到 函数的定义不是通过 function 关键字声明一个函数 函数式编程本质上是通过使用 函数 让代码变得 函数化 那么，函数的 本质 到底是什么？ 什么是函数 ¶ 常规定义 ¶ 一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明 数学角度 ¶ 一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」 函数式编程和「面向过程」编程的区别 ¶ 函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出 js 中的函数的能力 ¶ 解构赋值 ¶ 解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用 闭包 ¶ 应用到偏函数和 curry 上 匿名函数 ¶ 尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read 惰性表达式 ¶ 后面的文章会说到。","text_tokens":["因为","或","达式","则","数据","，","x","返回","我们","过程","给","字符串","多个","隐含","值","偏","bug","声明","映射","更","不是","使用","赋值","if","并且","清晰","临时","至少","curry","返回值","输入输出","变差","代码","跟踪","function","到","y","值得","表达","开发人员","式","那么","作用","todo","如果","read","这会","匿名","的话","定义","这个","让","输出","最后","修改","不赋","为","它","化","通过","当有","稳定","惰性","或者","学习","本质","区别","时候","个","会","只有","部分","包括","引用","造成","数据流","表达式","喜欢","开发","入","片段","传递","编程","递归","说","需要","能力","空","情况","什么","。","多次","字符","不同","中","coding","文章","一段",")","闭包","或是","尽可","有","对象","写法","return","到底","这种","交易","调用","最好","？","参是","关键"," ","关键字","副作用","可能","存储",">","上","else","命名","js","后面",",","你",".","一次","一部","当","知道","原因","元","清楚","叫做","显式","把","是","没有","人员","明显","面向","执行","}","when","fn","只","用来","堆栈","很","角度","前面","过于","应用","name","更新","数学","一定","包含","的","取出","加上","一部分","尽可能","pain","名","不传","如何","发人","准确","自","和","解构","可读性","」","¶","也","抽象","用途","=","变量","(","n","是因为","函数","意识","常规","easy","更加","可以","外部","一个","调试","用","可读","但是","变得","在","「","含有","/","确保","未来","这些","不","参数","let","地","{","输入"],"title":"Nature Function","title_tokens":["nature","function"," "]},{"location":"javascript/fp/nature-function/#_1","text":"","text_tokens":[],"title":"什么是函数","title_tokens":["什么","函数","是"]},{"location":"javascript/fp/nature-function/#_2","text":"一段可以执行一次或者多次的代码片段，这些片段使用 function 关键字声明","text_tokens":["关键","的","关键字","一段","执行","声明","一次","，","代码","可以","多次","这些","或者","使用","function","片段"," "],"title":"常规定义","title_tokens":["定义","常规"]},{"location":"javascript/fp/nature-function/#_3","text":"一个函数包含一个准确的 输入 和一个准确的 输出 输入输出可以有 一个或多个 值，但是不同的输入，输出不同 我们也可以把「函数」叫做「映射」 我们把含有 n 个输入的函数叫做「n 元函数」","text_tokens":["或","包含","的","，","我们","准确","和"," ","个","多个","值","」","也","映射","n","函数","输入输出","可以","一个","元","叫做","不同","把","但是","「","含有","输出","有","输入"],"title":"数学角度","title_tokens":["数学","角度"]},{"location":"javascript/fp/nature-function/#_4","text":"函数式编程中的函数有 稳定 的输入输出 面向过程编程则不一定，可能 没有 输出","text_tokens":["一定","的","则","，","稳定","过程"," ","可能","编程","函数","输入输出","中","式","没有","面向","输出","不","有","输入"],"title":"函数式编程和「面向过程」编程的区别","title_tokens":["式","的","函数","面向","」","「","过程","区别","编程","和"]},{"location":"javascript/fp/nature-function/#js","text":"","text_tokens":[],"title":"js 中的函数的能力","title_tokens":["js","的","能力","函数"," ","中"]},{"location":"javascript/fp/nature-function/#_5","text":"解构赋值可以让我们取出并且命名参数对象中的一部分 let fn = ({ x , y } = {}) => { // 这种写法可以不传参数 // 如果不赋一个空对象则至少需要传递一个参数 } 当返回值有多个的时候，使用解构可以让数据流更加明显和清晰 一个函数最好只有一个 return ，当有多个 if() {} else {} 的时候，可以用临时变量存储返回值，最后返回它 开发人员更喜欢显式代码，包括显式的输入输出，不喜欢隐含的修改外部变量，因为这会让可读性变差和造成副作用","text_tokens":["因为","则","数据","x","，","返回","我们","多个","隐含","更","使用","if","赋值","并且","清晰","临时","至少","返回值","输入输出","变差","代码","y","开发人员","作用","如果","这会","让","最后","输出","修改","不赋","它","当有","时候","只有","部分","包括","造成","数据流","喜欢","开发","传递","需要","空","中",")","有","对象","写法","return","这种","最好"," ","副作用","存储",">","else","命名",",","一部","当","显式","人员","明显","}","fn","取出","的","一部分","不传","发人","和","解构","可读性","=","变量","(","函数","更加","可以","外部","一个","用","可读","/","不","参数","let","{","输入"],"title":"解构赋值","title_tokens":["赋值","解构"]},{"location":"javascript/fp/nature-function/#_6","text":"应用到偏函数和 curry 上","text_tokens":["偏","函数","curry","上"," ","到","和","应用"],"title":"闭包","title_tokens":["闭包"]},{"location":"javascript/fp/nature-function/#_7","text":"尽可能的给匿名函数命名，如果你需要跟踪 堆栈调用情况 调试 bug 的话 如果函数入参是匿名函数，调用 fn.name 会返回一个空字符串 匿名函数命名可以用来 自引用 递归 在不知道如何给匿名函数命名的时候，原因只可能是因为你不清楚这个函数的用途或是这个函数过于抽象 可以在函数名前面加上 todo 确保未来会更新函数命名 为函数命名是一个很值得的交易，when easy coding, pain read","text_tokens":["因为","为","的","pain","加上","尽可能","名","，","交易","调用","返回","如何","更新","自","给","时候","会","参是","字符串"," ","引用","bug","可能","抽象","用途","入","when","递归","前面","很","命名","是因为","需要",",","函数","你",".","情况","空","跟踪","easy","字符","可以","知道","一个","原因","调试","清楚","值得","coding","是","todo","在","如果","read","匿名","的话","fn","这个","只","用来","确保","堆栈","未来","不","或是","尽可","过于","name"],"title":"匿名函数","title_tokens":["函数","匿名"]},{"location":"javascript/fp/nature-function/#_8","text":"后面的文章会说到。","text_tokens":["说","文章","后面","的","。","到","会"],"title":"惰性表达式","title_tokens":["达式","表达","惰性","表达式"]},{"location":"javascript/fp/side-effect/","text":"写一个没有副作用的程序是不可能的。但是我们可以尽可能的限制他们。 思考下面的代码 function foo ( x ) { y = x * 2 ; } var y ; foo ( 3 ); //// function foo ( x ) { return x * 2 ; } var y = foo ( 3 ); 很明显前者是 因 果 不相关的，因此可读性很差，这也就是我们所说的副作用 当函数引用了一个自身之外的变量时，这个变量叫做 自由变量 并不是所有的 自由变量 都会带来负面影响，但是我们应当要小心。 了解副作用 ¶ 副作用意味着您的代码读者需要人肉编译你的代码才能知道某个变量的变化。比如你在某个函数中修改了某个外部变量 副作用还有可能是因为你在返回值中的引用，如果引用的状态发生了变化，函数就产生了副作用。因此，所有影响到函数输出的东西都应该作为函数的输入 固定状态 ¶ 一个约定俗称的规矩是从不覆盖函数实现，因此函数作为自由变量引用，我们可以当做我们引用了一个常量。 考虑两点，当你有一个函数时 当你给定输入，输出是不变的吗？ 你引入的自由变量每次都是不变的吗？程序中有其他地方可能会修改这个自由变量吗？ 偶然性 ¶ 随机函数也可能产生副作用。 大部分语言中的随机都是采用伪随机算法，有些语言提供了起始值，因此给定相同的起始值生成的随机序列都是一致的。 但是 js 没有提供这项功能，因此 js 中偶然性也是副作用的一种 IO Effects ¶ 最常见的副作用就是 IO 输入输出 比如 DOM，当我们修改了 DOM 事实上就已经产生了副作用 再比如两个依赖自由变量的 ajax，当异步请求的时候，如果回调执行的顺序不一致，可能会产生 bug，但是我们难以捕捉他们，因为很多时候，这些 bug 只会带来 ui 渲染上的不一致，或者只是简单的状态改变。 制裁副作用 ¶ 如果你不得不通过副作用修改状态，制裁他们的一种方式是 幂等性 幂等性 ¶ 首先给出一个在 数学 上和 编程 上都 不属于 幂等的例子 function updateCounter ( obj ) { if ( obj . count < 10 ) { obj . count ++ ; return true ; } return false ; } 数学上的幂等性 ¶ 从数学角度来看，幂等性意味着在第一次调用后输出不会改变的操作。 更清晰的例子 f(x) = f(f(x)) = f(f(f(x))) 在 js 内置的 Math 库中，下面这些例子显然是幂等性的。 Math.min(..) Math.max(..) Math.round(..) Math.floor(..) Math.ceil(..) 我们也可以自己定义一些幂等性的运算 function toPower0 ( x ) { return Math . pow ( x , 0 ); } function snapUp3 ( x ) { return x - ( x % 3 ) + ( x % 3 > 0 && 3 ); } toPower0 ( 3 ) == toPower0 ( toPower0 ( 3 ) ); // true snapUp3 ( 3.14 ) == snapUp3 ( snapUp3 ( 3.14 ) ); // true 数学角度的幂等性并不仅仅局限于数学运算，来看看 js 基本类型强制转换 var x = 42 , y = \"hello\" ; String ( x ) === String ( String ( x ) ); // true Boolean ( y ) === Boolean ( Boolean ( y ) ); // true 或者是 function upper ( x ) { return x . toUpperCase (); } function lower ( x ) { return x . toLowerCase (); } var str = \"Hello World\" ; upper ( str ) == upper ( upper ( str ) ); // true lower ( str ) == lower ( lower ( str ) ); // true 总而言之，幂等性就是满足下列公式的数学表达式 f(x) = f(f(x)) 程序中的幂等性 ¶ 程序中的幂等性没有那么正式，换句话说，第一次调用 f(x) 与第二次调用的返回值没有区别。 就像在 Http 的 RESTapi 中，PUT 被定义为更新服务器资源，当我们发送了多个带有相同数据的 PUT 时，服务器资源都应该具有相同的结果状态 // idempotent:幂等性 obj . count = 2 ; a [ a . length - 1 ] = 42 ; person . name = upper ( person . name ); // non-idempotent:非幂等性 obj . count ++ ; a [ a . length ] = 42 ; person . lastUpdated = Date . now (); 在这里，幂等性的概念是，在第一次调用之后，后续无论怎样的重复调用，程序状态都不会改变。而非幂等性每次调用都会更改程序状态。 那么在 DOM 更新中如何表现呢？ var hist = document . getElementById ( \"orderHistory\" ); // idempotent: hist . innerHTML = order . historyText ; // non-idempotent: var update = document . createTextNode ( order . latestUpdate ); hist . appendChild ( update ); // 隐式的，当前状态是下一状态的一部分 我们并不能总是幂等的定义我们的操作，但这有利于减少副作用的影响 Pure Bliss ¶ 一个没有副作用的函数我们称之为 Pure Function 纯函数在编程角度来说是幂等的，因为没有任何副作用 let add = ( a , b ) => a + b 可以发现所有的输入输出都是直接的，没有引用任何自由变量，多次调用 add 函数与只调用一次没有任何区别。所以 add 是一个幂等纯函数。 但是在数学意义中，不是所有纯函数都是幂等的，因为他们不必返回适合他们的输入的输出。 function calculateAverage ( nums ) { var sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } calculateAverage ( [ 1 , 2 , 4 , 7 , 11 , 16 , 22 ] ); // 9 返回值并非一个数组，因此不可能 calculateAverage(calculateAverage(nums)) 纯函数也可以引用自由变量和函数值，只要这个变量是没有副作用的。 const PI = 3.141592 ; function circleArea ( radius ) { return PI * radius * radius ; } function cylinderVolume ( radius , height ) { return height * circleArea ( radius ); } 另一个纯函数引用自由变量的例子就是 闭包 虽然 fn 是一个函数对象，我们可以给他分配属性「突变」，但是这不影响函数值调用，因此只要不重新分配函数，他就无副作用。 表达纯函数的另一种方式是，给他相同的输入，他总是产生相同的输出。 如果一个函数给相同的输入产生不同的输出，那么就不是一个纯函数。产生副作用也是不纯的。 在 js 中，产生副作用实在是太容易了。 Purely Relative ¶ function rememberNumbers ( nums ) { return function caller ( fn ){ return fn ( nums ); }; } var list = [ 1 , 2 , 3 , 4 , 5 ]; var simpleList = rememberNumbers ( list ); simpleList 看起来像是一个纯函数，实际上并不是， function median ( nums ) { return ( nums [ 0 ] + nums [ nums . length - 1 ]) / 2 ; } simpleList ( median ); // 3 // .. list . push ( 6 ); // .. simpleList ( median ); // 3.5 显而易见，当我们修改数组，他的返回值就发生了变化。 我们可以通过复制数组让他变成纯函数。 function rememberNumbers ( nums ) { // make a copy of the array nums = [... nums ]; return function caller ( fn ){ return fn ( nums ); }; } 但是可能会有一个更隐蔽的副作用潜伏。 var list = [ 1 , 2 , 3 , 4 , 5 ]; // make `list[0]` be a getter with a side effect Object . defineProperty ( list , 0 , { get : function (){ console . log ( \"[0] was accessed!\" ); return 1 ; } } ); var simpleList = rememberNumbers ( list ); // [0] was accessed! 因此，我们可以通过这样 function rememberNumbers (... nums ) { return function caller ( fn ){ return fn ( nums ); }; } var simpleList = rememberNumbers ( ... list ); // [0] was accessed! 这样做的好处是，rememberNumbers 是纯函数，造成副作用的原因在于 ... 纯函数 + 不纯函数 = 不纯函数 // yes, a silly contrived example :) function firstValue ( nums ) { return nums [ 0 ]; } function lastValue ( nums ) { return firstValue ( nums . reverse () ); } simpleList ( lastValue ); // 5 list ; // [1,2,3,4,5] -- OK! simpleList ( lastValue ); // 1 reverse() 方法其实修改了原本的数组 所以我们可以这样做 function rememberNumbers (... nums ) { return function caller ( fn ){ // send in a copy! return fn ( [... nums ] ); }; } 传递一个复制了的数组来避免接受的函数在行为上改变原数组。 但是我们仍然无法保证我们传递一个不纯的函数进去。因此，我们只能尽量的让函数 pure，这能提高可读性 Referential transparency ¶ 判断一个函数是否纯净的第三种方式，是 Referential transparency。如果将一个函数和他的输出对换，行为上没有任何变化，那么就是纯函数。","text_tokens":["因为","latestupdate","obj","hist","功能","，","操作","他们","约定","正式","显而易见","值","innerhtml","historytext","编译","显然","像是","foo","non","var","因此","果","第二次","如果","读者","这里","不纯","这个","order","让","输出","第一次","log","idempotent","..","simplelist","仍然","概念","服务器","突变","重新","会","自己","height","大部分","强制","get","true","易见","传递","影响","依赖","now","put","*","6","in","add","false","分配","闭包","变成","属性","有","22","`","称之为","偶然","yes","touppercase","实在","接受","+","提高","length","2","pi","不得不","实现","16",".","伪","of","看起","知道","叫做","改变","accessed","是","snapup3","非","来说","原本","]","11","角度","状态","首先","的","<","局限","尽可能","方式","upper","如何","floor","重复","纯净","」","具有","也","¶","median","firstvalue","看看","负面","发生","只会","内置","另","函数","等","lastupdated","可以","appendchild","意味着","「","限制","任何","无副作用","并","%","第一","服务","{","小心","起始","side","list","只是","人","bug","渲染","后续","was","make","更","请求","5","地方","公式","circlearea","dom","清晰","固定","getelementbyid","bliss","到","y","给出","effects","表现","幂","b","那么","定义","简单","序列","常量","tolowercase","这能","radius","相关","所有","了","实际上","或者","很差","时候","只能","语言","最","部分","表达式","要","有利于","生成","createtextnode","a","需要","都","&&","是否","。","判断","中","ceil",")","http","难以","考虑","\"","看起来","这样","尽可","起始值","保证","当前","对象","中有","3.14","[","采用","不仅仅","调用","结果","偶然性","？"," ","hello","某个","做","像","方法","一些","呢","js","nums","数组","copy","你","一部","总是","是从","后","规矩","不变","将","明显","下","date","fn","性","限于","只","时","更新","一种","并非","一部分","仅仅","很多","基本","来","=","所说","caller","pure","是因为","减少","之后","两点","应该","外部","一个","7","与","但是","异步","不得","而","reverse","不仅","不能","产生","更改","silly","达式","写","++","第三","多个","10","每次","push","从","随机","输入输出","来看","不必","无法","带来","两个","例子","相同","作用","常见","实际","前者","自由","回调","务器","document","捕捉","calculateaverage","造成","负面影响","不会","直接","制裁","编程","隐蔽","二次","带有","多次","relative","意义","world","吗","count","lastvalue","return","num","一","max","总而言之","被","容易","副作用","转换","尽量","referential","可能","...","潜伏",">","上","ajax","运算","换句","example","pow","思考","只要","适合","给定","当","be","object","其他","for","其实","没有","俗称","服务器资源","很","有些","transparency","boolean","太","orderhistory","math","string","利于","变化","和","怎样","好处","顺序","ui","可读性","io","避免","肉","the","对换","进去","原","覆盖","一致","第三种","/","这些","update","!","数据","x","返回","之外","我们","给","就","4","起来","lower",";","无论怎样","sum","局限于","console","这","不是","if","自身","就是","round","purely","返回值","ok","array","代码","function","1","表达","9","cylindervolume","显而","满足","修改","为","通过","person","f","42","下列","事实上","才能","区别","所以","-","无论","引用","事实","换句话说","再","3.141592","了解","复制","topower0","已经","第二","不同","当做","之为","东西","资源","defineproperty","remembernumbers","隐式","但","发现","引入","with","还有","提供","0","3",",","程序","一次","属于","原因","算法","const","非幂","执行","您","应当","}","这项","min","库中","name","数学","行为","str","因","contrived","而言","重新分配","三种","变量","换句话","(","作为","类型","在于","updatecounter","比如","大部","他","3.5","getter","纯","可读","在",":","下面","发送","虽然","意味","有利","send","effect","不","let","restapi","输入"],"title":"Side Effects","title_tokens":["side","effects"," "]},{"location":"javascript/fp/side-effect/#_1","text":"副作用意味着您的代码读者需要人肉编译你的代码才能知道某个变量的变化。比如你在某个函数中修改了某个外部变量 副作用还有可能是因为你在返回值中的引用，如果引用的状态发生了变化，函数就产生了副作用。因此，所有影响到函数输出的东西都应该作为函数的输入","text_tokens":["因为","的","所有","，","了","返回","就","才能","变化","人"," ","引用","副作用","还有","某个","可能","肉","编译","变量","是因为","需要","发生","影响","作为","函数","返回值","你","都","。","代码","因此","应该","比如","知道","外部","到","中","意味着","作用","在","如果","您","读者","东西","意味","产生","输出","修改","状态","输入"],"title":"了解副作用","title_tokens":["副作用","了解","作用"]},{"location":"javascript/fp/side-effect/#_2","text":"一个约定俗称的规矩是从不覆盖函数实现，因此函数作为自由变量引用，我们可以当做我们引用了一个常量。 考虑两点，当你有一个函数时 当你给定输入，输出是不变的吗？ 你引入的自由变量每次都是不变的吗？程序中有其他地方可能会修改这个自由变量吗？","text_tokens":["自由","中有","的","，","引入","了","我们","约定","？","会"," ","引用","可能","变量","地方","每次","输入","作为","实现","函数","都","你","给定","当","因此","。","是从","两点","可以","程序","一个","覆盖","其他","规矩","不变","俗称","是","当做","吗","考虑","这个","输出","修改","不","有","时","常量"],"title":"固定状态","title_tokens":["固定","状态"]},{"location":"javascript/fp/side-effect/#_3","text":"随机函数也可能产生副作用。 大部分语言中的随机都是采用伪随机算法，有些语言提供了起始值，因此给定相同的起始值生成的随机序列都是一致的。 但是 js 没有提供这项功能，因此 js 中偶然性也是副作用的一种","text_tokens":["一种","的","采用","起始","功能","，","了","偶然","偶然性","语言","大部分"," ","部分","副作用","可能","提供","生成","也","js","函数","随机","都","伪","给定","。","因此","大部","一致","中","算法","相同","是","作用","但是","没有","这项","序列","产生","起始值","有些"],"title":"偶然性","title_tokens":["偶然","偶然性"]},{"location":"javascript/fp/side-effect/#io-effects","text":"最常见的副作用就是 IO 输入输出 比如 DOM，当我们修改了 DOM 事实上就已经产生了副作用 再比如两个依赖自由变量的 ajax，当异步请求的时候，如果回调执行的顺序不一致，可能会产生 bug，但是我们难以捕捉他们，因为很多时候，这些 bug 只会带来 ui 渲染上的不一致，或者只是简单的状态改变。","text_tokens":["自由","回调","因为","的","，","了","很多","我们","事实上","他们","或者","就","只是","时候","会","最","捕捉"," ","顺序","ui","副作用","io","bug","渲染","事实","可能","上","ajax","再","变量","请求","dom","就是","只会","输入输出","当","依赖","带来","。","两个","比如","已经","一致","改变","作用","常见","但是","异步","如果","执行","难以","产生","简单","输出","这些","修改","不","状态","输入"],"title":"IO Effects","title_tokens":["io","effects"," "]},{"location":"javascript/fp/side-effect/#_4","text":"如果你不得不通过副作用修改状态，制裁他们的一种方式是 幂等性","text_tokens":["一种","的","通过","，","方式","他们"," ","副作用","制裁","不得不","等","你","幂","是","作用","如果","不得","性","修改","状态"],"title":"制裁副作用","title_tokens":["副作用","制裁","作用"]},{"location":"javascript/fp/side-effect/#_5","text":"首先给出一个在 数学 上和 编程 上都 不属于 幂等的例子 function updateCounter ( obj ) { if ( obj . count < 10 ) { obj . count ++ ; return true ; } return false ; }","text_tokens":["数学","的","obj","{","<","return","++","和"," ",";","true","10","上","if","编程","(","都","等",".","updatecounter","function","属于","一个","给出","例子","幂","在",")","false","count","}","不","首先"],"title":"幂等性","title_tokens":["等","性","幂"]},{"location":"javascript/fp/side-effect/#_6","text":"从数学角度来看，幂等性意味着在第一次调用后输出不会改变的操作。 更清晰的例子 f(x) = f(f(x)) = f(f(f(x))) 在 js 内置的 Math 库中，下面这些例子显然是幂等性的。 Math.min(..) Math.max(..) Math.round(..) Math.floor(..) Math.ceil(..) 我们也可以自己定义一些幂等性的运算 function toPower0 ( x ) { return Math . pow ( x , 0 ); } function snapUp3 ( x ) { return x - ( x % 3 ) + ( x % 3 > 0 && 3 ); } toPower0 ( 3 ) == toPower0 ( toPower0 ( 3 ) ); // true snapUp3 ( 3.14 ) == snapUp3 ( snapUp3 ( 3.14 ) ); // true 数学角度的幂等性并不仅仅局限于数学运算，来看看 js 基本类型强制转换 var x = 42 , y = \"hello\" ; String ( x ) === String ( String ( x ) ); // true Boolean ( y ) === Boolean ( Boolean ( y ) ); // true 或者是 function upper ( x ) { return x . toUpperCase (); } function lower ( x ) { return x . toLowerCase (); } var str = \"Hello World\" ; upper ( str ) == upper ( upper ( str ) ); // true lower ( str ) == lower ( lower ( str ) ); // true 总而言之，幂等性就是满足下列公式的数学表达式 f(x) = f(f(x))","text_tokens":["达式","，","x","操作","我们","lower",";","局限于","更","显然","公式","清晰","就是","round","从","来看","var","function","y","例子","表达","幂","满足","定义","输出","第一次","..","tolowercase","f","42","下列","或者","自己","-","强制","true","表达式","不会","&&","。","topower0","ceil","world",")","\"","3.14","return","不仅仅","调用","max","touppercase","总而言之"," ","+","hello","转换",">","0","一些","运算","3","js","pow",",",".","一次","改变","后","是","snapup3","}","性","限于","min","角度","库中","数学","boolean","的","局限","math","仅仅","string","upper","floor","基本","来","str","而言","也","看看","=","(","内置","等","类型","可以","意味着","在","下面","/","意味","并","不仅","这些","%","第一","{"],"title":"数学上的幂等性","title_tokens":["数学","的","等","上","性","幂"]},{"location":"javascript/fp/side-effect/#_7","text":"程序中的幂等性没有那么正式，换句话说，第一次调用 f(x) 与第二次调用的返回值没有区别。 就像在 Http 的 RESTapi 中，PUT 被定义为更新服务器资源，当我们发送了多个带有相同数据的 PUT 时，服务器资源都应该具有相同的结果状态 // idempotent:幂等性 obj . count = 2 ; a [ a . length - 1 ] = 42 ; person . name = upper ( person . name ); // non-idempotent:非幂等性 obj . count ++ ; a [ a . length ] = 42 ; person . lastUpdated = Date . now (); 在这里，幂等性的概念是，在第一次调用之后，后续无论怎样的重复调用，程序状态都不会改变。而非幂等性每次调用都会更改程序状态。 那么在 DOM 更新中如何表现呢？ var hist = document . getElementById ( \"orderHistory\" ); // idempotent: hist . innerHTML = order . historyText ; // non-idempotent: var update = document . createTextNode ( order . latestUpdate ); hist . appendChild ( update ); // 隐式的，当前状态是下一状态的一部分 我们并不能总是幂等的定义我们的操作，但这有利于减少副作用的影响","text_tokens":["latestupdate","obj","数据","hist","，","x","操作","返回","我们","++","正式","就",";","无论怎样","多个","innerhtml","historytext","后续","这","每次","dom","non","返回值","var","getelementbyid","1","第二次","表现","幂","相同","那么","作用","这里","定义","order","第一次","idempotent","概念","为","服务器","person","f","务器","42","document","了","区别","会","-","无论","部分","有利于","换句话说","不会","createtextnode","a","影响","二次","都","。","带有","now","put","第二","中",")","http","count","资源","\"","当前","隐式","但","[","一","调用","结果","？"," ","被","副作用","像","length","2","换句","更改","呢",".","程序","一次","当","一部","总是","改变","没有","是","非幂","非","下","date","]","性","服务器资源","状态","更新","时","name","的","一部分","orderhistory","upper","如何","利于","怎样","重复","具有","=","换句话","(","减少","之后","等","lastupdated","应该","appendchild","与","在","而",":","发送","/","并","有利","不能","第一","update","服务","restapi"],"title":"程序中的幂等性","title_tokens":["的","等","程序","性","幂","中"]},{"location":"javascript/fp/side-effect/#pure-bliss","text":"一个没有副作用的函数我们称之为 Pure Function 纯函数在编程角度来说是幂等的，因为没有任何副作用 let add = ( a , b ) => a + b 可以发现所有的输入输出都是直接的，没有引用任何自由变量，多次调用 add 函数与只调用一次没有任何区别。所以 add 是一个幂等纯函数。 但是在数学意义中，不是所有纯函数都是幂等的，因为他们不必返回适合他们的输入的输出。 function calculateAverage ( nums ) { var sum = 0 ; for ( let num of nums ) { sum += num ; } return sum / nums . length ; } calculateAverage ( [ 1 , 2 , 4 , 7 , 11 , 16 , 22 ] ); // 9 返回值并非一个数组，因此不可能 calculateAverage(calculateAverage(nums)) 纯函数也可以引用自由变量和函数值，只要这个变量是没有副作用的。 const PI = 3.141592 ; function circleArea ( radius ) { return PI * radius * radius ; } function cylinderVolume ( radius , height ) { return height * circleArea ( radius ); } 另一个纯函数引用自由变量的例子就是 闭包 虽然 fn 是一个函数对象，我们可以给他分配属性「突变」，但是这不影响函数值调用，因此只要不重新分配函数，他就无副作用。 表达纯函数的另一种方式是，给他相同的输入，他总是产生相同的输出。 如果一个函数给相同的输入产生不同的输出，那么就不是一个纯函数。产生副作用也是不纯的。 在 js 中，产生副作用实在是太容易了。","text_tokens":["因为","，","返回","我们","他们","给","就","4",";","sum","值","这","不是","circlearea","就是","返回值","输入输出","不必","var","因此","function","1","例子","表达","幂","b","相同","9","作用","cylindervolume","那么","如果","不纯","这个","输出","自由","radius","所有","突变","了","重新","区别","所以","height","引用","calculateaverage","直接","编程","a","3.141592","影响","都","。","多次","*","不同","中","意义","add",")","分配","之为","闭包","属性","22","对象","return","[","num","称之为","发现","调用","实在"," ","+","容易","副作用","可能",">","0","length","2","pi","nums","js",",","16","数组",".","只要","适合","一次","of","总是","for","const","没有","是","来说","}","]","fn","只","11","角度","一种","数学","并非","的","太","方式","和","」","重新分配","也","=","变量","(","pure","另","函数","等","可以","一个","他","7","与","纯","但是","在","「","/","虽然","任何","无副作用","产生","不","let","{","输入"],"title":"Pure Bliss","title_tokens":["pure","bliss"," "]},{"location":"javascript/fp/side-effect/#purely-relative","text":"function rememberNumbers ( nums ) { return function caller ( fn ){ return fn ( nums ); }; } var list = [ 1 , 2 , 3 , 4 , 5 ]; var simpleList = rememberNumbers ( list ); simpleList 看起来像是一个纯函数，实际上并不是， function median ( nums ) { return ( nums [ 0 ] + nums [ nums . length - 1 ]) / 2 ; } simpleList ( median ); // 3 // .. list . push ( 6 ); // .. simpleList ( median ); // 3.5 显而易见，当我们修改数组，他的返回值就发生了变化。 我们可以通过复制数组让他变成纯函数。 function rememberNumbers ( nums ) { // make a copy of the array nums = [... nums ]; return function caller ( fn ){ return fn ( nums ); }; } 但是可能会有一个更隐蔽的副作用潜伏。 var list = [ 1 , 2 , 3 , 4 , 5 ]; // make `list[0]` be a getter with a side effect Object . defineProperty ( list , 0 , { get : function (){ console . log ( \"[0] was accessed!\" ); return 1 ; } } ); var simpleList = rememberNumbers ( list ); // [0] was accessed! 因此，我们可以通过这样 function rememberNumbers (... nums ) { return function caller ( fn ){ return fn ( nums ); }; } var simpleList = rememberNumbers ( ... list ); // [0] was accessed! 这样做的好处是，rememberNumbers 是纯函数，造成副作用的原因在于 ... 纯函数 + 不纯函数 = 不纯函数 // yes, a silly contrived example :) function firstValue ( nums ) { return nums [ 0 ]; } function lastValue ( nums ) { return firstValue ( nums . reverse () ); } simpleList ( lastValue ); // 5 list ; // [1,2,3,4,5] -- OK! simpleList ( lastValue ); // 1 reverse() 方法其实修改了原本的数组 所以我们可以这样做 function rememberNumbers (... nums ) { return function caller ( fn ){ // send in a copy! return fn ( [... nums ] ); }; } 传递一个复制了的数组来避免接受的函数在行为上改变原数组。 但是我们仍然无法保证我们传递一个不纯的函数进去。因此，我们只能尽量的让函数 pure，这能提高可读性","text_tokens":["!","，","side","返回","我们","就","list","4","起来",";","显而易见","console","was","make","更","不是","5","像是","push","返回值","ok","var","array","因此","无法","function","1","作用","显而","不纯","实际","log","让","修改","..","simplelist","仍然","这能","通过","了","实际上","所以","会","get","-","只能","造成","易见","传递","a","隐蔽","。","复制","6","in",")","defineproperty","\"","变成","看起来","这样","remembernumbers","有","`","保证","lastvalue","return","[","yes","with","接受"," ","+","副作用","尽量","可能","...","潜伏","做","上","0","length","2","方法","提高","example","3","nums",",","数组","copy",".","当","看起","of","be","原因","object","其实","改变","accessed","是","原本","}","fn","]","的","行为","变化","好处","来","避免","可读性","contrived","the","median","firstvalue","=","caller","进去","(","pure","发生","原","函数","在于","可以","一个","3.5","他","getter","纯","可读","但是","在",":","reverse","/","并","send","effect","不","silly","{"],"title":"Purely Relative","title_tokens":["purely","relative"," "]},{"location":"javascript/fp/side-effect/#referential-transparency","text":"判断一个函数是否纯净的第三种方式，是 Referential transparency。如果将一个函数和他的输出对换，行为上没有任何变化，那么就是纯函数。","text_tokens":["的","方式","，","行为","变化","和"," ","第三","纯净","referential","对换","三种","上","就是","函数","是否","。","一个","判断","他","第三种","是","没有","将","那么","如果","纯","任何","输出","transparency"],"title":"Referential transparency","title_tokens":["referential","transparency"," "]},{"location":"javascript/fp/why-fp/","text":"近年来，主流开发模式从独立开发转变成多人协同，对代码的可读性的要求增加。 函数式编程带来的好处 ¶ 可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。 命令式 => 声明式的转变 ¶ 命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。 代码中的平衡 ¶ 熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["因为","数据","过度","，","我们","++","i","4","人",";","bug","声明","技术细节","更","成本","循环","从","代码","带来","栗子","1","多人","式","才","map","读者","让","协同","熟练","化","所有","干","了","时候","会","数据流","掌握","潜意识","开发","编程","去","主流","更易","命令式","都","近年","。","什么","技术","维护性","中","取得","一目了然","维护","可维护性","不由自主","对比","m",")","得","变成","[","发现","一下","结果","平衡","看出"," ","...",">","0","length","2","事情","3",",","每",".","总是","细节","知道","for","要求","不由","更少","是","转变成","明显","一步","arr","强","自主","}","]","对","转变","迫不得已","的","<","增加","深入","了然","天然","关心","好处","和","来","可读性","不得已","」","熟练掌握","¶","也","=","(","近年来","函数","意识","年来","命令","阅读","可以","必须","应该","一个","一目","意味着","可读","在","而","不得","下面","「","模式","/","独立","并","意味","举个","不","let","{"],"title":"Why FP","title_tokens":["fp","why"," "]},{"location":"javascript/fp/why-fp/#_1","text":"可读性强 可维护性 天然 bug 更少更易发现 举个栗子 来对比一下下面的代码 // 1. let arr = [ 1 , 2 , 3 , 4 ] arr . map ( m => { //... }) // 2. let arr = [ 1 , 2 , 3 , 4 ] for ( let i = 0 ; i < arr . length ; i ++ ) { // arr[i] ... } 明显可以看出 map 一目了然，因为在阅读 for 循环的时候，我们会不由自主，也迫不得已的深入代码细节，潜意识会去知道每一步循环干了什么。","text_tokens":["因为","，","我们","++","i","4",";","bug","循环","代码","栗子","1","map","干","了","时候","会","潜意识","去","更易","什么","。","维护性","维护","可维护性","一目了然","不由自主","对比","m",")","[","发现","一下","看出"," ","...",">","0","length","2","3",",","每",".","细节","知道","for","不由","更少","一步","明显","arr","强","自主","}","]","迫不得已","的","<","深入","了然","天然","来","可读性","不得已","也","=","(","意识","阅读","可以","一目","可读","在","不得","下面","/","举个","let","{"],"title":"函数式编程带来的好处","title_tokens":["式","的","函数","带来","编程","好处"]},{"location":"javascript/fp/why-fp/#_2","text":"命令式的代码总是让读者「过度的」关心技术细节。 而声明式的代码让人更关心数据流和结果。","text_tokens":["的","数据","过度","结果","关心","人"," ","和","数据流","」","声明","技术细节","更","命令式","命令","总是","。","代码","技术","细节","式","而","读者","「","让"],"title":"命令式 =&gt; 声明式的转变","title_tokens":[";","式","gt","的","命令式","声明","命令","&","=","转变"," "]},{"location":"javascript/fp/why-fp/#_3","text":"熟练掌握函数式编程并不意味着所有的代码都必须得函数化。 取得一个开发和维护的成本的平衡才是我们应该去关心的事情。","text_tokens":["的","熟练","化","所有","我们","平衡","关心","和"," ","掌握","熟练掌握","开发","编程","成本","去","事情","函数","都","。","代码","必须","应该","一个","取得","式","维护","才","意味着","是","得","意味","并","不"],"title":"代码中的平衡","title_tokens":["代码","平衡","的","中"]},{"location":"javascript-ecosystem/introduction/","text":"","text_tokens":[],"title":"Getting Started","title_tokens":["started","getting"," "]},{"location":"skills/introduction/","text":"简介 ¶","text_tokens":["¶"," ","简介"],"title":"Getting Started","title_tokens":["started","getting"," "]},{"location":"skills/introduction/#_1","text":"","text_tokens":[],"title":"简介","title_tokens":["简介"]},{"location":"skills/git/git-cz/","text":"why git cz ¶ 给 git commit 添加一段简短有意义且规范的描述 组成 ¶ 一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中 type ¶ feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变 scope ¶ 说明本次代码影响的范围（文件、文件夹） subject ¶ 简短描述 body ¶ 当代码需要一些说明时 foot ¶ 可以用来跟踪 issue 的 ID ，如 Close #123 方便的库 ¶ npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["功能","，","foot","过程","标准","给","就","i","footer","如","且","测试","bug","init","去掉","close","config","npm","blank","本次","全局","代码","跟踪","scripts","#","修改","然后","line","通过","方便","了","或者","目录","-","工具","只有","部分","包括","换行","安装","exact","需要","影响","refactor","简短","feat","。","commitizen","package","范围","运行","中","意义","库","type","一段",")","文档","几个","\"","docs","文件","有","fix","chore","changelog","json","commit"," ","修复","说明","提高",">","一些","g","文件夹","git","提交","cz","perf","）",".","当","style","body","新","、","其中","改变","没有","subject","}","用来","构建","（","组成","run","时","的","<","test","id","scope","描述","件夹","path","添加","来","空格","¶","也","项目","issue","save","(","conventional","可以","应该","一个","why","123","在",":","下面","规范","并","性能","{"],"title":"git-cz","title_tokens":["cz","-","git"]},{"location":"skills/git/git-cz/#why-git-cz","text":"给 git commit 添加一段简短有意义且规范的描述","text_tokens":["git","且","意义","的","一段","简短","规范","描述","给","添加","有","commit"," "],"title":"why git cz","title_tokens":["cz","why","git"," "]},{"location":"skills/git/git-cz/#_1","text":"一个标准的 commit 应该包括下面几个部分 <type> ( <scope> ): <subject> <BLANK LINE > <body> <BLANK LINE > <footer> 其中","text_tokens":["的","<","line","scope","标准","footer","commit"," ","部分","包括",">","(","blank","body","应该","其中","一个","type","subject",")",":","下面","几个"],"title":"组成","title_tokens":["组成"]},{"location":"skills/git/git-cz/#type","text":"feat 新功能 fix 修复 Bug docs 只有文档改变 style 并没有影响代码的意义(去掉空格，换行) refactor 没有修改 Bug 也没有提交新功能 perf 代码修改提高性能 test 添加测试 chore 构建过程或者构建工具的改变","text_tokens":["fix","的","test","功能","，","过程","或者","chore","添加"," ","工具","只有","空格","测试","修复","bug","提高","换行","去掉","也","(","提交","影响","refactor","perf","feat","style","代码","新","改变","意义","没有",")","文档","并","构建","docs","修改","性能"],"title":"type","title_tokens":["type"]},{"location":"skills/git/git-cz/#scope","text":"说明本次代码影响的范围（文件、文件夹）","text_tokens":["影响","的","本次","）","说明","代码","、","（","文件","件夹","范围","文件夹"],"title":"scope","title_tokens":["scope"]},{"location":"skills/git/git-cz/#subject","text":"简短描述","text_tokens":["描述","简短"],"title":"subject","title_tokens":["subject"]},{"location":"skills/git/git-cz/#body","text":"当代码需要一些说明时","text_tokens":["需要","说明","当","代码","一些","时"],"title":"body","title_tokens":["body"]},{"location":"skills/git/git-cz/#foot","text":"可以用来跟踪 issue 的 ID ，如 Close #123","text_tokens":["123","的","#","id","，","跟踪","用来","可以","issue","close","如"," "],"title":"foot","title_tokens":["foot"]},{"location":"skills/git/git-cz/#_2","text":"npm i -g commitizen 全局安装 commitizen commitizen init cz-conventional-changelog --save --save-exact 项目目录中运行 在 package.json 中添加 \"config\" : { \"commitizen\" : { \"path\" : \"cz-conventional-changelog\" } } \"scripts\" : { \"commit\" : \"git-cz\" } 然后就可以通过 npm run commit 来运行了。","text_tokens":["通过","了","path","目录","就","i","changelog","json","添加","-"," ","commit","来","init","项目","g","save","config","git","安装","npm","exact","cz",".","全局","。","scripts","commitizen","conventional","package","可以","运行","中","在",":","}","\"","然后","run","{"],"title":"方便的库","title_tokens":["方便","的","库"]}]}